\documentclass[11pt,a4paper,oneside]{book}

\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{chngpage}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{alltt}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{wrapfig}

\lstset{tabsize = 2, mathescape}

\theoremstyle{definition}
\newtheorem{definition}{Definizione}[section]

\begin{document}
\title{Reti di Calcolatori}
\author{Francesco Iannelli\thanks{Stesura originale}
\and
unipi-notes @ GitHub\thanks{Aggiornamento anno accademico 2020-2021}
}
\maketitle

\setcounter{tocdepth}{5}
\tableofcontents

\pagebreak

\chapter{Introduzione}
Questi appunti, originariamente scritti per l'anno accademico 2019-2020, sono in corso di aggiornamento per poter includere i contenuti del corso più recente.

\section{Cenni di modelli stratificati}
Sono architetture di comunicazione a strati. \newline
Concetti generali:
\begin{itemize}
	\item Stratificazione
	\item Information hiding
	\item Separation of concerns
\end{itemize}
Vantaggi della stratificazione:
\begin{itemize}
	\item \textbf{Facilità di progettazione.}
	\item \textbf{Facilità di manutenzione.}
	\item \textbf{Possibilità di riciclo.}
\end{itemize}
Due modelli: \textbf{ISO/OSI} (approccio top-down) e \textbf{Stack TCP/IP} (approccio bottom-up), quest ultimo vincente.\newline
Idea chiave: \underline{suddivisone in sottoproblemi.}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/Modelli_Strat.png}
	\centering
	\caption{Modello stratificato.}
\end{figure}

\pagebreak

\subsection{Livello applicativo}
Fanno parte del livello applicativo:
\begin{itemize}
	\item Identificativi delle risorse: \textbf{URL}, \textbf{URI} e \textbf{URN}.
	\item Il \textbf{web}: user agents, protocollo http.
	\item \textbf{Protocollo FTP}.
	\item \textbf{TELNET}: servizio di terminale virtuale.
	\item \textbf{Posta elettronica}.
	\item Sistema dei nomi \textbf{DNS} a dominio e la risoluzione dei nomi: iterativa e ricorsiva.
	\item molto altro ancora$\dots$
\end{itemize}

\subsection{Livello di trasporto}
Due tecnologie degne di nota:
\begin{enumerate}
	\item Protocollo \textbf{TCP}: \textbf{connection-oriented}, \textit{orientato alla connessione}.
	\item Protocollo \textbf{UDP}: \textbf{connection-less}, molto più leggero, prende dati applicativi e li affida allo strato IP, \underline{NON} da garanzie di consegna nè di ordine.
\end{enumerate}

\subsection{Livello rete}
Nel \textbf{livello di rete si ricava un percorso dall'host sorgente all'host destinatario} usando le informazioni che si trovano nell'IP.\newline
Verrà trattato il protocollo Ipv4 e introdotto il protocollo Ipv6.

\subsection{Livello link}
Si occupa di gestire il collegamento tra due nodi \textbf{adiacenti}.
La tecnologia principale è l'\textbf{ethernet}.


\section{Introduzione alle reti}
\textit{Cos'è una rete? Quante tipologie di reti ci sono? Cos'è internet?}

\theoremstyle{definition}
\begin{definition}
	Una \textbf{rete} è un'interconnessione di dispositivi in grado di scambiarsi e interpretare le informazioni. Comprende sistemi terminali e intermedi: \textit{e.g.\ \  router, switch e modem.}
\end{definition}
I sistemi terminali si possono dividere in due tipi: \textbf{host} e \textbf{server}, sull'host girano le applicazioni utente mentre il server esegue programmi che forniscono servizi applicativi ad applicazioni. \newline \textit{N.B. il termine host può essere usato per indicare anche un server. \newline L'host, infatti, può essere sia un server sia il terminale di un utente che esegue un'applicazione client, più generalmente \textbf{l'host è una macchina}.}

\theoremstyle{definition}
\begin{definition}
	Una rete è formata da \textbf{dispositivi} e da \textbf{tecnologie}.
\end{definition}

\subsection{LAN}
Acronimo di \textbf{L}ocal \textbf{A}rea \textbf{N}etwork, è
una rete di area geografica limitata collegata attraverso una tecnologia ethernet \textbf{bus} o ethernet \textbf{switch}: ciascun host ha un cavo che lo collega allo switch e a ogni porta dello switch corrisponde un host. Lo \textbf{switch} possiede una tecnologia di autoapprendimento ed è una componente del \textbf{livello link}.
\begin{figure}[!h]
	\includegraphics[scale=0.62]{Immagini/LAN.png}
	\centering
	\caption{In figura due modelli diversi di LAN.}
\end{figure}

\pagebreak

\subsection{WAN}
Acronimo di \textbf{W}ide \textbf{A}rea \textbf{N}etwork, è una rete di area geografica estesa: è composta da due o più reti collegate tramite un mezzo di trasmissione. Le reti coinvolte potrebbero anche essere reti LAN. \textit{(e il link potrebbe essere affittato a un'azienda da un operatore di telefonia).}
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/WAN_Switch.png}
	\centering
	\caption{Un esempio di WAN a cavo condiviso e a commutazione.\newline
		Queste WAN permettono l'esistenza di \textbf{percorsi alternativi} e la \textbf{divisione del traffico}. Una \textbf{WAN punto punto} invece ha \textbf{solo} 2 punti di terminazione.}
\end{figure}


\subsection{Internetwork}
L'internetwork è un sistema in cui ci sono più reti composte, capaci di scambiarsi informazioni e collegate. Concettualmente è una WAN ma è più complicata.
I dispositivi che la compongono si distinguono in \textbf{sistemi terminali}
e dispositivi come gli \textbf{switch} e i \textbf{routers} che si trovano nel percorso tra i sistemi sorgente e i sistemi destinazione.
\begin{figure}[!h]
	\includegraphics[scale=0.45]{Immagini/Internetwork.png}
	\centering
	\caption{Una internetwork.}
\end{figure}\newline
\textit{Problema: come mandare informazioni da un host a un altro?}


\subsubsection{Reti a commutazione di circuito}
Nelle \textbf{reti a commutazione di circuito} le \textbf{risorse} sono \textbf{riservate end to end} per ogni connessione. Risulta quindi necessario il \textbf{setup della comunicazione} per instaurare la connessione ed elargire le risorse.\newline
La risorsa non è tutto il link, bensì si considerano come risorse la capacità o la larghezza di banda porzionate per ogni connessione. Le risorse assegnate rimangono inattive se non utilizzate (\textit{e.g.\  telefonata}). I dispositivi mantengono lo stato della connessione. \textbf{Le performance sono garantite}. La capacità delle linee (\textit{link}) cambia a seconda della loro funzione all'interno della rete. Il \textbf{punto debole} delle reti a commutazione di circuito è la \textbf{poca flessibilità nel dispiegamento delle risorse}.


\subsubsection{Reti a commutazione di pacchetto}
Nelle \textbf{reti a commutazione di pacchetto} gli utenti inviano pacchetti che condividono le risorse del canale di comunicazione. \textbf{Non c'è} quindi \textbf{un canale dedicato} ai pacchetti di un singolo utente. La principale differenza rispetto alla commutazione di circuito risiede nell'implementazione della logica dei dispositivi di interconnessione, ovvero:
\begin{itemize}
	\item \textbf{Commutazione di Circuito}: avviene il \textbf{setup} della connessione dove  si prealloca l’utilizzo del collegamento trasmissivo con collegamenti
	      garantiti.
	\item \textbf{Commutazione di Pacchetto}: non viene instaurata una connessione bensì le informazioni necessarie si trovano all'interno dei pacchetti stessi, non ci sono informazioni di connessione memorizzate nei dispositivi coinvolti.
\end{itemize}
Nelle reti a commutazione di pacchetto quindi le risorse vengono usate a seconda della necessità. Possono quindi verificarsi situazioni di contesa delle risorse e sussiste il pericolo di congestione o di perdita dei pacchetti nel caso in cui la dimensione della coda del router non fosse sufficiente a contenere il flusso dei pacchetti entranti: il commutatore (\textit{router}) deve infatti ricevere l’intero
pacchetto prima di poter cominciare a trasmetterlo sul collegamento in uscita (\textit{\textbf{store and forward}}). \textbf{Non sono} quindi \textbf{garantite le prestazioni}.
\subsubsection{Circuiti virtuali}
I circuiti virtuali funzionano nel seguente modo: viene stabilito un path tra host sorgente e host destinazione e tutti i pacchetti di un certo flusso seguono lo \textbf{stesso} path.

\pagebreak

\subsubsection{Datagram Network}
Con \textbf{datagram} si indica un'entità informativa autocontenuta che contiene le informazioni sufficienti per essere indirizzata alla destinazione senza comunicazioni aggiuntive tra sorgente e destinazione: \textbf{non è quindi detto} che pacchetti di uno stesso flusso seguano lo stesso path sulla rete.
\begin{figure}[!h]
	\includegraphics[scale=0.17]{Immagini/Circuit_switch.png}
	\centering
	\caption{Rete a commutazione di circuito.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Packet_Switch.png}
	\centering
	\caption{Rete a commutazione di pacchetto. Notare le diverse capacità dei link.}
\end{figure}

\subsubsection{Packet Switch e Circuit Switch a confronto}
Vi sono 35 utenti su una rete con 100 Kbit/s di connessione e un link da 1 Mbit/s.
Ogni utente è attivo solo il 10\% del tempo. Con una \textbf{rete a commutazione di circuito} si riescono a gestire \textbf{solo} 10 utenti. Con una \textbf{rete a commutazione di pacchetto} si hanno i seguenti casi:
\begin{enumerate}
	\item 10 o meno utenti attivi: \textbf{nessun problema}.
	\item Più di 10 utenti attivi: \textbf{ritardo}.
\end{enumerate}
Tuttavia che gli utenti siano tutti e 35 attivi contemporaneamente è poco probabile (infatti $P(35) = 0.0004$).
Se ne deduce che la rete a commutazione di pacchetto riesce a gestire tutti gli utenti contemporaneamente nella maggior parte dei casi.
Nonostante il risultato ottenuto \textbf{non} si deve pensare che la rete a  commutazione di circuito sia obsoleta. Nel corso degli anni infatti le due tecnologie sono state \textbf{integrate} in vari modi. La commutazione di circuito infatti è usata nella telefonia fissa (\textit{PSTN: public switch telephone network}) per i servizi voce, la commutazione di pacchetto invece per i dati. Nelle reti ottiche di prima e seconda generazione si usano entrambe le tecnologie.

\pagebreak

\subsection{Internet}
\textit{Come interconnettere reti già esistenti?}
\theoremstyle{definition}
\begin{definition}
	Una internet (con i minuscola) è una rete costituita da
	due o più reti interconnesse.
\end{definition}
La internet più famosa è chiamata \textbf{Internet} (con i maiuscola) ed è composta da migliaia di reti interconnesse. Ogni rete connessa ad Internet deve usare il protocollo IP e rispettare certe convenzioni su come vengono assegnati nomi e indirizzi.
Si possono facilmente aggiungere nuove reti. \newline Tuttavia è impensabile avere un link fisico tra ogni host, si hanno invece numerosi
dispositivi di interconnessione che permettono la comunicazione da un host all'altro e da un router all'altro.\newline
Uno scorcio delle \textbf{componenti di Internet}:
\begin{itemize}
	\item Miliardi di \textbf{dispositivi interconnessi} (e.g.\  hosts, end systems).
	\item \textbf{Link di comunicazione} (e.g.\  fibre ottiche, doppini telefonici,
	      cavi coassiali, onde radio).
	\item \textbf{Routers}: instradano pacchetti \textit{(sequenze)} di dati attraverso la rete.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Internet.png}
	\centering
	\caption{Una porzione di Internet}
\end{figure}
Uno scorcio delle \textbf{entità software} di Internet:
\begin{itemize}
	\item Applicazioni e processi che elaborano le informazioni.
	\item \textbf{Protocolli} che regolamentano la trasmissione e la ricezione di informazioni e.g.\  TCP, IP, HTTP, FTP, PPP.
	\item Interfacce: verranno definite in seguito, sono le \textit{“membrane”} che separano gli \textit{"strati"}.
\end{itemize}

\pagebreak

\subsubsection{Servizi}
L’\textbf{infrastruttura di comunicazione} consente il funzionamento delle applicazioni distribuite per scambio di informazioni \textit{(e.g.\  WWW, email, giochi, e-commerce, database, controllo remoto, ecc).}\newline
Lo \textbf{stack protocollare} offre il servizio di connessione. Vi sono due approcci:
\begin{enumerate}
	\item \textbf{Connection-less}: I dati vengono trasferiti \textbf{senza} stabilire una
	      connessione, non c'è nessuna garanzia di ordine e consegna. \textit{Ogni pacchetto ha una vita a sè.}
	\item \textbf{Connection-oriented}: Prevede l'\textbf{instaurazione della connessione}, il trasferimento dei dati e, in seguito, la chiusura della connessione. Garantisce integrità, completezza e ordine.
\end{enumerate}

\subsubsection{IETF/RFC/ICANN}

\theoremstyle{definition}
\begin{definition}
	L'IETF (Internet Engineering Task Force) è l’organismo che studia e sviluppa i protocolli in uso su Internet. Si basa su gruppi di lavoro a cui chiunque può accedere.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	RFC/STD (Request For Comments \& STanDards) sono i documenti \textit{“ufficiali” } che descrivono i protocolli usati su Internet. Sono pubblicamente accessibili in rete.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	ICANN (Internet Corporation for Assigned Names and Numbers) È un ente internazionale che coordina il sistema dei nomi di dominio (DNS), assegna i gruppi di indirizzi di rete, gli identificativi di protocollo e ha funzioni di controllo (blando) sullo sviluppo di Internet.
\end{definition}

\subsubsection{Rete di accesso}
Internet è una internetwork che consente a qualsiasi utente
di farne parte. L’utente, tuttavia, deve essere fisicamente collegato a un
ISP (\textit{internet service provider}).
\theoremstyle{definition}
\begin{definition}
	Il collegamento che connette l'utente al primo router di internet è detto \textbf{rete di accesso}, suddetto collegamento può essere effettuato tramite rete telefonica, rete wireless o tramite accesso diretto.
\end{definition}
\begin{itemize}
	\item \textbf{Accesso via rete telefonica}: servizio dial-up, ADSL o Asymmetric Digital Subscriber Line e fibra ottica.
	\item \textbf{Accesso tramite reti wireless}.
	\item \textbf{Collegamento diretto}: collegamenti WAN dedicati ad alta velocità e.g.\  aziende o
	      università.
\end{itemize}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Internet_Concept.png}
	\centering
	\caption{Un modello concettuale di Internet.}
\end{figure}

\section{Metriche di riferimento}
\textit{Come misurare le prestazioni di una rete?}\newline

\theoremstyle{definition}
\begin{definition}
	La \textbf{larghezza di banda} o \textbf{bandwidth} è la larghezza dell'intervallo di frequenze utilizzato dal sistema trasmissivo.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	Il \textbf{bit rate} o \textbf{trasmission rate} è la quantità di dati che possono essere trasmessi o ricevuti nell'unità di tempo. [e.g.\  bps = bit/s]\newline
	Il bitrate dipende dalla tecnica trasmissiva ed è proporzionale alla larghezza di banda.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	Il \textbf{throughput} è la quantità di traffico che arriva realmente a destinazione nell'unità di tempo, al netto di perdite sulla rete,
	del funzionamento dei protocolli etc.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	La \textbf{latenza} o \textbf{latency} è il tempo che passa dal momento in cui il primo bit parte dalla sorgente al momento in cui l'intero messaggio arriva a destinazione.
	\begin{center}
		\fbox{\Large{$L = r_{propagazione} + r_{trasmissione} + r_{accodamento} + r_{elaborazione}$}}
	\end{center}
\end{definition}

\theoremstyle{definition}
\begin{definition}
	Il \textbf{volume di un link} è il numero massimo di bit che il link può contenere.
\end{definition}

{\centering\fbox{$Volume = bit rate\times ritardo$} \par}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Link_Volume.png}
	\centering
\end{figure}

\pagebreak

\subsection{Ritardi}
Il ritardo introdotto da un nodo è la somma di questi 4 ritardi:
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Ritardi.png}
	\centering
	\caption{Una visione di contesto}
\end{figure}

\subsubsection{Ritardo di elaborazione del nodo}
Il ritardo di elaborazione \textbf{è causato dall'elaborazione del percorso} (ovvero dove inoltrare il pacchetto scegliendo il percorso \textit{"migliore"}) \textbf{e dal controllo di errori sui bit}, è \textbf{tipicamente piccolo e trascurabile}.

\subsubsection{Ritardo di accodamento}
Il ritardo di accodamento \textbf{è il tempo che un pacchetto passa nella coda del router}, dipende dall'intensità e dal tipo di traffico. I pacchetti si accodano nei buffer dei router se il tasso di arrivo dei pacchetti eccede la capacità del collegamento di inoltrarli. Se non ci sono spazi liberi i pacchetti in arrivo vengono scartati.

\subsubsection{Ritardo di trasmissione}
Il ritardo di trasmissione \textbf{è il tempo impiegato a trasmettere un pacchetto intero} sul link.\newline
$R$ = rate di trasmissione del collegamento.\newline
$L$ = lunghezza del pacchetto.\newline

{\centering$r_{trasmissione} = \frac{L}{R}$ \par}

\subsubsection{Ritardo di propagazione}
Il ritardo di propagazione \textbf{è il tempo impiegato da un bit per essere propagato da un nodo (router) all'altro}.\newline
$d$ = lunghezza del collegamento fisico\newline
$s$ = velocità di propagazione del collegamento fisico \newline

{\centering$r_{propagazione} = \frac{d}{s}$ \par}

\subsection{Esempi}
Si consideri l'invio di un file di 1 MBit su un datalink di lunghezza 4800km:\newline
$d = 4800\times10^3 m$ \newline
$s = 3\times10^8 m/s$ \newline
Si calcoli il ritardo di propagazione. \newline
Soluzione:\newline\newline
$r_{propagazione} = \frac{d}{s} = \frac{4800\times10^3 m }{3\times10^8 m/s}  = 0.016$ secondi.\newline\newline
Sia il trasmission rate pari a 64 kbps, si calcoli il ritardo di trasmissione. \newline\newline
$r_{trasmissione} = \frac{L}{R} = \frac{10^6 bit}{64\times10^3 bps}= 15.625$ secondi.\newline\newline
Se il trasmission rate fosse invece di 1 Gbps? \newline\newline
$r_{trasmissione} = \frac{L}{R} = \frac{10^6 bit}{10^9 bps} = 0.001$ secondi.

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Esempio_ritardi.png}
	\centering
\end{figure}
Si calcoli il ritardo end-to-end di un pacchetto sul percorso con i router A e B. Sia trascurabile il ritardo di congestione e si suppongano uguali su tutti link il propagation delay, il transmission delay e il processing delay.\newline\newline
\textbf{Soluzione}:\newline Essendoci due router intermedi bisongna attraversare tre link, quindi:

{\centering $r_{totale} = 3\times r_{propagation} + 3\times r_{trasmission} + 3\times r_{processing}$ \par}

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Soluzione_ritardi.png}
	\centering
	\caption{Quello che succede in dettaglio nell'esempio precedente.}
\end{figure}

\pagebreak

\chapter{Modelli Stratificati e Protocolli}
\textit{Cos'è un protocollo? Cos'è uno strato?}

\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Postale.png}
	\centering
	\caption{Esempio di stratificazione. Si nota come i vari strati del modello interagiscono tra di loro, dal basso verso l'alto e viceversa, per consentire al sig. Rossi e al sig. Takamura di scambiarsi lettere.}
\end{figure}
\textbf{\underline{Vademecum per la lettura del seguente contenuto:}}:
\begin{enumerate}
	\item Gli strati comunicano \textit{(di solito)} \textbf{solo} con gli altri strati a loro adiacenti.
	\item Uno strato \textbf{fornisce} servizi allo strato superiore e \textbf{riceve} servizi da quello inferiore.
	\item La comunicazione tra strati adiacenti avviene attraverso un'\textbf{interfaccia}.
	\item Tra due entità diverse comunicano fra di loro solo gli strati dello \textbf{stesso livello} e secondo un \textbf{protocollo assegnato}, queste due entità sono dette \textbf{peer}.
\end{enumerate}

\pagebreak

\section{OSI: Open Systems Interconnection}
Le \textbf{prime} reti di calcolatori nacquero come \textbf{sistemi chiusi} in cui tutti i componenti dovevano essere dello stesso costruttore. Erano quindi tecnologie chiuse e \textbf{non interoperabili} l'una con l'altra a causa di drastiche differenze \textit{(e.g.\  differenza di linguaggio, \textbf{modelli di stratificazione diversi} e impossibilità per i programmi applicativi di riuscire ad operare in ambiente distribuito)}. Alla fine degli anni ‘60 esistevano: ARPANET, SNA (IBM), DNA (Digital).\newline
I \textbf{Sistemi Aperti} nascono dall'obbiettivo di alcune aziende di realizzare una rete di calcolatori in cui qualsiasi terminale potesse comunicare con un qualsiasi fornitore di servizi mediante qualsiasi rete.\newline\newline
Per realizzare un sistema aperto è necessario stabilire delle regole comuni: \textbf{gli standards}.
\theoremstyle{definition}
\begin{definition}
	Un sistema che implementa \textbf{protocolli aperti} è un \textbf{sistema aperto} (open system).
\end{definition}
\begin{definition}
	Un set di protocolli è \textbf{aperto} se:
	\begin{enumerate}
		\item I dettagli (\textbf{specifiche}) dei protocolli sono disponibili pubblicamente.
		\item I cambiamenti al set sono gestiti da un’organizzazione la cui
		      partecipazione è aperta al pubblico
	\end{enumerate}
\end{definition}

\subsection{Modello ISO/OSI}
L’International Organization for Standards (ISO) ha specificato
uno standard per l’interconnessione di sistemi aperti: l' \textbf{Open System Interconnection Reference Model} (OSI-RM) poi diventato standard internazionale nel 1983 (ISO 7498). \textbf{Si basa sul concetto di architettura a strati i cui criteri sono:}.
\begin{itemize}
	\item \textbf{Divisione delle funzionalità}: il protocollo di telecomunicazione è diviso in strati o layers, ognuno dei quali svolge un compito piccolo e indipendente dagli altri.\newline
	      Si cerca quindi di mantenere un minor numero di strati possibile e di far svolgere a ognuno di essi il minor numero di compiti possibile.
	\item \textbf{Comunicazione mediante interfacce}: i livelli comunicano mediante \textbf{chiamate standard}. Ogni livello è tenuto a rispondere alle \textbf{sole} chiamate che gli competono e che verranno
	      invocate dal singolo livello o dai due livelli ad esso adiacenti.
	\item \textbf{Information hiding}: le modalità con cui le funzioni competenti ad un livello
	      vengono svolte non è visibile dall'esterno che ne è così
	      svincolato.
\end{itemize}

\pagebreak

\section{Protocollo}
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Protocollo.png}
	\centering
\end{figure}
I protocolli definiscono il \textbf{formato} e l’\textbf{ordine} dei
messaggi inviati e ricevuti tra entità della rete al livello n-esimo e
le \textbf{azioni} che vengono fatte per la loro \textbf{trasmissione} e
\textbf{ricezione}.
\theoremstyle{definition}
\begin{definition}
	Un \textbf{protocollo} è un insieme di regole che permettono a due entità uno scambio \textbf{efficace} ed \textbf{efficiente} delle informazioni. \textbf{Definisce} il \textbf{formato} e il
	\textbf{significato} dei frame (campi del messaggio), dei pacchetti o dei messaggi
	che vengono scambiati tra gli \textbf{strati paritari} di due
	entità diverse.
\end{definition}
Un protocollo specifica quindi:
\begin{itemize}
	\item La \textbf{sintassi} di un messaggio (e.g.\  i campi).
	\item La \textbf{semantica}.
	\item  \textbf{Le azioni da compiere }(e.g.\  per l'invio, alla ricezione, alla trasmissione etc$\dots$).
\end{itemize}
\theoremstyle{definition}
\begin{definition}
	Uno \textbf{strato} o livello è un modulo interamente definito attraverso i
	servizi, protocolli e le interfacce che lo caratterizzano.
\end{definition}
\theoremstyle{definition}
\begin{definition}
	Un' \textbf{interfaccia} è il set di regole governanti sintassi e semantica della comunicazione tra due \textbf{strati successivi} della \textbf{stessa entità}.
\end{definition}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{servizio} è l'insieme di \textbf{primitive} (operazioni) che uno strato
	fornisce ad uno strato soprastante. (\textit{vedi sez. 3.4.1}).
\end{definition}
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Protocol_stack.png}
	\centering
	\caption{Esempio di stack protocollare.}
\end{figure}
\begin{figure}[!h]
	\centering
	\begin{minipage}[b]{0.45\textwidth}
		\includegraphics[scale=0.47]{Immagini/Osi_strati.png}
		\caption{Gli strati di OSI.}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.45\textwidth}
		\includegraphics[scale=0.47]{Immagini/End_sys.png}
		\caption{Esempio di collegamento tra end systems.}
	\end{minipage}
\end{figure}
\subsection{Incapsulamento dell'informazione}
All'interno della rete l'informazione ha origine \textbf{al livello
	applicativo} (\textit{livello 7 in figura}), discende quindi i vari livelli fino alla
\textbf{trasmissione}, che avviene mediante il \textbf{canale fisico}.
Da ogni livello attraversato viene aggiunta all'informazione una sezione informativa (o più di una) chiamata \textbf{header} che contiene informazioni pertinenti esclusivamente al livello stesso.
Per i dati ricevuti invece si segue il cammino inverso. Si tratta infatti di un \textbf{processo di incapsulamento \underline{reversibile}}.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Incapsulamento.png}
	\centering
\end{figure}
\begin{itemize}
	\item \textbf{Header}: è la qualificazione del pacchetto dati per questo livello.
	\item \textbf{DATA}: è il payload proveniente dal livello superiore.
	\item \textbf{Trailer}: è usato per rilevare e correggere gli errori.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/Incaps_2.png}
	\centering
	\caption{Il processo di incapsulamento. Da notare in particolare il payload.}
\end{figure}

\pagebreak

\chapter{Stack protocollare TCP/IP}
\textbf{TCP/IP} è una \textbf{famiglia di protocolli} attualmente
in uso su Internet.\newline Si tratta di una \textbf{gerarchia di
	protocolli} costituita da \textbf{moduli interagenti}, ciascuno dei
quali fornisce funzionalità specifiche.
Il termine \textbf{gerarchia} significa che ciascun protocollo di
\textbf{livello superiore} è supportato dai servizi \textbf{forniti} dai
protocolli di \textbf{livello inferiore}.
Definita in origine in termini di quattro livelli software
soprastanti a un livello hardware, \textbf{la pila TCP/IP} è \textbf{oggi}
intesa come \textbf{composta} \textbf{di cinque livelli}.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/TCP_IP.png}
	\centering
	\caption{Livelli dello stack protocollare TCP/IP, si notino le differenze tra il modello originario e il modello attuale.}
\end{figure}
\begin{itemize}
	\item Il \textbf{livello applicativo} supporta le applicazioni di rete.
	\item Il \textbf{livello di trasporto} supporta il trasferimento di dati da un host all'altro.
	\item Il \textbf{livello di rete} instrada i datagrammi dalla sorgente alla destinazione.
	\item Il \textbf{livello link} trasferisce dati tra elementi adiacenti della rete.
	\item  Al \textbf{livello fisico} troviamo i bit sul link.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Incapsulamento_m.png}
	\centering
	\caption{Esemplificazione del processo di incapsulamento/decapsulamento dell'informazione.}
\end{figure}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Logfis.png}
	\centering
	\caption{I vari collegamenti logici di comunicazione, in \textbf{rosso} invece, \textbf{il collegamento fisico}. La modularità del sistema fa in modo che gli strati paritari dei due host abbiano l'\textbf{illusione} di comunicare direttamente tra di loro. Si ricorda che queste entità situate a livelli corrispondenti su macchine (host) diverse sono dette \textbf{peer}.}
\end{figure}

\section{Lo strato applicativo}
Dello \textbf{strato applicativo} fanno parte le \textbf{applicazioni di rete}. Le applicazioni di rete sono composte da \textbf{processi distribuiti} e \textbf{comunicanti}, ovvero programmi eseguiti dai dispositivi terminali (host o end system) di una rete. Nella comunicazione \textbf{a livello applicativo} fra due dispositivi terminali interconnessi, due o più processi sono in esecuzione su ciascuno degli host comunicanti e si scambiano messaggi.
Il protocollo dello strato applicativo definisce: (\textit{repetita iuvant})
\begin{itemize}
	\item I \textbf{tipi} di messaggi scambiati al livello
	      applicativo (e.g.\  richiesta e risposta).
	\item La \textbf{sintassi} e la \textbf{semantica} dei campi dei messaggi.
	\item Le \textbf{regole} di comunicazione \textbf{interprocessuale}.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.63]{Immagini/Application_layer.png}
	\centering
	\caption{Esempio di comunicazione tra applicazioni di rete. Ancora una volta è bene ricordare che il protocollo crea l'\textit{illusione} che i processi siano in comunicazione diretta.}
\end{figure}
Presentiamo ora i \textbf{paradigmi di comunicazione} dello strato applicativo:
\begin{itemize}
	\item \textbf{Client-Server}: prevede un numero \textit{limitato} di processi \textbf{server} che
	      offrono servizi e sono \textbf{sempre} in esecuzione in attesa di ricevere richieste dai client. Un \textbf{client} è un programma che richiede un servizio. Tipicamente il client inizia il contatto con il server \textbf{inviando una richiesta} e il server risponde \textbf{offrendo il servizio} richiesto.
	\item \textbf{Peer-to-Peer}: comunicazione tra \textbf{peer} \textit{(pari)} che possono sia \textbf{offrire} servizi che \textbf{inviare} richieste.
	\item  \textbf{Misto}.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Client_server.png}
	\centering
	\caption{Esempio di paradigma client-server.}
\end{figure}

\pagebreak

Abbiamo, seppur assai brevemente, esaminato la comunicazione a livello applicativo tra macchine diverse. Scendiamo ora più nel dettaglio iniziando a tracciare il percorso \textbf{reale} dei dati dallo \textbf{strato applicativo} allo \textbf{strato di trasporto}. Partiamo dalla seguente definizione:

\theoremstyle{definition}
\begin{definition}
	\textbf{API}: acronimo di Application Programming Interface, è un insieme di \textbf{procedure} e \textbf{regole} che un programmatore deve seguire per accedere a delle risorse o per realizzare l'interazione tra due entità. Facilita molto la programmazione del software client-side.
\end{definition}
L'\textbf{API} che funge da \textbf{interfaccia} tra gli \textbf{strati di applicazione} \textbf{e} di \textbf{trasporto} è chiamata \textbf{socket} ed è usata dai processi dello strato applicativo per inviare e ricevere dati dallo strato di trasporto. Si tratta, ancora una volta, di una connessione \textbf{logica} poichè in realtà l'invio e la ricezione dei dati sono, nel \textbf{concreto}, responsabilità del sistema operativo e del protocollo TCP/IP.\newline
Riportiamo un estratto dell'\textbf{API} di \textbf{TCP:}\newline\newline
\texttt{connection TCPopen(IPaddress, int) //to open a conn.}\newline
\texttt{void TCPsend(connection, data) //to send data}\newline
\texttt{data TCPreceive(connection) //to receive data}\newline
\texttt{void TCPclose(connection) //to close a conn.}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Socket.png}
	\centering
	\caption{In figura due processi che comunicano tramite socket. Il processo è controllato dallo sviluppatore dell'applicazione, tutto ciò che è presente sotto la socket è controllato dal sistema operativo.}
\end{figure}
Sorge ora spontanea una domanda: \textbf{se ci fossero più processi su ogni host}?\newline
Servirebbe un modo per \textbf{identificarli}$\dots$ ci viene in aiuto il \textbf{socket address}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Socket_addr.png}
	\centering
	\caption{Il socket address identifica sia il \textbf{processo} con il numero di porta che l'\textbf{host} con l'indirizzo IP, a ogni porta corrisponde un processo.}
\end{figure}

\pagebreak

\textbf{\underline{Riassumendo}}: dello strato applicativo fanno parte le \textbf{applicazioni di rete}, composte da \textbf{processi distribuiti} su macchine diverse che comunicano tra di loro mediante il protocollo proprio dello strato applicativo. Sebbene il protocollo fornisca alle applicazioni l'illusione di comunicare direttamente, la comunicazione è in realtà garantita da tutto lo stack protocollare sottostante. In particolare, lo strato applicativo dipende dai servizi offerti dallo \textbf{strato di trasporto} che gli è immediatamente sottostante. I due strati comunicano tramite una \textbf{API} che si chiama \textbf{socket}.\newline\newline
A seconda del \textbf{servizio di trasporto richiesto} dall'applicazione è possibile che si trovino in uso \textbf{protocolli di trasporto diversi} tra i quali: \textbf{TCP} e \textbf{UDP}. \textit{(vedi sez. 2.2)}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Tcp_udp.png}
	\centering
	\caption{In figura le caratteristiche di alcune delle principali applicazioni di rete. Non tutte le applicazioni sono uguali. Tipicamente la telefonia di internet usa il protocollo UDP.}
\end{figure}
\subsection{Web}
Il \textbf{web} è formato da risorse indirizzate da \textbf{URL}, acronimo di \textbf{uniform resource locator}. Generalmente queste risorse sono \textbf{pagine web}, formate da altri oggetti referenziati \textit{(e.g.\  altre pagine web, immagini ecc$\dots$)}. Lo \textbf{user agent} o \textbf{client} per il web è chiamato \textbf{browser} ed il \textbf{server} è chiamato \textbf{web server}.
\theoremstyle{definition}
\begin{definition}
	Una \textbf{URI} o Uniform Resource Identifier è una stringa compatta di caratteri che identifica una risorsa fisica o astratta.
\end{definition}
Le \textbf{URL} sono un \textbf{sottoinsieme} delle URI e identificano le risorse tramite la loro posizione all'interno della rete. Le \textbf{URN} acronimo di \textbf{uniform resource name} sono un altro sottoinsieme delle URI la cui funzione è di rimanere \textbf{globalmente uniche} e \textbf{persistenti} anche quando le risorse da loro puntate cessano di esistere o non sono più disponibili.
La \textbf{sintassi} delle URI è organizzata \textbf{gerarchicamente} e i componenti sono disposti in ordine di importanza da sinistra verso destra.
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/URIvsURL.png}
	\centering
	\caption{URN e URL non sono altro che specializzazioni delle URI.}
\end{figure}

\pagebreak

\subsubsection{Sintassi della URI}
\begin{center}
	\Large$<scheme>://<authority><path>?<\textcolor{green}{query}>$
\end{center}
\textcolor{red}{http}://\textcolor{blue}{maps.google.it}/\textcolor{purple}{maps}/\textcolor{purple}{place}?\textcolor{green}{q=largo+bruno+pontecorvo+pisa
	\&hl=it}
\begin{itemize}
	\item \textcolor{red}{\textbf{scheme}}: è \textbf{obbligatorio}, definisce lo \textbf{spazio dei nomi} della risorsa.
	\item \textcolor{blue}{\textbf{authority}}: indica il \textbf{nome di dominio} di un host \textit{(reg\_name)} o il suo \textbf{indirizzo IP} in notazione decimale puntata. Tipicamente identifica un computer sulla rete.
	\item \textcolor{purple}{\textbf{path}}: contiene \textbf{dati} specifici per l’authority (o per lo scheme) e \textbf{identifica} la risorsa \textbf{nel contesto} di quel namespace e di quell'authority.
\end{itemize}
Le URI possono essere \textbf{assolute} o \textbf{relative}, una \textbf{URI assoluta} identifica una risorsa \textbf{indipendentemente} dal contesto in cui è usata. Una \textbf{URI relativa} identifica una risorsa in relazione ad un'altra URL, \textbf{è priva di schema e di authority}, non viaggia sulla rete ed è interpretata dal browser in relazione al documento di partenza.\newline \textit{(e.g.\  http://www.w3.org/pub/WWW/TheProject.html oppure\newline /pub/WWW/TheProject.html \underline{sotto l'host}: www.w3.org)}.
\subsection{HTTP}
\label{sec:HTTP}
Il protocollo \textbf{HTTP} è un protocollo di tipo \textbf{request}/\textbf{response}: il client inizia la connessione inviando un messaggio di \textbf{request} al server che a sua volta invia una \textbf{response}. Si tratta di un \textbf{protocollo generico}, poichè non dipende dal formato delle risorse, e \textbf{stateless} poichè \textbf{le coppie richiesta/risposta sono indipendenti l'una dall'altra}. In \textbf{HTTP 1.0} dopo la prima coppia di richiesta/risposta la connessione viene \textbf{terminata} mentre in \textbf{HTTP 1.1} si \textbf{procede} con un’altra coppia. \newline
Lo \textbf{schema http} è usato per accedere alle risorse attraverso il protocollo HTTP.

\pagebreak

\subsubsection{Sintassi della URL HTTP}
\begin{center}
	\LARGE$http: // <host> [ : <port> ] [ <path> ]$
\end{center}
\begin{itemize}
	\item \textbf{host}: è un \textbf{host domain di Internet} valido oppure un indirizzo IP in forma decimale puntata.
	\item \textbf{port}: \textbf{è un intero}, se  la porta è vuota o non è indicata si usa automaticamente la porta 80.
	\item \textbf{path}: specifica la \textbf{request URI} \textit{(vedi seguito)}.
\end{itemize}
\textbf{\underline{N.B.} Il protocollo HTTP utilizza il protocollo TCP tramite la sua API.}\newline\newline
//esempio client\newline
\texttt{c = TCPopen("131.115.7.24", 80);}\newline
\texttt{TCPsend(c,"GET /index.html");}\newline
\texttt{d = TCPreceive(c);}\newline\newline
\texttt{//esempio server}\newline
\texttt{p = TCPbind(80); //where to wait for connections}\newline
\texttt{d = TCPaccept(p); //waiting for connections}\newline
\texttt{r = TCPreceive(d);}\newline
\texttt{$\dots$}\newline
\texttt{TCPsend(d,pag);}\newline
\texttt{TCPclose(d);}
\theoremstyle{definition}
\subsubsection{Connessione HTTP}
\begin{definition}
	Una \textbf{connessione http} è  un circuito logico di livello di trasporto stabilito tra due programmi applicativi per comunicare tra loro.
\end{definition}
Una \textbf{connessione HTTP} può essere:
\begin{itemize}
	\item \textbf{Non persistente}\textit{(http1.0: RFC 1945)}:  \textbf{per ogni richiesta} del \textbf{client} viene instaurata \textbf{una nuova connessione} con il \textbf{server}. Ciò aumenta il \textbf{carico} su quest ultimo e potrebbero verificarsi fenomeni di \textbf{congestione}. \textit{Infatti per visualizzare le n immagini di un sito il client invia di seguito n richieste al server.}
	\item \textbf{Persistente}\textit{(http1.1: RFC 2616)}: la connessione è appunto \textbf{persistente}. Nello \textbf{standard} è specificato un meccanismo che consente al server di \textbf{chiudere} la connessione TCP su richiesta del client. \textit{(CONNECTION = CLOSE, in GENERAL HEADER, vedi seguito.)}\newline \textbf{\underline{N.B.}} Una volta che la chiusura della connessione è stata segnalata, il client \textbf{non deve} inviare altre richieste.
\end{itemize}

\pagebreak

\textbf{Esempio:}\newline
Supponiamo che l’utente digiti la seguente URL:
\begin{center}
	\textbf{www.someSchool.edu/someDepartment/home.index}
\end{center}
Con \textbf{una connessione non persistente}, in ordine temporale succedono le seguenti cose:
\begin{enumerate}
	\item Il \textbf{client http}  invia una richiesta di connessione
	      \textbf{TCP} verso il server http al \textbf{www.someSchool.edu} \textit{(La porta 80 è usata di default per il server http.)}
	\item Il \textbf{server http} dell’host	\textbf{www.someSchool.edu}, che aspetta le richieste di connessione \textbf{TCP} alla \textbf{porta 80}, \textbf{accetta} \textbf{la richiesta di connessione}  e notifica il client.
	\item Il \textbf{client http} invia quindi un \textbf{messaggio di richiesta}, contenente la URL.
	\item Il \textbf{server http} riceve il messaggio di richiesta, compila un \textbf{messaggio di risposta} con l’oggetto richiesto indicato dalla URL: \textbf{someDepartment/home.index}, invia il messaggio e in seguito \textbf{chiude} la connessione.
	\item Il \textbf{client http}  riceve il messaggio di risposta che contiene il file html e lo visualizza.
\end{enumerate}
\textit{Si ricorda che la ricezione e la trasmissione di tutti i messaggi elencati poco sopra avviene tramite socket.}\newline
Supponiamo ora che la URL contenga dei riferimenti a 10 immagini, in tal caso per ogni riferimento si devono ripetere tutti i passaggi definiti sopra. Salta immediatamente all'occhio la \textbf{scarsa efficienza} della procedura.\newline\newline
Con \textbf{una connessione persistente} invece il server lascerebbe aperta la connessione TCP dopo aver spedito la prima risposta e vi riceverebbe quindi le richieste successive. La connessione verrebbe chiusa dal server quando specificato nell’header di un messaggio  \textbf{inviatogli dal client}, oppure alla mancata ricezione di richieste per un certo intervallo di tempo \textit{(time out)}.\newline\newline
Un ulteriore miglioramento delle prestazioni, si otterrebbe con una tecnica di \textbf{pipelining}, consistente nell’invio da parte del client di molteplici richieste senza aspettarne la ricezione da parte del server.\newline
Il \textbf{server} \textbf{deve} tuttavia inviare le risposte nello stesso ordine in cui sono state ricevute le richieste e il \textbf{client} \textbf{non} può inviare \textbf{in pipeline} richieste che usano metodi HTTP \textbf{non idempotenti}. Ma cos'è un \textbf{metodo idempotente}?
\theoremstyle{definition}
\subsubsection{Metodo idempotente}
\begin{definition}
	Un \textbf{metodo idempotente} è un metodo tale che il suo effetto collaterale sulla risorsa è lo \textbf{stesso} per N o 1 richieste identiche che ne fanno uso. \textit{(e.g.\  GET, HEAD, PUT, DELETE, OPTIONS, TRACE)}
\end{definition}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{metodo safe} è un metodo che non produce effetti collaterali sulle risorse. \textit{(e.g.\  non le modificano: GET, HEAD, OPTIONS, TRACE$\dots$)}
\end{definition}
\begin{figure}[!h]
	\includegraphics[scale=0.65]{Immagini/Http_vs.png}
	\centering
	\caption{In figura sono rappresentate le differenze viste prima.}
\end{figure}
\subsubsection{Messaggi HTTP}
Riportiamo di seguito la \textbf{struttura} di un generico messaggio http:\newline
\texttt{Request = Request-Line} \textit{o} \texttt{Response = Status-Line} \textit{per i messaggi di risposta.}\newline
\texttt{*( general-header}\newline
\texttt{| request-header} \textit{o} \texttt{response-header}\newline
\texttt{| entity-header )}\newline
\texttt{CRLF}\newline
\texttt{[ message-body ]}\newline
La prima riga o \textbf{start line} distingue i messaggi di request dai messaggi di response.
\begin{figure}[!h]
	\includegraphics[scale=0.43]{Immagini/Http_req.png}
	\includegraphics[scale=0.43]{Immagini/Http_res.png}
	\caption{In figura un messaggio di richiesta e uno di risposta.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Req_line.png}
	\centering
	\caption{La struttura della \textbf{request line}. Il campo \textbf{method} è case sensitive ed indica l'operazione da eseguire sulla risorsa identificata dalla URI\@. Il metodo \textbf{POST} serve per inviare dal client al server le
		informazioni inserite nel body del messaggio, \textbf{PUT} è usato dal client per chiedere al server di creare o modificare una risorsa, \textbf{DELETE} per cancellarla.}
	\includegraphics[scale=0.4]{Immagini/Stat_line.png}
	\centering
	\caption{La \textbf{status-Line} è la prima riga del messaggio di risposta. Lo \textbf{status code} è un numero di 3 cifre, indica il risultato del tentativo di soddisfare la richiesta del client. La \textbf{reason-phrase} dà una breve descrizione testuale dello status-code. Lo status-code è rivolto alla macchina mentre la reason-phrase all'utente umano.}
\end{figure}
Gli \textbf{header} sono insiemi di coppie \textbf{nome} : \textbf{valore} che specificano
alcuni parametri del messaggio trasmesso o ricevuto.
\begin{itemize}
	\item \textbf{General Headers}: sono relativi alla \textbf{trasmissione} e si applicano a \textbf{tutto il messaggio}. \textit{(e.g.\  \textbf{Date, Connection:} usato dal mittente per specificare delle opzioni desiderate per la connessione, ad esempio \underline{close}. \textbf{Transfer-encoding}: specifica se e quali trasformazioni sono state applicate al corpo del messaggio ad esempio gzip, chunked ecc. \textbf{Cache control}: indica quale tipologia di cache può memorizzare il messaggio, può essere \textbf{public}, \textbf{private} o \textbf{no-cache}.)}
	\item \textbf{Entity Headers}: sono \textbf{metadati} relativi all'\textbf{entità trasmessa}. Ogni entity è costituita da un \textbf{entity body} e da una
	      serie di \textbf{entity headers} che ne definiscono contenuto e
	      proprietà. \textit{(e.g.\  Content Lenght)}
	\item \textbf{Request Headers}: sono relativi alla \textbf{richiesta}. Supportano il \textbf{content negotiation}, il processo tramite cui il server sceglie la forma "giusta" del contenuto richiesto dal client. \textit{(Specificano da chi è fatta la richiesta, a chi viene fatta, che tipo di risposte il client è in grado di accettare, l'autorizzazione, ecc.)}
	\item \textbf{Response Headers}: sono relativi al \textbf{messaggio di risposta}.
\end{itemize}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.2]{Immagini/HTTP_get.png}
	\centering
	\caption{In figura un esempio di richiesta HTTP con cui il client preleva un documento, viene usato il metodo \textbf{GET} per ottenere l'immagine individuata dal percorso \texttt{usr/bin/image1}.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/General_h.png}
	\centering
	\caption{L'elenco dei general headers.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Req_h.png}
	\centering
	\caption{L'elenco dei request headers. \textbf{Accept} specifica quali tipi di media sono accettati in risposta dal client, \textbf{Accept-Charset}, quali caratteri e \textbf{Accept-Encoding} quali formati. È possibile specificare una \textbf{condizione}, in tal caso il server invia la risorsa solo se la condizione è soddisfatta altrimenti informa il client della motivazione del mancato invio.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Cond_HTTP.png}
	\centering
	\caption{In figura un esempio di richiesta condizionale.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.32]{Immagini/Cond_HTTP_risp.png}
	\centering
	\caption{In figura la risposta alla richiesta condizionale di prima. La riga di stato indica che il file non è stato modificato successivamente alla data indicata dal client, nulla viene inviato e il corpo del messaggio è vuoto.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Resp_h.png}
	\centering
	\caption{I campi del \textbf{response-header} consentono al server di inviare informazioni aggiuntive che non possono essere poste nella status-line. Ad esempio: \textbf{Age}: indica quanto tempo è trascorso, in secondi, tra l'invio della risposta da parte del mittente e la generazione della stessa all'origine. \textbf{Location} é usato per reindirizzare il client verso un altra URI per completare la sua richiesta o per fornire una nuova risorsa. Il campo \textbf{Server} contiene informazioni sul software usato dal server di origine per portare a compimento la richiesta del client.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Stat_code.png}
	\centering
	\caption{In figura l'elenco degli status-codes e il loro significato. Descrivono lo stato della risposta. I codici dal 100 al 199 indicano informazioni, dal 200 al 299 che una richiesta è stata eseguita con successo, quelli tra 300 e 399 reindirizzano il client verso un'altra URL, quelli tra 400 e 499 indicano che si è verificato un errore lato client e quelli dal 500 al 599 dal lato server.}
\end{figure}

\pagebreak

Fin'ora abbiamo mostrato come il client accede alle risorse del web inviando richieste al server. Cosa succederebbe se, ad esempio, un client richiedesse continuamente la \textbf{stessa} risorsa? Potremmo evitare di inoltrare richieste tutte uguali al server? \textbf{Sì}, ci viene in aiuto il \textbf{web caching}. L'obbiettivo del web caching è di soddisfare le richieste del client \textbf{senza} contattare il server. Funziona memorizzando \textbf{copie temporanee} di risorse web, servendole poi al client così da \textbf{ridurre} l’uso di \textbf{banda}, limitare il \textbf{workload} sul server e di conseguenza \textbf{diminuire tempo di risposta} verso gli altri clients. Consideriamo due modelli possibili di web caching:
\begin{itemize}
	\item \textbf{User Agent Cache}: lo \textbf{user agent} (il browser) mantiene una \textbf{copia} delle risorse visitate dall’utente.
	\item \textbf{Proxy Cache}: il \textbf{proxy intercetta il traffico} e mette in cache le risposte. Successive richieste alla stessa URI possono essere servite direttamente dal proxy senza inoltrare la richiesta al server. Sta poi all' utente configurare il browser per consentire gli accessi Web via proxy.
\end{itemize}
\subsubsection{Proxy}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{proxy} è un \textbf{programma intermediario} che agisce sia da \textbf{server} che da \textbf{client}, \textbf{inviando} e \textbf{servendo} \textbf{richieste} per altri clients. Le richieste sono gestite internamente o inoltrate a server terzi.
\end{definition}
Resta ora da chiarire come è possibile che, sebbene abbiamo definito il protocollo HTTP come \textbf{stateless}, alcuni siti, \textit{riconoscano} gli utenti.
Sebbene infatti il protocollo HTTP sia a tutti gli effetti stateless, le applicazioni web \textbf{non} lo sono. Come fare quindi a conciliare queste due realtà?
\subsubsection{Cookies}
\begin{definition}
	I \textbf{cookies} sono stringhe di testo contenenti informazioni relative all'utente.
\end{definition}
I \textbf{cookies} funzionano nel seguente modo:
\begin{enumerate}
	\item Un client invia al server una richiesta HTTP.
	\item Il server invia al client la risposta HTTP e in più una linea \textbf{set-cookie: 1678453}. \textit{(esempio fittizio)}
	\item Il client \textbf{memorizza} il cookie in un file e lo associa al server.
	      Lo aggiungerà con la seguente linea: \textbf{cookie: 1678453} a tutte le sue successive richieste.
	\item Alla successiva richiesta da parte del client, il server \textbf{risalirà} tramite il cookie alle informazioni ad esso \textbf{associate}.
\end{enumerate}

\pagebreak

\subsection{TELNET}
\textbf{TELNET}, acronimo per \textbf{TE}rmina\textbf{L} \textbf{NET}work, è un \textbf{protocollo} \textbf{client-server} che fornisce una comunicazione \textbf{interattiva ed orientata al testo} tra due macchine, è basato sul trasporto \textbf{connection-oriented} ed usa il protocollo \textbf{TCP}.
Consente all'utente di effettuare una sessione di \textbf{login} in una macchina remota e quindi di utilizzarne il terminale. L'utente che si autentica tramite login remoto ha accesso infatti a tutti i \textbf{comandi} e ai \textbf{programmi} disponibili su di essa. \textbf{I comandi vengono eseguiti come se l'utente li digitasse dalla tastiera stessa della macchina.} \textit{Per estensione,} \texttt{\textbf{telnet}} \textit{è anche il nome di un programma usato per avviare una sessione TELNET verso un host remoto.}
\textbf{TELNET} infatti include due programmi: un programma \textbf{TELNET client} e un programma \textbf{TELNET server}. \textbf{TELNET client} (\texttt{\textbf{telnet}}) interagisce con l'utente sulla macchina locale e scambia messaggi con \textbf{TELNET server}. Riportiamo di seguito una semplificazione del funzionamento:
\begin{enumerate}
	\item L'utente, dalla \textbf{propria} macchina \textbf{locale} (\textbf{\textbf{TELNET client}}), stabilisce una connessione \textbf{TCP}, persistente per tutta la durata della sessione, con una \textbf{macchina remota (\textbf{TELNET server})} alla \textbf{porta 23} e vi si \textbf{autentifica}.
	\item  Tutte le \textbf{battute} dei \textbf{tasti} della macchina locale vengono \textbf{trasmesse} dal client
	      alla \textbf{macchina remota}.
	\item La \textbf{macchina remota} accetta la connessione TCP e il \textbf{TELNET server} trasmette i dati al sistema operativo locale.
	\item L'\textbf{output} della \textbf{macchina remota} viene quindi \textbf{ricevuto} e \textbf{trasmesso} sul terminale dell'utente.
\end{enumerate}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/TELNET.png}
	\centering
	\caption{In figura il funzionamento di TELNET.}
\end{figure}
\underline{N.B. TELNET è un protocollo STATEFUL.}

\pagebreak

\subsubsection{Network Virtual Terminal}
\begin{flushleft}
	\textbf{I terminali non sono tutti uguali}, possono differire gli uni dagli altri per il \textbf{set} e la \textbf{codifica} dei caratteri, per la \textbf{lunghezza} della \textbf{linea} e della \textbf{pagina} e per i \textbf{tasti funzione} individuati da diverse sequenze di caratteri.
\end{flushleft}
Una \textbf{soluzione} è stata trovata mediante la definizione di un \textbf{Network Virtual  Terminal (NVT) che definisce un \textbf{set di caratteri universali}}.
L’NVT è quindi un dispositivo “immaginario” che fornisce una
rappresentazione astratta di un terminale. Gli host, sia client
che server, \textbf{traducono} le loro caratteristiche \textbf{locali} \textbf{tramite il set universale} così da apparire \textbf{in rete} come un NVT e assumono che l’host remoto sia anch'esso un NVT\@. Questa operazione di traduzione è ovviamente \textbf{reversibile}.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/NVT.png}
	\centering
\end{figure}
\newline
Il funzionamento di TELNET, con l'aggiunta della trasformazioni intermedie sopra descritte diventa:
\begin{enumerate}
	\item $\dots$
	\item  Tutte le \textbf{battute} dei \textbf{tasti} della macchina locale vengono \textbf{trasformate in NVT e successivamente} \textbf{trasmesse dal TELNET client}
	      alla \textbf{macchina remota}.
	\item La \textbf{macchina remota} accetta la connessione TCP, il \textbf{TELNET server} \textbf{traduce} da NVT allo standard del sistema operativo remoto e infine gli trasmette i dati ricevuti.
	\item $\dots$
\end{enumerate}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/NVT2.png}
	\centering
\end{figure}
\underline{\textit{N.B. NVT invia i caratteri di controllo prioritariamente con TCP URGENT.}}

\pagebreak

\begin{flushleft}
	Concludiamo con qualche tecnicismo:
\end{flushleft}
I terminali NVT si scambiano dati in formato \textbf{7-bit US-ASCII} e adottano inoltre un approccio \textbf{in-band signaling}, ovvero dati e comandi viaggiano sullo \textbf{stesso canale}. Per distinguere i due tipi di informazione si usa la seguente convenzione: ogni carattere è inviato come un \textbf{ottetto di bit} con \textbf{il primo bit settato a zero}. I caratteri, in notazione decimale, vanno dal numero 0 al 127. I comandi invece sono identificati tramite  ottetti speciali di 1, in n.\  d.\  vanno dal numero 240 al numero 254, per distinguerli dai dati sono sempre preceduti da un carattere speciale: \textbf{IAC o Interpret As Command} identificato, sempre in n.\  d.\ , dal numero 255. Essenzialmente quindi si usa un canale di 8 bit per scambiare dati di tipo 7 bit ASCII\@. I messaggi scambiati durante la fase iniziale della comunicazione, ovvero prima del login, sono \textbf{messaggi di controllo} e costituiscono la \textbf{Telnet Option Negotiation}, in sostanza sono usati per scambiare \textbf{informazioni} sulle \textbf{caratteristiche} degli \textbf{host}.
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Comando} & \textbf{Codifica decimale} & \textbf{Significato} \\
			\hline
			IAC              & 255                        & Interpret as command \\
			EL               & 248                        & Erase line           \\
			EC               & 247                        & Erase character      \\
			IP               & 244                        & Interrupt process    \\
			EOR              & 239                        & End of record        \\
		\end{tabular}
	\end{center}
\end{table}\newline
\begin{flushleft}
	\textit{Ma quindi NVT conviene?}
\end{flushleft}
\begin{flushleft}
	Rispondiamo alla domanda mostrando dei semplici calcoli:
\end{flushleft}
Supponiamo che N sia il numero di sistemi distinti che si vogliono far
interoperare:
\begin{itemize}
	\item \textbf{Senza} l'uso di NVT, si necessita la scrittura di \textbf{N-1} client per ogni sistema (N-1 TELNET-clients che traducano negli N-1 standards dei sistemi), e 1 TELNET-server per ogni sistema: \newline
	      In totale si avranno $N\times(N-1) + N$ applicativi.
	\item \textbf{Usando} NVT, bisogna scrivere 1 TELNET-server per ogni sistema e N TELNET-client (1 per ogni sistema che traduca dallo standard di sistema allo standard di NVT): \newline Avremo quindi $N + N = 2N$ applicativi.
\end{itemize}
Quindi per $N > 2$ \textbf{conviene} usare NVT!

\pagebreak

\subsection{SSH}
TELNET non possiede \textbf{alcuna} misura di sicurezza poichè è stato progettato per l'uso su \textbf{reti private}, trasmette tutto in chiaro, anche le \textbf{password}! Con l'avvento delle reti pubbliche però si è reso necessario prendere delle contromisure. \newline
\textbf{SSH} o \textbf{S}ecure \textbf{SH}ell è un'applicazione nata per sostituire TELNET.
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/SSH.png}
	\centering
	\caption{Le componenti di SSH}
\end{figure}\newline
Il \textbf{protocollo} di livello applicazione \textbf{SSH} è composto da \textbf{tre} diverse componenti: \textbf{SSH-TRANS, SSH-AUTH e SSH-CON}. La componente \textbf{SSH-TRANS} o \textbf{SSH-Transport Layer Protocol} costruisce un canale di comunicazione sicuro, tramite tecniche crittografiche, sfruttando la connessione offerta da TCP\@. Il \textbf{protocollo TCP} trasmette tutte le informazioni in chiaro, \textbf{non} è quindi in grado \textbf{da solo} di garantire \textbf{privacy} e \textbf{confidenza}. \textit{SSH-TRANS è anche in grado di riconoscere se il server a cui ci stiamo connettendo è quello autentico o meno.} La componente \textbf{SSH-AUTH} si occupa di autenticare il client. \textit{Sono disponibili altre tecniche di autenticazione oltre alla classica con username e password tra le quali l'accesso basato su coppie di chiavi crittografiche.} Infine la componente \textbf{SSH-CONN} sfruttando i servizi offerti dalle altre due componenti offre i servizi di \textbf{terminale}, \textbf{trasferimento file}, \textbf{creazione di tunnel} ecc$\dots$\newline \textbf{SSH offre} quindi \textbf{molti più servizi di TELNET}.
\subsubsection{TCP Port Forwarding}

Il \textbf{TCP Port Forwarding} è un meccanismo che permette di \textbf{creare} un \textbf{canale di comunicazione sicuro} attraverso il quale \textbf{veicolare} \textbf{qualsiasi} tipo di \textbf{connessione TCP}. Opera creando un canale di comunicazione \textbf{cifrato} tra la \textbf{porta} all’\textbf{indirizzo remoto} a cui ci si vuole collegare e una \textbf{porta locale} libera. Le applicazioni punteranno il collegamento alla porta locale e la connessione verrà inoltrata automaticamente all’host remoto
tramite un canale sicuro. \newline Segue una spiegazione delle differenze tra \textbf{local port forwarding} e \textbf{remote port forwarding}.

\pagebreak

\begin{itemize}
	\item \textbf{Local}: \texttt{ssh -L} specifica che il traffico sulla porta indicata della macchina locale deve essere reindirizzato verso la porta indicata della macchina remota. \newline
	      e.g.\  \texttt{ssh -L sourcePort:forwardToHost:onPort connectToHost} significa: connettiti via ssh a \textbf{connectToHost}, e inoltra tutti i tentativi di connessione che arrivano alla porta locale \textbf{sourcePort} verso la porta \textbf{onPort} della macchina chiamata \textbf{forwardToHost}, che si raggiunge tramite la macchina chiamata a sua volta \textbf{connectToHost}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.8]{Immagini/Local_ssh.png}
		      \centering
	      \end{figure}

	      \pagebreak

	\item \textbf{Remote}: \texttt{ssh -R} specifica che il traffico sulla porta indicata della macchina remota deve essere reindirizzato verso la porta indicata della macchina locale.\newline
	      e.g.\  \texttt{ssh -R sourcePort:forwardToHost:onPort connectToHost} significa: connettiti via ssh a \textbf{connectToHost}, e inoltra tutti i tentativi di connessione che arrivanao alla porta remota \textbf{sourcePort} verso la porta \textbf{onPort} della macchina \textbf{forwardToHost}, che si raggiunge tramite la tua macchina locale.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.9]{Immagini/Remote_ssh.png}
		      \centering
	      \end{figure}
\end{itemize}
\underline{N.B. SSH è un protocollo STATEFUL.}

\pagebreak

\subsection{FTP}
\label{sec:FTP}
\textbf{FTP} acronimo per \textbf{F}ile \textbf{T}ransfer \textbf{P}rotocol, è un \textbf{protocollo} per il \textbf{trasferimento} di \textbf{dati} tra due host di una rete, è lo \textbf{standard} per il \textbf{trasferimento} di file \textbf{offerto da TCP/IP}. Adotta il modello \textbf{client-server}: il \textbf{client} richiede il trasferimento di un file che può consistere sia nell'\textbf{acquisizione} di una copia locale modificabile sia nell'eventuale \textbf{trasferimento} della copia modificata sull'host remoto (\textbf{server}).
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/FTP.png}
	\centering
\end{figure}\newline
Il \textbf{client} ha \textbf{tre} componenti: \textbf{interfaccia utente}, \textbf{processo di controllo} e \textbf{processo di trasferimento dati} mentre il \textbf{server} remoto ne ha solo \textbf{due}: \textbf{processo di controllo} e \textbf{processo di trasferimento dati}. La \textbf{separazione} del trasferimento dei dati da quello dei comandi rende il protocollo FTP \textbf{efficiente}. Infatti la \textbf{connessione di controllo} usa \textbf{regole semplici} così da ridurre lo scambio delle informazioni a \textbf{una riga di comando} e \textbf{una di risposta per ogni interazione}. Mentre la \textbf{connessione dati usa regole più complicate} a causa della varietà delle informazioni che vi transitano.
\textbf{FTP} offre funzionalità \textbf{aggiuntive} oltre al semplice trasferimento di dati, infatti \textbf{mette a disposizione}:
\begin{itemize}
	\item \textbf{Accesso interattivo}: l’utente può \textbf{navigare}, \textbf{cambiare} e \textbf{modificare} l’albero di directory nel file system dell'host remoto.
	\item \textbf{Specificazione del formato dei dati da trasferire} (e.g.\  file di testo o file binari)
	\item \textbf{Autenticazione}: il client può \textbf{autenticarsi} con username e password.
\end{itemize}
Poco sopra abbiamo accennato al fatto che \textbf{FTP} prevede l'instaurazione di \textbf{due tipi di connessione tra il client e il server} ovvero:
\begin{enumerate}
	\item \textbf{Control connection}: prevede uno scambio di comandi e \textbf{codici di ritorno} e.g.\  \textbf{200 OK}, tra client e server. Segue il protocollo TELNET e \textbf{rimane aperta per l'intera durata della sessione interattiva}. Si usa la \textbf{porta 21} del \textbf{server} e la codifica standard \textbf{NVT ASCII}.
	\item \textbf{Data connection}: prevede il trasferimento di dati mediante procedure e la \textbf{specifica dei tipi}. I dati trasferiti possono essere parte di un file, un file o un set di file. \textbf{Viene aperta e chiusa per ogni singolo scambio}. Per lo scambio di dati il \textbf{server} usa la \textbf{porta 20}.
\end{enumerate}

\pagebreak

La \textbf{Data Connection} \textbf{non segue il protocollo TELNET} e la sua apertura avviene secondo uno schema completamente diverso, ovvero:
\begin{enumerate}
	\item Il \textbf{client}, non il server, effettua un'\textbf{apertura} \textbf{passiva} usando una \textbf{porta effimera} e resta in attesa di connessione, viene fatto dal client poichè è tale processo che invierà i comandi, tramite la connessione di controllo, per il trasferimento dei file.
	\item Il client \textbf{invia} questo \textbf{numero} di \textbf{porta} al \textbf{server} per mezzo del comando PORT.
	\item Il \textbf{server}, ricevuto il numero di porta, \textbf{effettua} un'\textbf{apertura} \textbf{attiva}, ovvero apre la connessione, usando la propria \textbf{porta} nota \textbf{20} e quella effimera offerta dal client.
\end{enumerate}
Per effettuare il trasferimento dei file inoltre, il client deve \textbf{definire} il \textbf{tipo}
di file, la \textbf{struttura dati} e la \textbf{modalità di trasmissione} al fine di
risolvere i problemi di eterogeneità tra client e server, va infatti ricordato che programma client e programma server sono su macchine \textbf{diverse}. Questo scambio di informazioni avviene mediante la \textbf{connessione di controllo}.\newline\newline
FTP è quindi un protocollo \textbf{STATEFUL} poichè il \textbf{server deve tener traccia dello stato dell’utente}: bisogna tenere conto infatti, tra le altre cose, della directory del file system remoto in cui si trova l'utente!\newline\newline
Concludiamo menzionando il fatto che esistono server che supportano connessioni FTP \textbf{senza autenticazione} (\textbf{Anonymous FTP}).  Tipicamente consentono di accedere \textbf{solo} ad una parte del file system e permettono \textbf{solo} un subset di operazioni (e.g.\  la PUT \textbf{non} è permessa). Di solito \textbf{si usa} un \textbf{username comune} (solitamente "ftp" or "anonymous") e una \textbf{password qualsiasi} (e.g.\  l'indirizzo email dell'utente).\textit{Erano usate per distribuire a un pubblico dei file senza dover generare numerosi username e password.}
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c}
			\textbf{Comandi di controllo} & \textbf{Significato}             \\
			\hline
			USER   username               & username d'autenticazione        \\
			PASS   password               & password   d'autenticazione      \\
			LIST   dirname                & elenca i file della
			directory corrente                                               \\
			NLST   dirname                & richiede elenco file e
			directory (ls)                                                   \\
			RETR   filename               & recupera (get)
			un file dalla directory
			corrente                                                         \\
			STOR   filename               & memorizza
			(put) un file nell’host remoto                                   \\
			ABOR                          & interrompe ultimo
			comando e trasferimenti in
			corso                                                            \\
			PORT   portnumber             & indirizzo e numero di porta
			del client                                                       \\
			SYST                          & il server restituisce il tipo di
			sistema                                                          \\
			QUIT                          & (quit) chiude la
			connessione                                                      \\
		\end{tabular}
	\end{center}
\end{table}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Ftp_transfer.png}
	\centering
	\caption{Esempio di trasferimento di un file, notare la connessione dati.}
\end{figure}
Ogni comando FTP \textbf{genera} almeno \textbf{una risposta}, le risposte sono composte da due parti: \textbf{un numero di tre cifre e un testo}.
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c}
			\textbf{Risposte FTP} & \textbf{Descrizione}                               \\
			\hline
			125                   & connessione dati aperta                            \\
			150                   & stato del file OK                                  \\
			200                   & comando OK
			\\
			220                   & servizio pronto                                    \\
			221                   & servizio in chiusura                               \\
			225                   & connessione dati aperta                            \\
			226                   & connessione dati in chiusura                       \\
			230                   & login dell'utente OK                               \\
			250                   & azione sul file OK                                 \\
			331                   & nome utente OK, attesa PW                          \\
			425                   & non è possibile aprire la connessione dati         \\
			450                   & azione sul file non eseguita, file non disponibile \\
			452                   & azione interrotta, spazio insufficiente            \\
			500                   & errore di sintassi, comando non riconosciuto       \\
			501                   & errore di sintassi nei parametri o negli argomenti \\
			530                   & login dell'utente fallito                          \\
		\end{tabular}
	\end{center}
\end{table}

\pagebreak

\subsection{DNS}
Sappiamo oramai che i dispositivi connessi in rete vengono individuati dai protocolli TCP/IP mediante i loro \textbf{indirizzi IP}, gli utenti, d'altro canto, preferiscono usare dei \textbf{nomi} invece che degli indirizzi numerici. Un \textbf{nome} identifica un \textbf{oggetto} mentre un \textbf{indirizzo} specifica \textbf{dove} l'oggetto è situato.
\begin{flushleft}
	\textit{Come fare per associare i nomi agli indirizzi?}
\end{flushleft}
Agli albori di Internet l’associazione tra nomi logici e indirizzi IP era statica!
Tutti i nomi \textit{logici} e i relativi indirizzi IP erano contenuti in un file chiamato \textbf{host file} e periodicamente tutti gli host ne prelevavano una versione aggiornata, chiamata a sua volta \textbf{master host file}, da un server ufficiale.\newline
A noi utenti moderni però dovrebbe immediatamente saltare all'occhio la seguente \textbf{problematica}: le \textbf{dimensioni attuali di Internet} rendono questo approccio \textbf{impraticabile}. Non sarebbe infatti possibile che ogni host possegga una \textbf{copia aggiornata} di un elenco del genere, in più la dimensione di questo  sarebbe sterminata, per non parlare del \textbf{volume di traffico} sul server ufficiale, il pericolo dovuto alla presenza di un \textbf{unico punto di fallimento} e l'\textbf{impossibilità di scalare} di questo sistema.\newline
Fu così che all'inizio degli anni '80 venne ideato il \textbf{DNS} o \textbf{Domain Name System}. L'\textbf{idea centrale} è di \textbf{suddividere} la sconfinata mole di associazioni nome-indirizzo e \textbf{distribuirne} le varie parti su \textbf{calcolatori sparsi per il mondo}. \textit{Come funziona? Così:}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/DNS.png}
	\centering
\end{figure}\newline
Supponiamo che un utente utilizzi un client di trasferimento file per accedere a un file su un server. L'utente conoscerà solo il \textbf{nome} del server e.g.\  \textit{cheneso.com}, lo \textbf{stack TCP/IP} invece ha bisogno dell'\textbf{indirizzo IP} del server per stabilire una connessione. Alla pagina seguente troviamo i sei passi necessari per \textbf{associare} l'\textbf{indirizzo} IP al \textbf{nome} del server.

\pagebreak

\begin{enumerate}
	\item L'\textbf{utente} comunica il nome del server al client di trasferimento file.
	\item \textbf{Il client di trasferimento file} trasmette il nome del server al \textbf{client DNS}.
	\item \textbf{Ogni computer una volta avviato conosce l'indirizzo IP di un server DNS}, il \textbf{client DNS} invia dunque, usando la \textbf{porta 53}, al \textbf{server DNS} la richiesta di traduzione del nome simbolico del server.
	\item Il \textbf{server DNS} risponde con l'indirizzo IP del server desiderato.
	\item Il \textbf{client DNS} comunica al \textbf{client di trasferimento file} l'indirizzo IP del server.
	\item Il \textbf{client di trasferimento file} \textbf{utilizza} così l'\textbf{indirizzo IP ricevuto} per accedere al server.
\end{enumerate}
Per far sì che questo meccanismo funzioni bisogna \textbf{eliminare le ambiguità sui nomi} e per far ciò si è definito uno \textbf{spazio dei nomi}. Lo \textbf{spazio dei nomi} ha una \textbf{struttura gerarchica} per una ragione principale: se tutti i nomi fossero composti da una sola stringa alfanumerica servirebbe un'\textbf{autorità centrale} che controllasse l'unicità di ogni singolo nome. Una \textbf{struttura gerarchica} consente invece di avere nomi composti da diverse parti e di \textbf{delegare il controllo} su ciascuna parte a enti o società diverse, \textbf{decentralizzando} in tal modo il processo di controllo.
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/DNSpace.png}
	\centering
	\caption{In figura lo spazio dei nomi di dominio.}
\end{figure}\newline
Nello \textbf{spazio dei nomi di dominio} i nomi hanno una struttura ad \textbf{albero} con la radice in cima e un numero di livelli compreso tra 0 e 127. Ogni nodo è individuato da un'\textbf{etichetta} costituita da \textbf{massimo 63 caratteri} (\textit{la radice ha l'etichetta vuota}), tutti i nodi collegati a uno stesso nodo da rami diversi hanno etichette \textbf{diverse}, ciò garantisce l'\textbf{univocità} dei nomi. Ogni nodo dell'albero ha inoltre un \textbf{nome di dominio}, che, se letto da sinistra verso destra, è costituito da tutte le etichette, separate da punti, di tutti i nodi a partire dal nodo stesso fino alla radice, la cui etichetta è la stringa \textbf{nulla}. Immediatamente sotto la radice si trovano i \textbf{domini top-level}.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Etichette_dns.png}
	\centering
	\caption{In figura le etichette e i nomi di dominio.}
\end{figure}
\theoremstyle{definition}
\begin{definition}
	Un \textbf{dominio} è un \textbf{sottoalbero} dello spazio dei nomi che viene identificato dal \textbf{nome di dominio} della sua radice.
\end{definition}
\textit{Ma dove sono contenute le informazioni relative allo spazio dei nomi di dominio?}

\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Dnserver.png}
	\centering
	\caption{In figura la gerarchia dei name server.}
\end{figure}
All'interno dei \textbf{DNS-Servers} o \textbf{name servers}. L'intero spazio dei nomi è stato \textbf{diviso} in diversi domini, differenziati al \textbf{top-level}, e i domini così ottenuti sono stati divisi a loro volta ottenendo dei sotto domini. Ogni \textbf{name server} è responsabile di un dominio o di un sottodominio. Vi è quindi una \textbf{gerarchia di server}. Una \textbf{zona} \textbf{è tutto ciò di cui è responsabile un server}, se un server è responsabile di un dominio e non effettua suddivisioni in sottodomini, allora la sua zona e il suo dominio \textbf{coincidono}. Se invece il server suddivide il proprio dominio in sottodomini la sua zona e il suo dominio \textbf{differiscono}. Ogni name-server ha un database chiamato \textbf{file di zona} contenente le informazioni su tutti i nodi che ricadono nella \textbf{sua} \textbf{zona} di competenza.

\pagebreak

Un \textbf{root server} è un server che ha per zona l'\textbf{intero albero dello spazio dei nomi}.\newline Solitamente i \textbf{root server} si limitano a immagazzinare riferimenti relativi ad altri server e \textbf{delegano} loro tutte le responsabilità.\newline
Esempio di top-level domains:
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Dominio}     & \textbf{Uso}                            \\
			\hline
			com                  & organizzazioni commerciali              \\
			edu                  & istituti di istruzione                  \\
			mil                  & gruppi militari                         \\
			gov                  & istituzioni governative americane       \\
			net                  & principali centri di supporto alla rete \\
			org                  & organizzazioni diverse dalle precedenti \\
			it, uk, us, fr, ecc. & codice geografico per nazioni
			\\
		\end{tabular}
	\end{center}
\end{table}\newline
I \textbf{server DNS} possono essere \textbf{primari} o \textbf{secondari}.
\begin{itemize}
	\item Un server \textbf{primario} possiede sul disco e aggiorna il \textbf{file di zona} relativo alla zona sotto la sua responsabilità.
	\item Un server \textbf{secondario} riceve le informazioni relative a una zona da un \textbf{server primario}.
\end{itemize}
I \textbf{server} \textbf{primari} e \textbf{secondari} hanno la medesima autorità sulla loro zona di competenza, è bene specificare che \textbf{un server può essere primario per una zona  e secondario per un altra}, \textbf{primario} e \textbf{secondario} sono quindi aggettivi \textbf{relativi alla zona}. Si noti inoltre come l'introduzione di un server secondario in una zona porti a una duplicazione del \textbf{file di zona} che può risultare utile per eventuali guasti al \textbf{server primario}.
\subsubsection{Risoluzione}

Il processo con cui si associa l'indirizzo IP da un nome è detto \textbf{processo di risoluzione}. Il \textbf{protocollo DNS} è progettato come protocollo \textbf{client-server}. Un host che voglia ricavare un indirizzo IP da un nome si rivolge al \textbf{programma client} detto anche \textbf{resolver} che invierà un'opportuna richiesta al \textbf{server DNS più vicino} il quale, se dispone della risposta, invierà l'indirizzo o il nome (\textit{è infatti possibile fare il processo al contrario}), oppure inoltrerà la richiesta a un altro server o comunicherà al resolver l'indirizzo di un altro server a cui fare riferimento. Il \textbf{resolver}, ricevuta la risposta, la esaminerà per verificarne la presenza di errori e la trasmetterà al processo che l'ha effettuata. La \textbf{risoluzione} può essere \textbf{ricorsiva} o \textbf{iterativa}.

\pagebreak

\begin{itemize}
	\item Con la \textbf{risoluzione ricorsiva}, la \textbf{query DNS} viaggia dall'host su cui è in esecuzione il processo applicativo che ne ha fatto richiesta fino a un host che conosce l'indirizzo IP richiesto, eventualmente scalando, poi discendendo e infine percorrendo a all'indietro \textbf{l'intera gerarchia dei server DNS}. \textbf{Al server locale che ha richiesto la query viene inviato \textbf{solo} l'indirizzo IP risultante}, ha richiesto quindi una \textbf{conversione completa}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.7]{Immagini/DNSrec.png}
		      \centering
		      \caption{In figura un esempio di risoluzione ricorsiva.}
	      \end{figure}
	\item Con la  \textbf{risoluzione iterativa} ogni \textbf{server-DNS} che non è in grado di risolvere la \textbf{query-DNS} dell'host risponde, \textbf{direttamente al server locale}, con \textbf{l'indirizzo di un altro server in grado di risolverla}.
	      \textbf{Al server locale che ha richiesto la query non viene quindi inviato solo l'indirizzo IP risultante}. La \textbf{risoluzione iterativa} è supportata da \textbf{tutti} i \textbf{name server}, l'host può richiedere che venga usata la \textbf{risoluzione ricorsiva} ma potrebbe non essere disponibile.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.7]{Immagini/DNSite.png}
		      \centering
		      \caption{In figura un esempio di risoluzione iterativa.}
	      \end{figure}
\end{itemize}
Ogni volta che a un \textbf{server} arriva una richiesta di risoluzione di un nome, che non fa parte del suo dominio, deve cercare, all'interno del suo database, un altro server a cui inoltrare la richiesta. Ridurre questo tempo di ricerca significa ridurre il tempo di attesa della risposta e aumentare l'efficienza. Ancora una volta ci viene in aiuto il \textbf{caching}: una volta che un \textbf{server} ha appreso un' \textbf{associazione}, la inserisce in \textbf{cache}. Il server marca le risposte prese dalla propria cache come \textbf{unauthoritative} o non autorevoli.

\pagebreak

Dopo un certo lasso di tempo chiamato \textbf{TTL} o \textbf{time to live} il server cancella dalla cache l'associazione per evitare l'invio di risposte obsolete.

\subsubsection{Record DNS} Il \textbf{database di un  server DNS} non è altro che una collezione di \textbf{records} strutturati nel seguente modo:
\begin{center}
	\textbf{(Nome di dominio, Tipo, Classe, TTL, Valore)}
\end{center}
A ogni \textbf{nome di dominio}, quindi a ogni \textbf{nodo dell'albero dello spazio dei nomi di dominio}, è associato un record composto da 5 campi.
\begin{itemize}
	\item \textbf{Nome di dominio} identifica il record della risorsa.
	\item \textbf{Tipo} definisce come interpretare il campo \textbf{Valore}.
	\item \textbf{Classe} definisce il tipo di rete, IN sta per Internet.
	\item \textbf{TTL} indica il numero di secondi per cui l'informazione deve essere ritenuta valida
	\item \textbf{Valore} contiene l'informazione memorizzata relativa al \textbf{nome di dominio}.
\end{itemize}
Di seguito i \textbf{tipi} dei \textbf{record}:
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|r}
			\textbf{Tipo} & \textbf{Interpretazione}                           \\
			\hline
			A             & indirizzo Ipv4 a 32 bit                            \\
			NS            & identifica i server autoritativi di una zona       \\
			CNAME         & il nome di dominio è un alias per quello ufficiale \\
			SOA           & informazioni autoritative riguardanti una zona     \\
			MX            & server di posta del dominio
			corrente                                                           \\
			AAAA          & indirizzo Ipv6                                     \\
		\end{tabular}
	\end{center}
\end{table}\newline
\begin{flushleft}
	\textit{Che protocollo di livello trasporto è usato?}
\end{flushleft}
Il sistema DNS può usare \textbf{sia} il \textbf{il protocollo TCP} che l'\textbf{UDP}.
Il \textbf{protocollo UDP} viene usato \textbf{quando} la dimensione del messaggio di risposta è \textbf{inferiore} a \textbf{512 byte}, molto spesso infatti i \textbf{datagrammi utente UDP} non possono superare i 512 byte come dimensione massima. In caso contrario si usa il \textbf{protocollo TCP}.
\begin{flushleft}
	\textit{Come si aggiungono nuovi domini al DNS?}
\end{flushleft}
Pagando i \textbf{registrar}, ovvero aziende commerciali accreditate dall'ICANN.

\pagebreak

\subsubsection{Messaggi DNS}
I \textbf{messaggi DNS} posso essere di \textbf{due tipi}: di \textbf{interrogazione} o di \textbf{risposta} e i due tipi hanno lo \textbf{stesso} formato.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/DNSmessage.png}
	\centering
	\caption{La struttura dei messaggi DNS, il messaggio interrogazione contiene solo la sezione richiesta mentre il messaggio di risposta contiene la sezione richiesta, la sezione risposta ed eventualmente le altre due.}
\end{figure}\newline
Descriviamo ora brevemente i vari campi situati prima dell'\textbf{intestazione} lunga \textbf{12 bytes}:
\begin{itemize}
	\item \textbf{Identificazione} è il campo usato dal \textbf{client} per associare la risposta all'interrogazione.
	\item Il campo \textbf{Flag} indica se si tratta di un messaggio di richiesta o di risposta e segnala inoltre la presenza di eventuali errori.
	\item I \textbf{quattro} campi successivi dell'\textbf{intestazione} specificano il numero di ciascun tipo di record presente nel messaggio.
\end{itemize}
Poi del \textbf{messaggio}:
\begin{itemize}
	\item La \textbf{sezione di richiesta} che è inclusa nell'interrogazione e poi ripetuta anche nel messaggio di risposta è \textbf{formata} da \textbf{uno o più record di richiesta}.
	\item La \textbf{sezione di risposta} è presente \textbf{esclusivamente} nei messaggi di risposta consiste \textbf{in uno o più record di risorsa}
	\item La \textbf{sezione autoritativa} fornisce le informazioni di uno o più server autorevoli per l'interrogazione.
	\item La \textbf{sezione supplementare} contiene \textbf{informazioni aggiuntive} che potrebbero essere \textbf{utili} al \textbf{client DNS}.
\end{itemize}
\textit{In UNIX si può utilizzare il comando} \texttt{nslookup} \textit{per ottenere associazioni nome simbolico : indirizzo numerico.}

\pagebreak

\subsection{EMAIL - SMTP}
\label{sec:SMTP}
La \textbf{posta elettronica} è uno dei primi servizi applicativi di Internet, la sua nascita risale infatti al 1971, quando un tale Ray Tomlinson installò su ARPANET un sistema in grado di scambiare messaggi fra le varie università. La \textbf{posta elettronica} consente agli utenti di scambiarsi \textbf{messaggi}, sebbene si siano trattate \textbf{altre applicazioni} fornenti questo servizio e.g.\  \textbf{HTTP} e \textbf{TCP}, il funzionamento della posta elettronica è tale da distinguersi da queste due applicazioni citate poco prima. Infatti in applicazioni come \textbf{FTP} e \textbf{HTTP} il programma \textbf{server} è \textbf{sempre attivo} e in attesa di richieste, che quando arrivano, vengono processate.
Vi è quindi una richiesta e una risposta. Nella \textbf{posta elettronica} il \textbf{funzionamento} è \textbf{differente}: infatti l'invio di un messaggio è considerato una \textbf{transazione unidirezionale}, la risposta può anche non arrivare e se arriva è considerata un'altra transazione unidirezionale. Secondariamente \textbf{non avrebbe} molto \textbf{senso tenere in esecuzione continuata un programma server} in attesa che qualcuno ci invii un messaggio, potremmo ragionevolmente voler spegnere il computer nell'attesa. Ciò implica che l'idea di modello client-server debba essere realizzata in un altro modo, magari utilizzando dei \textbf{server intermedi} e \textbf{disaccoppiando} le funzionalità di \textbf{ricezione} da quelle di \textbf{invio}. Di seguito illustriamo concisamente l'architettura della posta elettronica.
\begin{figure}[!h]
	\includegraphics[scale=0.45]{Immagini/MAIL.png}
	\centering
	\caption{Un esempio di architettura di posta elettronica.}
\end{figure}\newline
Tipicamente due utenti, mittente e destinatario, sono connessi a due \textbf{server di posta}. Ogni utente possiede una \textbf{mailbox} sul server, ovvero una porzione sulla memoria del server a cui solo lui può accedere e ogni server ha una \textbf{coda di invio}, o \textbf{spool}, dove memorizza i messaggi in attesa di essere inviati. Più:
\begin{itemize}
	\item \textbf{UA} o  \textbf{user agent}, prepara il messaggio e lo invia al server.
	\item \textbf{MTA} o \textbf{message trasfer agent}, è un'applicazione \textbf{push}.
	\item \textbf{MAA} o \textbf{message access agent}, è un'applicazione \textbf{pull}.
\end{itemize}

\pagebreak

Illustriamo ora \textbf{come avviene l'invio di un messaggio} da parte di \textit{Gaia} a \textit{Gabriele}.
\begin{enumerate}
	\item Gaia, utilizzando un programma \textbf{UA}, prepara il messaggio e lo invia al proprio server di posta.
	\item Il \textbf{server di posta memorizza} il messaggio in una coda, e lo \textbf{invia} tramite un \textbf{programma MTA} al server di posta di Gabriele. \textbf{\underline{N.B.} sono necessari due programmi MTA per ogni server di posta, un MTA server sempre attivo, in attesa di messaggi, e un MTA client, \underline{attivo all'evenienza}, che contatta il server di posta a cui deve essere inviato un messaggio  ed effettua l'invio}.
	\item Il server di posta \textbf{riceverà} il messaggio e lo \textbf{memorizzerà} nella \textbf{casella postale di Gabriele} che, a sua volta usando un programma \textbf{MAA client}, contatterà il programma \textbf{MAA server} del \textbf{server} e riceverà infine il messaggio.
\end{enumerate}
Lo \textbf{user agent} è il primo componente di un sistema di posta elettronica, \textbf{facilita all'utente l'invio e la ricezione dei messaggi}. Può avere o un'interfaccia a \textbf{riga di comando}, ma è abbastanza desueto, o di tipo \textbf{grafico}. Se l'utente decide di leggere i messaggi nella sua casella di posta elettronica lo \textbf{user agent} mostra un elenco dei messaggi ricevuti. Ogni riga dell'elenco offre un breve resoconto del messaggio, solitamente: \textbf{indirizzo del mittente}, \textbf{ora} e \textbf{oggetto del messaggio}.
\subsubsection{Indirizzi di posta elettronica}
Gli indirizzi di posta elettronica individuano gi utenti in modo \textbf{univoco}. Su \textbf{Internet} consistono di \textbf{due parti}:
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Mail_address.png}
	\centering
\end{figure}\newline
La \textbf{parte locale} identifica la \textbf{casella di posta del destinatario} sul server e il nome di dominio identifica il \textbf{server}.
\subsubsection{Invio di messaggi}
Con il protocollo \textbf{SMTP} o \textbf{simple mail transfer protocol}. Il protocollo \textbf{SMTP} definisce in maniera formale l'\textbf{interazione tra il client MTA e il server MTA}. Nell'operazione di invio di un messaggio SMTP è utilizzato \textbf{due} volte: tra il \textbf{mittente} e il \textbf{suo server di post}a e tra il \textbf{server di posta del mittente} e \textbf{quello del destinatario}. Di seguito un'immagine per schiarire le idee.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/SMTP.png}
	\centering
\end{figure}
Il \textbf{protocollo SMTP} definisce come deve avvenire l'interazione, per mezzo di \textbf{comandi} e \textbf{risposte}, tra \textbf{client e server MTA}. I comandi sono \textbf{inviati} dal \textbf{client MTA} al \textbf{server MTA} e viceversa le risposte.
I \textbf{comandi} e \textbf{le risposte} terminano tutti con la medesima \textbf{coppia} di \textbf{caratteri}: \textbf{ritorno a capo e fine linea}. \textbf{La connessione tra client MTA e server MTA è una sola ed è bidirezionale}.\newline
\begin{itemize}
	\item I \textbf{comandi} sono composti da una \textbf{keyword} e da \textbf{uno} o \textbf{più argomenti}.
	      \begin{table}[h!]
		      \begin{center}
			      \label{tab:table1}
			      \begin{tabular}{l|c|c}
				      \textbf{Nome} & \textbf{Argomenti}     & \textbf{Significato}                \\
				      \hline
				      HELO          & nome host mittente     & host mittente si identifica         \\
				      MAIL FROM     & mittente del messaggio & identifica mittente  messaggio      \\
				      RCPT TO       & destinatario           & identifica destinatario messaggio   \\
				      DATA          & corpo del messaggio    & il messaggio                        \\
				      QUIT          &                        & termina sessione SMTP
				      corrente                                                                     \\
				      RSET          &                        & interrompe la transazione in atto   \\
				      VRFY          & nome destinatario      & verifica validità nome destinatario \\
			      \end{tabular}
		      \end{center}
	      \end{table}
	\item Le \textbf{risposte} sono costituite da un \textbf{codice a tre cifre} seguite eventualmente da testo.
	      \begin{table}[h!]
		      \begin{center}
			      \label{tab:table1}
			      \begin{tabular}{l|c}
				      \textbf{Codice} & \textbf{Descrizione}                     \\
				      \hline
				      220             & servizio pronto                          \\
				      221             & servizio in chiusura canale trasmissione \\
				      250             & comando richiesto completato             \\
				      354             & corpo del messaggio                      \\
				      421             & servizio non disponibile                 \\
				      450             & mailbox non disponibile                  \\
				      502             & comando non disponibile                  \\
				      550             & user uknown                              \\
			      \end{tabular}
		      \end{center}
	      \end{table}
\end{itemize}

\pagebreak

\underline{N.B.} Il protocollo \textbf{SMTP} \textbf{usa} il protocollo di trasporto \textbf{TCP} per consegnare in maniera \textbf{\underline{affidabile}} i messaggi.\newline\newline
La consegna di un messaggio tramite SMTP prevede \textbf{tre fasi}:
\begin{enumerate}
	\item \textbf{Apertura della connessione} o \textbf{handshaking} con cui il client SMTP stabilisce una connessione TCP alla porta nota 25 con il server SMTP\@. Consiste di altre \textbf{tre sotto fasi}:
	      \begin{enumerate}[label*=\arabic*.]
		      \item Il \textbf{server} invia al \textbf{client} il codice \textbf{220} per indicare che è \textbf{pronto alla ricezione di messaggi} o il codice \textbf{421} in caso \textbf{contrario}.
		      \item Il \textbf{client} si \textbf{identifica} con il comando \textbf{HELO} seguito dal suo \textbf{nome di dominio} in modo tale da informare il server del proprio nome di dominio.
		      \item Il \textbf{server} invia il codice \textbf{250} o altri codici a seconda della situazione particolare.
	      \end{enumerate}
	\item \textbf{Invio del messaggio}: se l'apertura della connessione tra il client SMTP e il server SMTP è avvenuta con \textbf{successo}, il client può inviare \textbf{un singolo messaggio} a uno o più destinatari. Riportiamo di seguito gli \textbf{otto} passi necessari per portare a termine questa operazione:
	      \begin{enumerate}[label*=\arabic*.]
		      \item Il \textbf{client} invia al server il comando MAIL FROM con argomento l'indirizzo mail del mittente, in modo tale che, nel caso in cui si verifichino degli  errori, il server \textbf{sappia a chi inviare i messaggi di errore}.
		      \item Il \textbf{server} risponde con il codice 250.
		      \item Il \textbf{client} invia al server il comando RCPT TO con argomento l'indirizzo mail del destinatario
		      \item Il server risponde con il codice 250.
		      \item Il \textbf{client} invia il comando DATA per iniziare il trasferimento del messaggio.
		      \item Il \textbf{server} risponde con il codice 354.
		      \item Il \textbf{client} invia il messaggio come sequenza di righe, ognuna terminante con la coppia di caratteri ritorno a capo e fine linea. Il messaggio termina con una riga \textbf{contenente solo un punto}.
		      \item Il server risponde con il codice 250.
	      \end{enumerate}
	      Se ci sono \textbf{più destinatari} i passi 2.3 e 2.4 sono \textbf{ripetuti}.
	\item \textbf{Chiusura della connessione}: Il \textbf{client}, trasferito il messaggio, \textbf{chiude la connessione}. Questa operazione avviene in \textbf{due} fasi:
	      \begin{enumerate}[label*=\arabic*]
		      \item Il \textbf{client} invia al server il comando QUIT.
		      \item Il \textbf{server} risponde con il codice 221.
	      \end{enumerate}
\end{enumerate}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/SMTPes.png}
	\centering
	\caption{In figura l'invio di un messaggio. L'RFC 2822 definisce lo standard per il formato del messaggio. \textbf{I campi sono diversi dai comandi SMTP.} Il corpo del messaggio  contiene solamente caratteri ASCII a 7 bit.}
\end{figure}
\subsubsection{Ricezione dei messaggi}
Poco sopra abbiamo descritto l'invio di un messaggio di posta elettronica come la \textbf{composizione di tre fasi}: una di \textbf{preparazione} del messaggio, una di \textbf{invio} e una di \textbf{ricezione}. Le prime due utilizzano i \textbf{protocollo SMTP}, che è un protocollo \textbf{push}, il messaggio viene \textit{spinto} dal client mittente verso il server. L'ultima fase, quella di ricezione, usa invece un protocollo \textbf{pull}, il client destinatario \textit{tira} i messaggi dal server. Attualmente sono in uso \textbf{due} protocolli di tipo \textbf{pull}: \textbf{POP3} o \textbf{Post Office Protocol v.3} e \textbf{IMAP4} o \textbf{Internet Mail Access Protocol v.4}.
\textbf{POP3} è molto semplice ma ha funzionalità limitate. Il software \textbf{client POP3 } è installato sul computer del destinatario mentre il software \textbf{server POP3 }sul suo server di posta. Il \textbf{client POP3} apre una connessione TCP sulla porta \textbf{110} del \textbf{server POP3} e invia il proprio nome utente e la propria password per accedere alla casella postale. L'utente richiede poi la lista dei messaggi presenti e li preleva uno alla volta.

\pagebreak

\subsubsection{POP3}
Il \textbf{protocollo POP3} prevede due modalità: \textbf{delete} e \textbf{keep}, con la modalità \textbf{delete} i messaggi vengono automaticamente eliminati dalla mailbox dopo il prelievo, con la modalità \textbf{keep} vengono tenuti per uso futuro.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/POP3.png}
	\centering
	\caption{In figura il protocollo POP3.}
\end{figure}
\subsubsection{IMAP4}
Il \textbf{protocollo IMAP4} è simile al POP3 ma è più \textbf{potente} e \textbf{complesso}. POP3 \textbf{non} consente di \textbf{gestire più caselle }di posta sul server, di \textbf{organizzare} la posta e di \textbf{controllare una parte del messaggio prima di prelevarlo} nella sua interezza. \textbf{IMAP4} invece fornisce varie funzionalità aggiuntive, tra le quali:
\begin{itemize}
	\item \textbf{Controllare le intestazioni} dei messaggi prima di \textbf{prelevarli}.
	\item \textbf{Ricercare una stringa} specifica \textbf{nei messaggi prima di prelevarli}.
	\item \textbf{Prelevare i messaggi in modo parziale}. Utile per quando ci sono limitazioni di larghezza di banda.
	\item \textbf{Creare}, \textbf{cancellare} e \textbf{rinominare} le \textbf{mailbox} sul server di posta.
	\item \textbf{Creare una gerarchia di cartelle} all'interno della mailbox a scopo di archiviazione.
\end{itemize}
I protocolli visti fin'ora supportano \textbf{soltanto} messaggi nel formato standard \textbf{NVT ASCII a 7 bit}.

\pagebreak

\subsubsection{MIME}
Il \textbf{MIME} o \textbf{Multipurpose Internet Mail Extension} è un protocollo \textbf{supplementare} che permette l'invio di messaggi in formato \textbf{diverso} dall'\textbf{ASCII}. Il \textbf{MIME} agisce \textbf{sia} dal lato \textbf{mittente} \textbf{che} dal lato \textbf{destinatario}. Traduce tutti i dati in formato \textbf{non ASCII} in ASCII \textbf{prima} di inviare il messaggio al MTA e opera poi a ritroso quest'operazione di traduzione \textbf{presso} il destinatario dopo che ha ricevuto il messaggio tramite il MAA.
\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/MIME.png}
	\centering
	\caption{In figura il il funzionamento del protocollo MIME.}
\end{figure}\newline
Il \textbf{protocollo MIME} definisce \textbf{cinque} tipi di intestazioni specifiche che si aggiungono a quelle originali previste dal protocollo di posta elettronica:
\begin{itemize}
	\item \textbf{MIME - version}: vi è dichiarata la versione di MIME usata.
	\item \textbf{Content Type}: vi sono dichiarati i tipi di dato contenuti nel corpo del messaggio. Il tipo del contenuto e il sottotipo sono separati da una barra. Il protocollo MIME usa sette tipi di dato diversi:
	      \begin{itemize}
		      \item \textbf{Text}: \textbf{plain} o \textbf{html}, formato del testo.
		      \item \textbf{Multipart}: \textbf{mixed}, \textbf{parallel} o \textbf{alternative}, dà informazioni circa le parti da cui è composto il messaggio.
		      \item \textbf{Message}: \textbf{RFC 882}, \textbf{partial}, \textbf{external-body}, indicano rispettivamente: se il messaggio è incapsulato, se è una parte di un altro messaggio o se è un riferimento ad un altro messaggio.
		      \item \textbf{Image}: \textbf{jpeg} o \textbf{gif}.
		      \item \textbf{Video}: \textbf{mpeg}.
		      \item \textbf{Audio}: \textbf{basic}.
		      \item \textbf{Application}: \textbf{PostScript} o \textbf{octet-stream}.
	      \end{itemize}
	\item \textbf{Content-Transfer-Encoding}: definisce la codifica utilizzata per il messaggio.
	\item \textbf{Content-ID}: individua univocamente una parte nei messaggi che sono composti da più parti.
	\item \textbf{Content-Description}: indica se il corpo del messaggio contiene un'immagine, un file audio o video.
\end{itemize}

\pagebreak

\subsubsection{Web mail}
Concludiamo questa sezione offrendo una breve panoramica del servizio chiamato \textbf{web mail}. Data la larga diffusione della posta elettronica molti siti web ne offrono il servizio. I \textbf{webmail servers} a seconda del \textbf{client} interessato, che può essere \textbf{SMTP} o \textbf{HTTP}, ricevono ed evadono i messaggi tramite o il \textbf{protocollo HTTP} o il \textbf{protocollo SMTP} come illustrato nelle seguenti figure:
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Web_mail.png}
	\centering
	\caption{In figura uno scenario in cui \textbf{solo} il ricevente utilizza \textbf{HTTP}.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Web_mail1.png}
	\centering
	\caption{In figura uno scenario in cui \textbf{sia} che il ricevente che il destinatario utilizzano \textbf{HTTP}.}
\end{figure}
\section{Lo strato di trasporto}
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/App_tr_rete.png}
	\centering
	\caption{Livelli dello stack protocollare TCP/IP.}
\end{figure}
Nello \textbf{stack protocollare TCP/IP} il \textbf{livello di trasporto} è posizionato tra il livello applicazione e il livello rete, \textbf{fornisce} servizi al \textbf{livello applicazione} e ne \textbf{riceve} dal \textbf{livello rete}. Realizza una connessione \textbf{logica} fra \textbf{processi applicativi} in esecuzione su host system \textbf{diversi}.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/Trasporto.png}
	\centering
	\caption{In figura una rappresentazione della connessione logica tra i livelli trasporto di due host.}
\end{figure}
Come anticipato poco prima, uno dei \textbf{servizi offerti} dal \textbf{livello di trasporto} è di \textbf{supportare} la \textbf{comunicazione} tra \textbf{processi applicativi}. Tuttavia le \textbf{informazioni}, \textbf{una volta inviate}, \textbf{prima} di arrivare ai singoli processi devono arrivare all'\textbf{host} su cui essi sono in esecuzione.
\begin{figure}[!h]
	\includegraphics[scale=0.9]{Immagini/Trasporto_host.png}
	\centering
	\caption{In figura un esempio di comunicazione tra dispositivi. Si notino i ruoli dei protocolli di rete e dei protocolli di trasporto.}
\end{figure}\newline
I \textbf{protocolli di rete} si occupano di trasferire informazioni tra \textbf{macchine} e i \textbf{protocolli di trasporto} di indirizzarle ai \textbf{processi}.

\pagebreak

\begin{flushleft}
	\textit{Come indirizzare le informazioni verso i processi?}
\end{flushleft}
Come osservato nella sezione precedente, uno dei principali modelli di comunicazione interprocessuale è il \textbf{client-server}. Per garantire quindi la \textbf{comunicazione} tra il \textbf{processo client} e il \textbf{processo server} c'è bisogno di:
\begin{enumerate}
	\item \textbf{Identificare l'host locale e l'host remoto}. Spesso infatti, se non quasi sempre, il processo client e il processo server sono in esecuzione su host \textbf{diversi}. Gli host, in \textbf{rete}, vengono identificati mediante il loro \textbf{indirizzo IP}.
	\item \textbf{Identificare il processo}. I sistemi operativi moderni sono \textbf{multiutente} e \textbf{multiprocesso}. I processi necessitano quindi di un  identificatore detto \textbf{numero di porta}. I protocolli TCP/IP usano numeri di porta compresi tra \textbf{0} e \textbf{65535}, l'intervallo è codificabile con \textbf{16 bit}.
\end{enumerate}
Al \textbf{client} viene \textbf{assegnato} un \textbf{numero di porta} detto \textbf{effimero}, ovvero di breve durata, dato il \textbf{breve} tempo di vita di un processo client. I numeri di porta \textbf{effimeri} sono superiori al \textbf{1023}.\newline
Anche al \textbf{server} verrà \textbf{associato} un \textbf{numero di porta} che dovrà però essere \textbf{noto} al \textbf{client}. Nei \textbf{protocolli TCP/IP},  per i server, si usano \textbf{numeri di porta universali} detti anche \textbf{numeri di porta noti}. Ogni \textbf{client applicativo conosce} il numero di porta noto del \textbf{server applicativo} corrispondente.
\begin{figure}[!h]
	\includegraphics[scale=0.65]{Immagini/Port_numb.png}
	\centering
	\caption{In figura i numeri di porta di un processo client e del corrispondente processo server.}
\end{figure}\newline
\textbf{Ricapitolando}: l'\textbf{indirizzo IP individua un host} tra i miliardi di host dell'intera rete mondiale ed è un numero di 32 bit. Il \textbf{numero di porta individua un processo} in esecuzione su tale host.

\pagebreak

L'\textbf{ICANN}, ovvero \textbf{Internet Corporation for Assigned Names and Numbers} ha suddiviso i numeri di porta in \textbf{tre} categorie:
\begin{enumerate}
	\item \textbf{Numeri di porta noti}: sono compresi tra \textbf{0} e \textbf{1023} e sono \textbf{assegnati} dall'authority \textbf{ICANN}.
	\item \textbf{Numeri di porta registrati}: sono compresi tra \textbf{1024} e \textbf{49151}, \textbf{non} sono \textbf{controllati} \textbf{né} \textbf{assegnati} dall'autorithy ICANN ma è \textbf{possibile} \textbf{registrarli} per evitare duplicazioni.
	\item \textbf{Numeri di porta dinamici}: vanno da \textbf{49152} a \textbf{65535}, \textbf{non} sono \textbf{controllati} \textbf{né} \textbf{registrati} e possono essere usati come numeri di porta \textbf{privati} o \textbf{temporanei}.
\end{enumerate}
\textit{In ambiente UNIX nel file} \texttt{/etc/services} \textit{sono memorizzate le associazioni nome server : porta nota}.
\theoremstyle{definition}
\begin{definition}
	La \textbf{combinazione} di \textbf{indirizzo IP} e \textbf{numero di porta} è detta \textbf{socket address}.
\end{definition}
Quando un processo applicativo deve inviare un messaggio a un altro processo applicativo, lo passa al livello trasporto insieme a una \textbf{coppia} di \textbf{socket address}, uno che identifica il \textbf{processo stesso} e uno che identifica il \textbf{processo destinatario}. Il \textbf{protocollo di trasporto} riceve questi dati e vi aggiunge la propria \textbf{intestazione}, \textbf{incapsulando} il tutto in un \textbf{pacchetto}. Questi pacchetti sono chiamati \textbf{segmenti} nel \textbf{protocollo TCP} e \textbf{datagrammi utente} nel \textbf{protocollo UDP}. L'\textbf{incapsulamento} avviene dal lato del \textbf{mittente} e il \textbf{decapsulamento} avviene dal lato del \textbf{ricevente}.

Il metodo con cui un entità riceve informazioni da più di una sorgente è chiamato \textbf{multiplexing}, viceversa con \textbf{demultiplexing} si fa riferimento a un'entità che trasmette informazioni a più di un destinatario. Il \textbf{livello di trasporto} effettua \textbf{multiplexing} sul versante \textbf{mittente}, raccogliendo i messaggi da varie socket e incapsulandoli, e \textbf{demultiplexing} su quello del \textbf{destinatario}, consegnando i vari pacchetti in ingresso al socket appropriato.

La \textbf{socket UDP} è identificata dalla coppia \textbf{IP e porta}. Nel caso di \textbf{demultiplexing senza connessione}, lo strato di trasporto dell'host ricevente consegna il segmento UDP alla socket identificata da IP e porta destinazione. I datagrammi con IP e/o porta mittente differenti ma stessi IP e porta destinatari vengono consegnati alla \textbf{stessa socket}.

La \textbf{socket TCP} è invece identificata da \textbf{quattro parametri}: \textbf{indirizzo IP di origine, numero di porta di origine, indirizzo IP di destinazione e numero di porta di destinazione}. Lo strato di trasporto dell'host ricevente usa questi quattro parametri per inviare il segmento alla \textbf{socket appropriata}, consentendo a un host che fa da server di supportare più socket contemporanee. (\textit{e.g.\  un server web può così avere socket differenti per ogni client!})

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/app_trans_net_int.png}
	\includegraphics[scale=0.3]{Immagini/no_conn_demul.png}
	\centering
	\caption{Demultiplexing in assenza di connessione}
\end{figure}

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/conn_demul.png}
	\centering
	\caption{Demultiplexing in presenza di connessione}
\end{figure}

\begin{flushleft}
	\textit{Come garantire un controllo del flusso?}
\end{flushleft}
\textbf{Il livello di trasporto} supporta la comunicazione tra \textbf{processi applicativi}.  Il \textbf{processo mittente} \textbf{produce informazioni} e le passa poi allo \textbf{strato di trasporto mittente} che le \textbf{consuma} e \textbf{produce pacchetti}. Lo \textbf{strato di trasporto destinatario} a sua volta \textbf{consuma pacchetti} e \textbf{produce informazioni} che verranno in seguito inviate al \textbf{processo destinatario}. Se i pacchetti vengono consumati con una velocità \textbf{inferiore} o \textbf{superiore} a quella con cui si è in grado di crearli o viceversa si va in contro a situazioni di \textbf{grave inefficienza} o addirittura di \textbf{perdita di dati}. Il controllo di flusso si occupa di \textbf{quest'ultima problematica}.

\pagebreak

Una soluzione tipica per evitare la \textbf{perdita di dati} consiste nell'utilizzare \textbf{due} buffer. Uno dal \textbf{lato trasporto  del destinatario} e \textbf{uno dal lato trasporto del mittente}. Se il \textbf{destinatario} ha il buffer \textbf{saturo} lo segnalerà al \textbf{mittente} che a sua volta \textbf{tratterrà} i messaggi nel \textbf{proprio} buffer e li rinvierà quando il \textbf{destinatario} segnalerà che il suo buffer non è più saturo.
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/Plexing.png}
	\centering
	\caption{In figura multiplexing e demultiplexing.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Flusso_ctr.png}
	\centering
	\caption{In figura il controllo di flusso.}
\end{figure}

\pagebreak

\begin{flushleft}
	\textit{Come garantire l'affidabilità?}
\end{flushleft}
Aggiungendo i \textbf{servizi di controllo degli errori} al livello di trasporto.
Il \textbf{livello di rete} infatti, come si vedrà più avanti, è \textbf{fallace}, ciò comporta che si debba \textbf{garantire l'affidabilità}, \textbf{se richiesta dalle applicazioni}, \textbf{al livello di trasporto}. Nel \textbf{controllo degli errori} sono coinvolti \textbf{solo} i \textbf{livelli trasporto del mittente e del destinatario}, in particolare, \textbf{è quest ultimo che gestisce il controllo degli errori}:
\begin{itemize}
	\item \textbf{Rileva e scarta i pacchetti corrotti}, notificando il problema al livello trasporto del mittente.
	\item \textbf{Tiene traccia dei pacchetti persi e scartati e ne gestisce la rispedizione}.
	\item \textbf{Riconosce i pacchetti duplicati e li elimina}.
	\item \textbf{Bufferizza i pacchetti fuori sequenza finché non arrivano quelli mancanti}.
\end{itemize}
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Error_ctr.png}
	\centering
	\caption{Il controllo degli errori.}
\end{figure}
Gli ultimi \textbf{tre} punti implicano che \textbf{il livello di trasporto del destinatario} \textbf{sappia riconoscere} i pacchetti \textbf{persi}, \textbf{duplicati} o \textbf{fuori sequenza}. Ciò è possibile grazie alla presenza di un campo, detto \textbf{numero di sequenza}, posto all'\textbf{interno} dei pacchetti. La \textbf{rispedizione} è gestita identificando il pacchetto mancante o corrotto mediante il suo numero di sequenza. I \textbf{pacchetti duplicati} o \textbf{mancanti} sono riconosciuti ordinando la sequenza di pacchetti entranti e verificando tutti i numeri di sequenza.\newline
\underline{\textbf{N.B.}} i numeri di sequenza vanno da 0 a $2^n - 1$, dove \textbf{n} è il numero di bit allocati per i numeri di sequenza specificato nell'intestazione del pacchetto. Se la sequenza di pacchetti è più lunga di $2^n$ pacchetti si ricomincia ad enumerarli da 0, di fatto i \textbf{numeri di sequenza} sono in \textbf{modulo} $2^n - 1$.
\begin{center}
	\textbf{e.g.\ } per n = 3 si ha la sequenza: 0 1 2 3 4 5 6 7 0 1 2 3 4 $\dots$
\end{center}
Per \textbf{notificare} al mittente la corretta ricezione di uno o più pacchetti viene utilizzato il \textbf{numero di riscontro} o \textbf{ACK}. Il mittente identifica i pacchetti persi utilizzando un \textbf{timer} e \textbf{attivandolo dopo ogni invio}, se non riceve un \textbf{ACK prima della scadenza} allora rispedisce il pacchetto.

\pagebreak

\begin{flushleft}
	\textit{È possibile combinare controllo degli errori e controllo del flusso?}
\end{flushleft}
Sì, è \textbf{possibile}. Per farlo si usa una coppia di \textbf{buffer numerati}, combinando l'esigenza di avere due buffer a quella di numerare i pacchetti.
Dal \textbf{lato mittente}, quando si \textbf{costruisce un pacchetto} per la spedizione, si usa come \textbf{numero di sequenza} la successiva posizione libera all'interno del buffer e lo si tiene in memoria finché non arriva l'\textbf{ACK} corrispondente. Dal \textbf{lato destinatario} invece, si tiene in memoria nel buffer il pacchetto ricevuto finché l'applicazione non è pronta a riceverlo, \textbf{solo} a quel punto viene inviato l'\textbf{ACK} e il pacchetto viene \textbf{eliminato}. L'intervallo dei numeri di sequenza: da 0 a $2^n - 1$, fa si che possano essere rappresentati come un \textbf{cerchio} e il buffer, a seconda della sua \textbf{dimensione}, come una \textbf{sezione} di esso, chiamata anche \textbf{sliding window}. Quando all'interno del \textbf{buffer} (\textbf{sliding window}) si libera una sezione \textbf{contigua} di posizioni \textbf{a partire dall'inizio}, la \textbf{sliding window} scorre.
\begin{figure}[!h]
	\includegraphics[scale=0.75]{Immagini/Sliding_w.png}
	\centering
	\caption{La sliding window. Si ricorda che è solo un'astrazione per far capire il concetto di fondo, in realtà si usano delle variabili per tenere traccia delle posizioni.}
\end{figure}
\begin{flushleft}
	\textit{Esiste un controllo della congestione?}
\end{flushleft}
Sì. \textbf{esiste}, sebbene sia un \textbf{problema} del \textbf{livello rete}, il \textbf{protocollo TCP} implementa un \textbf{proprio} meccanismo di controllo della congestione.

\pagebreak

\begin{flushleft}
	\textit{Che differenza c'è tra un servizio privo di connessione e un servizio orientato alla connessione?}
\end{flushleft}
Un \textbf{protocollo di livello trasporto}, cosi come un protocollo di livello rete, può fornire \textbf{due differenti tipi di servizi}: \textbf{connection-oriented} o \textbf{connection-less}. A livello di \textbf{rete} un servizio \textbf{connection-less} può comportare che datagrammi facenti parte dello stesso messaggio transitino su percorsi fisici \textbf{diversi}. A \textbf{livello di trasporto} invece, il percorso dei pacchetti \textbf{non è rilevante}, la \textbf{presenza} o l'\textbf{assenza di connessione} implicano rispettivamente \textbf{la dipendenza o l'indipendenza fra i pacchetti}.
\begin{itemize}
	\item \textbf{In un servizio privo di connessione} il \textbf{processo applicativo mittente  deve suddividere i suoi messaggi in porzioni accettabili dal protocollo di livello trasporto} \textbf{connection-less}, che li tratterà come se fossero unità indipendenti e scorrelate. Le varie porzioni sono \textbf{consegnate} al livello trasporto \textbf{in ordine}, ma \textbf{non} verrano \textbf{riconsegnate} al processo applicativo destinatario \textbf{in tal modo}. Inoltre i pacchetti \textbf{non sono numerati}. \textbf{Non è possibile implementare efficacemente il controllo di flusso, il controllo degli errori e il controllo della congestione.}
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Connection_less.png}
		      \centering
		      \caption{Un servizio privo di connessione.}
	      \end{figure}
	\item \textbf{In un servizio orientato alla connessione} i due processi comunicanti devono per prima cosa stabilire \textbf{una connessione logica} e poi possono iniziare a scambiarsi dati. Una volta \textbf{terminato lo scambio} la connessione viene \textbf{chiusa}. Come menzionato in precedenza ancora una volta l'approccio \textbf{connection-oriented} è \textbf{diverso} tra il livello di trasporto e il livello di rete. Nel livello di rete si presuppone una coordinazione totale fra gli host finali e tutti i router della rete, al livello di trasporto solo tra i due host finali. Ciò significa che \textbf{è possibile utilizzare un protocollo di trasporto connection-oriented indipendentemente dal protocollo di rete utilizzato}.
\end{itemize}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Connection_oriented.png}
	\centering
	\caption{Un servizio orientato alla connessione.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.8]{Immagini/Asf_diff.png}
	\centering
	\caption{Differenze tra i due approcci descritti sopra rappresentati come automi a stati finiti. La rappresentazione dell'approccio connection-oriented in esempio prevede l'apertura di una connessione bidirezionale.}
\end{figure}

\pagebreak

\subsection{UDP}
Il \textbf{protocollo UDP} o \textbf{User Datagram Protocol} è un protocollo di livello trasporto \textbf{inaffidabile} e \textbf{privo di connessione}. \textbf{Non aggiunge} \textbf{niente} ai \textbf{servizi IP} se non la comunicazione tra processi che avviene mediante l'utilizzo di \textbf{due code}, una in \textbf{ingresso} e una in \textbf{uscita}. Essendo \textbf{molto semplice} ha un \textbf{overhead minimo} ed è per ciò usato da processi che vogliono inviare \textbf{messaggi contenuti} senza preoccuparsi troppo dell'affidabilità che può comunque essere aggiunta al livello applicazione. \textbf{Al livello trasporto non è effettuato nessun controllo di flusso né di congestione}.\newline
I \textbf{pacchetti UDP} sono chiamati \textbf{datagrammi utente} e data l'\textbf{assenza di una connessione} vengono \textbf{trasmessi in modo indipendente} gli uni dagli altri. La loro \textbf{intestazione} è costituita da \textbf{4 campi di 2 byte}, per un totale di 8 byte.
\textbf{\underline{N.B.}} \textbf{Solo} i processi che inviano messaggi di dimensione \textbf{inferiore a 65507}, i.e. $65535 - 8$ byte di intestazione UDP $= 65527 - 20$ di intestazione IP $ = 65507$, \textbf{possono usare il protcollo UDP}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/UDP.png}
	\centering
	\caption{La struttura di un datagramma utente. La prima parte in figura è uno \textbf{pseudo header} e \textbf{non} viene trasmesso. Il campo proto serve a distinguere i pacchetti UDP (17) da quelli TCP.}
\end{figure}\newline
I \textbf{primi} \textbf{due campi} definiscono i numeri di porta rispettivamente del \textbf{mittente} e del \textbf{destinatario}. Il \textbf{terzo campo} definisce la \textbf{lunghezza totale del datagramma} compresa l'intestazione. \textit{I 16 bit possono definire una lunghezza totale da 0 a 65535 ma in realtà la dimensione è \textbf{inferiore}, il datagramma utente viene infatti inserito in un datagramma IP di lunghezza totale di 65535}. Lo \textbf{pseudoheader} è una parte dell'intestazione del \textbf{pacchetto IP} in cui viene incapsulato il datagramma utente. \textbf{L'ultimo campo} dell'intestazione può contenere la \textbf{checksum}, se il campo è settato con tutti 0, il mittente ha deciso di non calcolarla. La \textbf{checksum} è \textbf{l'unico} controllo degli errori che UDP mette  a disposizione, usa tutti i campi del datagramma \textbf{compreso lo pseudoheader}, se quest ultimo non fosse incluso infatti, si rischierebbe che il datagramma, seppur privo di errori in invio, finisca a un host sbagliato per via di errori nel pacchetto IP che lo trasporta.

\pagebreak

\subsubsection{Checksum}
La \textbf{checksum} viene calcolata nel seguente modo:
\begin{itemize}
	\item \textbf{Mittente}
	      \begin{enumerate}
		      \item Il messaggio viene diviso in parole da 16 bit.
		      \item Il valore della checksum viene inizialmente impostato a 0.
		      \item Tutte le parole del messaggio vengono sommate usando l'addizione complemento a 1.
		      \item Viene fatto il complemento a 1 della somma e il risultato è la \textbf{checksum}.

	      \end{enumerate}
	\item \textbf{Destinatario}
	      \begin{enumerate}
		      \item Il messaggio che comprende la checksum viene ricevuto.
		      \item Vengono ripetuti i passaggi 3 e 4 descritti in precedenza.
		      \item Se il valore della checksum è 0 allora il messaggio viene accettato altrimenti viene scartato.
	      \end{enumerate}
\end{itemize}
\begin{verbatim}
 1110011001100110 + 
 1101010101010101 =
11011101110111011 troncamento
 1011101110111011 somma
 0100010001000100 checksum
\end{verbatim}
\subsubsection{DNS e UDP}
Il \textbf{DNS usa UDP} \textbf{poiché} le richieste che il \textbf{client DNS} invia al \textbf{server DNS} sono \textbf{brevi} e possono essere \textbf{contenute in un singolo datagramma UDP}. Inoltre le \textbf{risposte} devono arrivare \textbf{velocemente} e soprattutto viaggia un \textbf{solo messaggio} per volta: uno di richiesta e uno di risposta, quindi \textbf{non c'è un problema di ordine di sequenza}.
\subsubsection{Applicazioni UDP}
UDP potrebbe essere usato da applicazioni i cui processi:
\begin{itemize}
	\item \textbf{Richiedono uno scambio di dati di volume limitato, con scarso interesse verso il controllo del flusso e degli errori}. \textbf{Non} è quindi adatto ad applicazioni come \textbf{SMTP} e \textbf{FTP}.
	\item \textbf{Possiedono meccanismi interni di controllo di flusso e di errore.}
	\item \textbf{Trasmettono in multicast.}
	\item \textbf{Non tollerano latenza} e.g.\  applicazioni interattive o real time.
\end{itemize}

\pagebreak

\subsection{TCP}
\label{sec:TCP}
Il \textbf{protocollo TCP} è un protocollo \textbf{orientato alla connessione e affidabile}, è il protocollo di livello trasporto \textbf{più utilizzato} su Internet.
Quando un processo sull'host A decide di inviare e ricevere dati da un processo sull'host B avvengono le seguenti \textbf{tre} cose:
\begin{enumerate}
	\item I due processi stabiliscono una connessione \textbf{logica}.
	\item Vengono scambiati dati in \textbf{entrambe} le direzioni.
	\item La connessione viene terminata.
\end{enumerate}
Oltre a essere \textbf{orientato alla connessione}, il protocollo TCP è anche \textbf{orientato al flusso dati}. Al contrario di UDP quindi due processi che comunicano via TCP hanno l'\textit{illusione} di essere connessi con un \textit{\textbf{tubo}}. Diremo che il processo in trasmissione \textbf{produce} il flusso
mentre il processo in ricezione lo \textbf{consuma}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/TCP_flow.png}
	\centering
	\caption{Rappresentazione del flusso dati.}
\end{figure}\newline
Poichè il processo produttore e il processo consumatore non scrivono e leggono dati necessariamente alla stessa velocità è necessario un \textbf{controllo del flusso} che consiste in \textbf{due} buffer \textbf{uno di trasmissione}, in cui si memorizzano i segmenti \textbf{inviati}, e \textbf{uno di ricezione} in cui si memorizzano quelli \textbf{ricevuti}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/TCP_buffers.png}
	\centering
	\caption{I due buffer.}
\end{figure}\newline
Tipicamente viene usato un \textbf{buffer circolare}, poiché consente più agilmente di mettere a disposizione per la scrittura le celle che contengono byte inviati e la cui ricezione è stata confermata.

\pagebreak

Sebbene la \textbf{bufferizzazione} gestisca il \textbf{controllo del flusso}, per inviare dati in uno \textbf{stream} bisogna ovviare a un altro problema. Il \textbf{livello IP infatti} invia i dati in \textbf{pacchetti} e non in un flusso di byte. Per far fronte a ciò \textbf{TCP raggruppa un certo numero di byte in unità chiamate segmenti},  \textbf{indipendenti} dal programma applicativo, a cui aggiunge un'intestazione prima di affidarli al livello rete.
I \textbf{segmenti} vengono poi incapsulati in datagrammi IP e trasmessi. La \textbf{bufferizzazione} consente una \textbf{riduzione del traffico} sulla rete
ottimizzando in un certo modo il numero di segmenti da trasmettere\newline
\textbf{\underline{N.B.}} non è detto che tutti i segmenti abbiano la \textbf{stessa dimensione}.
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/TCP_segm.png}
	\centering
	\caption{Il flusso di dati viene partizionato in segmenti, ognuno con il suo header.}
\end{figure}\newline
Il \textbf{protocollo TCP} inoltre fornisce un servizio \textbf{full duplex}, nel quale, instaurata la connessione, le due entità possono \textbf{scambiarsi} e \textbf{ricevere} i dati \textbf{contemporaneamente}. \textbf{Ciascuna entità TCP} ha infatti i propri buffer di \textbf{invio} e \textbf{ricezione}.
\subsubsection{Numerazione dei pacchetti}
L'affidabilità è garantita con un \textbf{meccanismo di numerazione} che prevede due campi: \textbf{il numero di sequenza} e \textbf{il numero di riscontro o ACK}. Questi due campi sono contenuti nell'\textbf{intestazione} dei segmenti TCP e fanno riferimento al \textbf{numero dei byte}, non al numero di segmento. \textbf{TCP} infatti \textbf{numera i byte che vengono trasmessi nella connessione}. Questa \textbf{numerazione} avviene all'interno del \textbf{buffer di trasmissione}, dopo che i byte sono stati generati dal processo applicativo mittente. I numeri di sequenza e di riscontro sono \textbf{diversi} nelle due \textbf{direzioni} della comunicazione. Il numero di sequenza del primo byte non necessariamente è 0 ma è \textbf{generato arbitrariamente} nell'intervallo tra 0 e $2^{32} - 1$.
Dopo aver numerato i byte, \textbf{TCP assegna a ogni segmento un numero di sequenza corrispondente al numero del primo byte del segmento}.
Il \textbf{primo numero di sequenza} o \textbf{ISN} è un numero casuale tra 0 e $2^{32} -1$. \textbf{Tutti gli altri numeri }sono il numero di sequenza del segmento precedente a cui viene sommato il numero di byte, \textbf{reali o fittizi}, contenuti dal successivo.

\pagebreak

Oltre al \textbf{numero di sequenza } nell'intestazione di un \textbf{segmento TCP} è contenuto anche un \textbf{numero di riscontro}, più brevemente detto \textbf{ACK}. L' \textbf{ACK} è utilizzato dalle due entità comunicanti per \textbf{confermare i byte ricevuti}, indica infatti il \textbf{numero} del \textbf{prossimo byte} che l'entità si aspetta di ricevere. \textit{e.g.\  se un'entità utilizza 5643 come ACK significa che ha ricevuto tutti i byte fino al 5642. \underline{\textbf{N.B.}}: non necessariamente vuol dire che l'entità ha ricevuto 5642 byte.}\newline
Riportiamo di seguito la \textbf{struttura} di un \textbf{segmento TCP}:
\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/TCP_segment.png}
	\centering
	\caption{La struttura di un segmento TCP.}
\end{figure}\newline
Il \textbf{segmento consiste} di un'\textbf{intestazione} di dimensione compresa tra 20 byte, in assenza di opzioni, e 60 byte altrimenti, seguita dai \textbf{dati} provenienti dal processo applicativo.
\begin{itemize}
	\item \textbf{Numero di porta sorgente}: contiene il numero di porta del processo mittente sull'host che invia il segmento.
	\item \textbf{Numero di porta destinazione}: contiene il numero di porta del processo destinatario sull'host che riceve il segmento.
	\item \textbf{Numero di sequenza}: contiene il numero di sequenza associato al primo byte di dati contenuto nel segmento.
	\item \textbf{Numero di riscontro}: contiene il numero di sequenza del byte che l'entità si aspetta di ricevere.
	\item \textbf{HLEN o lunghezza dell'intestazione}: indica il numero di parole di 4 byte presenti nell'intestazione, varia da 5 ($\frac{20}{4}$) a 15 ($\frac{60}{4}$).
	\item \textbf{Flags di controllo}: contiene i 6 bit di controllo, più di un bit può essere attivo contemporaneamente. Questi bit intervengono nel \textbf{controllo del flusso}, \textbf{nell'apertura e nella chiusura della connessione e nella determinazione della modalità di trasferimento dei dati}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/TCP_flags.png}
		      \centering
		      \caption{I flags di controllo e il loro significato.}
	      \end{figure}
	\item \textbf{Dimensione della finestra}: contiene la dimensione della finestra di ricezione di cui dispone l'entità, la dimensione massima è di 65535 byte, legata ai 16 bit che compongono il campo. È solitamente indicato con RWND o receiving window ed è determinato dal ricevente, il mittente deve rispettare le sue indicazioni.
	\item \textbf{Checksum}: contiene il \textbf{checksum}, è calcolato da TCP con le stesse modalità descritte per UDP, tuttavia è \textbf{obbligatoriamente richiesto} per i datagrammi TCP\@. Lo pseudoheader ha lo stesso scopo descritto per UDP, però il \textbf{campo proto vale 6}.
	\item \textbf{Puntatore urgente}: è rilevante se il flag \textbf{URG} è attivato. Contiene la cifra da sommare al numero di sequenza del segmento per ottenere il numero dell'ultimo bit urgente della sezione dati.
	\item \textbf{Opzioni}: contiene da 0 a 40 byte di informazioni opzionali.
\end{itemize}
\subsubsection{Connessione TCP}
Il \textbf{protocollo TCP} è \textbf{connection-oriented} il che vuol dire che stabilisce una connessione logica tra il processo mittente e il processo destinatario e tutti i segmenti TCP vengono spediti lungo questo percorso. L'utilizzo di una connessione virtuale \textbf{semplifica} i \textbf{processi di conferma}, di \textbf{controllo degli errori} e \textbf{di rispedizione}. La trasmissione orientata alla connessione del protocollo TCP richiede \textbf{tre fasi}: \textbf{apertura della connessione}, \textbf{trasmissione dei dati} e \textbf{chiusura della connessione}.
\begin{figure}[!h]
	\includegraphics[scale=0.44]{Immagini/Three_way.png}
	\centering
	\caption{L'apertura della connessione TCP.}
\end{figure}

\pagebreak

\begin{enumerate}
	\item \textbf{Apertura della connessione}: nel TCP, essendo un protocollo \textbf{full duplex}, le due entità comunicanti devono inizializzare la connessione e ciascuna deve ottenerne l'\textit{approvazione} da parte dell'altra. L'apertura della connessione TCP è detta \textbf{three-way handshake} e avviene nel seguente modo:
	      \begin{enumerate}[label*=\arabic*.]
		      \item Il \textbf{client} invia il primo segmento: si tratta di un \textbf{segmento SYN}, \textbf{senza dati utente} e \textbf{contenente solo il flag SYN} che specifica l' \textbf{ISN} della connessione client-server.
		      \item Il \textbf{server} invia il secondo segmento, senza dati utente, con i flag \textbf{ACK} e \textbf{SYN}, l'ACK viene usato dal server per comunicare al client la corretta ricezione del primo segmento e il SYN per specificare l'ISN della connessione server-client. Dato che il segmento contiene un \textbf{riscontro}, conterrà anche la dimensione della finestra di ricezione a cui il client dovrà attenersi.
		      \item A questo punto il \textbf{client} invia il terzo segmento e con il flag \textbf{ACK} comunica al server la corretta ricezione del secondo segmento. Il terzo segmento \textbf{può} contenere dati utente e \textbf{se} li contiene possiede anche un \textbf{numero di sequenza}.
	      \end{enumerate}
\end{enumerate}
Dopo aver instaurato la connessione è possibile trasferire i dati. Come detto sopra, il \textbf{protocollo TCP mittente memorizza i dati} generati dal processo mittente in un \textbf{buffer}, la quantità di dati che verranno poi inseriti nel segmento e inviati è a discrezione del TCP stesso. \textbf{Anche} il protocollo \textbf{TCP destinatario memorizza i dati in un buffer} e li invia al processo destinatario quando questo è pronto alla ricezione o quando il TCP destinatario lo ritiene opportuno. \begin{flushleft}
	\textit{Cosa succede se non possono essere tollerati ritardi nella consegna e nella ricezione dei dati?}
\end{flushleft}
Il protocollo TCP gestisce quest'eventualità con la \textbf{funzione push} che può essere \textbf{richiesta dal processo mittente}. In questo caso il \textbf{TCP mittente invia immediatamente i dati al TCP destinatario} e tramite il \textbf{flag PSH} specifica \textbf{che i dati devono essere immediatamente consegnati al processo destinatario}.
\begin{flushleft}
	\textit{Cosa succede se un processo necessita che il TCP elabori dei dati per primi indipendentemente dalla loro posizione nel segmento?}
\end{flushleft}
Il processo invierà i dati urgenti in un segmento con il \textbf{flag URG} attivato, li posizionerà all'\textbf{inizio} del segmento stesso e indicherà poi al TCP mittente, mediante il \textbf{puntatore urgente}, il \textbf{numero dell'ultimo byte di dati urgenti} contenuti nel segmento.\  e.g.\  se il numero di sequenza del segmento vale 15000 e il puntatore urgente vale 200, l'ultimo byte urgente sarà il 15200.

\pagebreak

\begin{flushleft}
	\textit{Come avviene la chiusura della connessione TCP?}
\end{flushleft}
Entrambe le entità coinvolte possono chiudere la connessione, solitamente però la chiusura della connessione è iniziata dal processo client. Sono offerte due vie per la chiusura della connessione: \textbf{handshake a tre vie} e \textbf{handshake a quattro vie con half close}.
\begin{itemize}
	\item \textbf{Handshake a tre vie}: inizia con l'invio da parte del TCP client
	      di un \textbf{segmento FIN} all'interno del quale viene settato il \textbf{flag FIN}. Questo segmento può contenere o meno dati utente, se non li contiene consuma solo un numero di sequenza.
	      Il \textbf{server TCP}, dopo aver ricevuto il segmento FIN, notifica il client TCP della ricezione e annuncia la chiusura della connessione server-client inviando un \textbf{segmento FIN $+$ ACK}. Questo segmento può contenere o meno dati da parte del server, se non li contiene consuma solo un numero di sequenza.
	      Il \textbf{client TCP} finalizza la chiusura della connessione inviando un segmento ACK per notificare il server della ricezione del segmento precedente. Questo segmento \textbf{non contiene dati utente e non consuma numeri di sequenza}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Three_wayc.png}
		      \centering
		      \caption{Chiusura della connessione tramite handshake a tre vie.}
	      \end{figure}
	\item Nella \textbf{chiusura handshake a quattro vie con halfclose} un \textbf{processo smette di inviare dati mentre ne sta ancora ricevendo dall'altro}. \textit{e.g.\  l'ordinamento di una grossa quantità di dati inviati da un client a un server}. Il \textbf{client TCP} richiede la halfclose inviando un \textbf{segmento FIN}, il server accetta la richiesta di chiusura inviando un \textbf{segmento ACK}. Il trasferimento dei dati client-server \textbf{termina} ma il \textbf{server può ancora inviare dati al client}. Quando a sua volta il \textbf{server termina} l'invio dei dati, invia un \textbf{segmento FIN} al client che risponde con un \textbf{segmento ACK}.
\end{itemize}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Halfway.png}
	\centering
	\caption{Chiusura della connessione tramite handshake a quattro vie con halfclose.}
\end{figure}
Una visione generale con un \textbf{diagramma delle transizioni di stato del protocollo TCP}:
\begin{figure}[!h]
	\includegraphics[scale=0.7]{Immagini/ASFTCP.png}
	\centering
	\caption{Il diagramma delle transizioni di stato.}
\end{figure}\newline
\textbf{TIME\_WAIT} è lo stato finale in cui un'entità che esegue la
chiusura attiva si trova prima della chiusura definitiva della connessione. Vi resta per due volte la MSL (Maximum Segment Lifetime). \textbf{Garantisce una terminazione affidabile della connessione in caso di perdita dell'ultimo ACK e consente l'eliminazione dalla rete dei segmenti duplicati}.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/ASF_halfclose.png}
	\centering
	\caption{Il diagramma delle transizioni di stato con chiusura four-way halfclose.}
\end{figure}
Riportiamo di seguito i \textbf{significati degli stati}.
\begin{table}[h!]
	\begin{center}
		\label{tab:table1}
		\begin{tabular}{l|c|c}
			\textbf{Stato} & \textbf{Significato}                            \\
			\hline
			LISTEN         & server in attesa di SYN                         \\
			SYN-SENT       & SYN inviato e attesa ACK                        \\
			SYN-RECEIVED   & SYN e ACK inviati e attesa di ACK               \\
			ESTABLISHED    & connessione aperta                              \\
			FIN-WAIT-1     & primo FIN inviato attesa di ACK                 \\
			FIN-WAIT-2     & ricevuto ACK primo FIN attesa di secondo FIN    \\
			CLOSE-WAIT     & ricevuto primo FIN e ACK inviato                \\
			TIME-WAIT      & ricevuto secondo FIN e ACK inviato, attesa 2MSL \\
			CLOSING        & attesa di ACK chiusura                          \\
			LAST-ACK       & secondo FIN inviato attesa di ACK               \\
			CLOSED         & assenza di connessione                          \\
		\end{tabular}
	\end{center}
\end{table}
\subsubsection{Controllo del flusso}
Descriviamo il \textbf{ciclo di vita dei dati} scambiati all'interno della comunicazione TCP\@. I dati sono:
\begin{enumerate}
	\item \textbf{Generati} dal processo applicativo mittente.
	\item Consegnati al \textbf{TCP mittente}.
	\item Consegnati al \textbf{TCP destinatario}.
	\item \textbf{Consumati} dal processo applicativo destinatario.
\end{enumerate}
Il \textbf{controllo del flusso} è gestito con il seguente meccanismo: il \textbf{TCP destinatario} invia un feedback al \textbf{TCP mittente} che a sua volta invia un feedback al \textbf{processo applicativo mittente}. Quando la finestra del TCP mittente è \textbf{piena} i dati, provenienti dal processo, vengono \textbf{rifiutati}.

\pagebreak

Il \textbf{protocollo TCP} prevede due finestre, una di \textbf{ricezione} e una di \textbf{trasmissione}, per ognuna delle due direzioni di comunicazione, in totale sono quindi presenti \textbf{4 finestre}. Ricordiamo che TCP instaura \textbf{una sola connessione}. La \textbf{dimensione della finestra di trasmissione} è \textit{\textbf{inizialmente}} determinata all'apertura della connessione. Si \textbf{apre} quando la dimensione della finestra di ricezione segnalata dal TCP destinatario lo consente e si \textbf{chiude} quando viene confermata la ricezione dei byte inviati. \textbf{Apertura, chiusura e ridimensionamento sono controllate dal TCP destinatario}.
\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/TCP_Window.png}
	\centering
	\caption{La finestra di trasmissione o di invio TCP.}
\end{figure}\newline
Invece la \textbf{finestra di ricezione} si \textbf{chiude} quando giungono altri byte dal \textbf{TCP mittente} e si \textbf{apre} quando il processo applicativo destinatario richiede altri byte.
\begin{figure}[!h]
	\includegraphics[scale=0.54]{Immagini/Rc_window.png}
	\centering
	\caption{La finestra di ricezione TCP\@. Ipotizzeremo che non si riduca mai.}
\end{figure}

\pagebreak

Alleghiamo di seguito un'immagine in grado di spiegare efficacemente ciò che succede in uno scenario \textbf{dinamico}.
\begin{figure}[!h]
	\includegraphics[scale=0.65]{Immagini/Dyn_win.png}
	\centering
	\caption{Il controllo di flusso in una ipotetica connessione TCP unidirezionale.}
\end{figure}
\begin{center}
	\fbox{\textbf{rwindow = RecBuff - (LastByteReceived - LastByteRead)}}
\end{center}
Il \textbf{mittente} si assicura che:
\begin{center}
	\fbox{\textbf{LastByteSent - LastByteAcked $<$ rwindow}}
\end{center}
Ovvero che la quantità di dati trasmessi e non ancora riscontrati sia \textbf{minore} della \textbf{finestra di ricezione}.\newline
\textbf{\underline{N.B.}} \textbf{rwindow può essere uguale a 0}, qualora ad esempio il TCP destinatario non volesse ricevere dai dati per un certo periodo di tempo. Il mittente in questo caso \textbf{non} riduce realmente la dimensione della sua finestra ma continua a mandare \textbf{segmenti sonda} di 1 byte per ricevere l’\textbf{aggiornamento} sulla dimensione di \textbf{rwindow}. Questa tecnica si definisce \textbf{probing} ed è usata per \textbf{prevenire
	lo stallo}.

\pagebreak

\subsubsection{Controllo degli errori}
Come è ormai più che noto \textbf{TCP è un protocollo di trasporto affidabile} e garantisce al processo applicativo che i dati vengano consegnati in \textbf{sequenza}, \textbf{senza errori}, \textbf{smarrimenti o duplicazioni}.\newline
Gli strumenti utilizzati da TCP per individuare gli errori di trasmissione sono \textbf{tre}:
\begin{enumerate}
	\item \textbf{La checksum}: ciascun \textbf{segmento TCP} contiene un campo \textbf{checksum} di 16 bit
	      \textbf{obbligatorio} e utilizzato per identificare i \textbf{segmenti corrotti}. Se un segmento viene rilevato essere tale viene \textbf{scartato} e \textbf{considerato smarrito}.
	\item \textbf{I messaggi di riscontro o ACK}: TCP usa gli ACK per riscontrare la \textbf{ricezione dei segmenti} che contengono un \textbf{numero di sequenza}, possono essere segmenti \textbf{dati} o di \textbf{controllo}. I segmenti ACK \textbf{non} usano numeri di sequenza e perciò \textbf{non} vengono \textbf{riscontrati}. Nella sua \textbf{implementazione originale} TCP è stato progettato per riscontrare i segmenti in modo \textbf{cumulativo}, ovvero notificando il numero del byte che si attende e ignorando i segmenti duplicati e fuori sequenza. Nelle \textbf{versioni} più \textbf{recenti} è implementato il \textbf{selective ack o SACK} il quale prevede che i \textbf{pacchetti} ricevuti \textbf{fuori sequenza} vengano ugualmente \textbf{memorizzati} e inoltre sia presente un riscontro per i pacchetti fuori sequenza e quelli duplicati contenuto nel campo OPTIONS. \textbf{Un'entità TCP genera riscontri quando}:
	      \begin{itemize}
		      \item \textbf{Invia un segmento dati} a un'altra entità e \textbf{contemporaneamente invia l'ACK} contenente numero del prossimo byte che si aspetta di ricevere, così da \textbf{ridurre il traffico}. Se destinatario \textbf{non} ha dati da inviare e riceve un segmento in ordine ritarda l'invio dell'ACK di \textbf{500ms} a meno che non riceva un nuovo segmento sempre per una ragione di riduzione del traffico.
		      \item Vengono ricevuti \textbf{due segmenti nel giusto ordine e nessuno dei due è ancora stato riscontrato}. Viene inviato immediatamente un segmento ACK, dal destinatario al mittente, per \textbf{evitare la ritrasmissione inutile dei segmenti}.
		      \item Arriva un \textbf{segmento fuori sequenza} il destinatario invia immediatamente un ACK per \textbf{consentire la ritrasmissione rapida dei segmenti}.
		      \item \textbf{Arriva un segmento mancante o un segmento duplicato}.
	      \end{itemize}
	\item \textbf{I timeout}: il \textbf{TCP mittente} inizializza un \textbf{timer di ritrasmissione}, o \textbf{RTO} per ogni segmento inviato. Il \textbf{primo} segmento inviato e in attesa di riscontro, che ricordiamo essere memorizzato nel buffer del TCP mittente, allo scadere del timer, \textbf{è ritrasmesso}.
\end{enumerate}

\pagebreak

\textbf{\underline{N.B.}} Un segmento viene ritrasmesso o alla \textbf{scadenza del timer} o quando vengono ricevuti \textbf{tre ACK duplicati} per quello precedente, questa funzione è chiamata \textbf{ritrasmissione veloce}.
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Fast_retrsm.png}
	\centering
	\caption{Un'esempio di scambio di dati tra due entità con un esempio di ritrasmissione veloce. Si supponga in uso una versione moderna di TCP dove i pacchetti fuori sequenza vengono memorizzati e non scartati.}
\end{figure}\newline
L'\textbf{RTO} ha un \textbf{valore} \textbf{dinamico} calcolato in base al tempo di andata e di ritorno dei segmenti trasmessi detto anche \textbf{RTT} o \textbf{Round} \textbf{Trip} \textbf{Time}.\newline\newline
Presentiamo ora una collezione di vari scenari di operatività del protocollo TCP.
\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Norm_op.png}
	\centering
	\caption{Uno scenario di operatività normale. Notare, come descritto in precedenza, il ritardo nella trasmissione dell'ACK dovuto alla ricezione di un solo segmento.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Loss_op.png}
	\centering
	\caption{Uno scenario di perdita di un segmento. Notare, come descritto in precedenza, che alla ricezione del secondo segmento in ordine, alla ricezione del terzo segmento in \textit{disordine} e alla ricezione del quarto segmento mancante viene immediatamente inviato un ACK.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/ACK_lost.png}
	\centering
	\caption{Uno scenario di perdita di un ACK\@. Notare come lo scenario venga ripristinato automaticamente in una condizione di normalità dalla spedizione dell'ACK successivo.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/ACK_retr.png}
	\centering
	\caption{Uno scenario di perdita di un ACK\@. Stavolta si torna alla normalità tramite la ricezione di un segmento duplicato e il conseguente ed immediato invio dell'ACK da parte del server..}
\end{figure}
\textbf{\underline{N.B.}} Lo \textbf{smarrimento di un riscontro può provocare lo stallo} ed è nel caso in cui, a seguito della ricezione da parte del TCP mittente di un segmento ACK con  il campo \textbf{rwnd settato a 0}, si perda il successivo ACK con il campo rwnd non nullo. Il \textbf{TCP destinatario} supporrà che il TCP mittente lo abbia ricevuto e \textbf{resterà in attesa} dei dati.

\pagebreak

Riassumiamo gli argomenti fin qui trattati presentando degli \textbf{ASF} per il \textbf{TCP mittente} e il \textbf{TCP destinatario}.
\begin{figure}[!h]
	\includegraphics[scale=0.47]{Immagini/ASF_tcpm.png}
	\centering
	\caption{ASF del TCP mittente.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.47]{Immagini/ASF_tcpd.png}
	\centering
	\caption{ASF del TCP destinatario.}
\end{figure}

\pagebreak

\begin{flushleft}
	\textit{Come si calcola l'RTO o Retrasmission Time-Out?}
\end{flushleft}
\textbf{TCP} fa partire un \textbf{timer} quando invia un segmento all'\textbf{inizio} della coda di invio, quando il \textbf{timer scade} TCP \textbf{rispedisce} il \textbf{primo} segmento all'inizio della coda e fa ripartire il timer. Per definire l'\textbf{RTO} bisogna prima definire l'\textbf{RTT} o \textbf{Round Trip Timer}. Infatti \textbf{l'RTO deve essere maggiore del'RTT}. Ricordiamo che l'RTT è il \textbf{tempo trascorso da quando si invia un segmento a quando ne si riceve il riscontro}. Calcolare l'RTT è un procedimento abbastanza complicato a causa della sua \textbf{variabilità} nel percorso.\newline
\textbf{Inizialmente} l'RTT vale 0 e l'RTO è \textbf{preimpostato}. Dopo la prima misurazione, ottenuta inviando un segmento e contando il tempo che passa tra l'invio e il riscontro, avremo un $RTT_{ESTIMATED}$. \newline\newline
\textbf{\underline{N.B.}} non si ha \textbf{nessuna} garanzia che il prossimo segmento impiegherà lo \textbf{stesso} tempo per essere inviato e riscontrato!\newline\newline
Perciò dalla \textbf{seconda misurazione} in avanti RTT viene calcolato utilizzando l'RTT dei segmenti precedenti con la seguente formula:
\begin{equation}
	RTT_{ESTIMATED} = (1 – \alpha) \times RTT_{ESTIMATED} + \alpha \times RTT_{SAMPLE}
\end{equation}
L' $RTT_{SAMPLE}$ è riferito all'\textbf{ultimo} segmento inviato. \textbf{$RTT_{ESTIMATED}$ è quindi la combinazione dei suoi precedenti valori e il nuovo valore $RTT_{SAMPLE}$}. Il valore di $\alpha$ viene posto a 1/8 in modo da rendere via via \textbf{meno importanti gli RTT dei pacchetti più vecchi}. Si ha quindi:
\begin{equation}
	RTT_{ESTIMATED} = 0,875 \times RTT_{ESTIMATED} + 0,125 \times RTT_{SAMPLE}
\end{equation}
Oltre al valore RTT stimato \textbf{è necessaria anche una stima della} sua \textbf{variabilità} data dalla \textbf{seguente formula}:
\begin{equation}
	RTT_{DEV} = (1 - b) \times RTT_{DEV} + b \times \mid RTT_{SAMPLE} - RTT_{ESTIMATED} \mid
\end{equation}
\begin{flushleft}
	Inizialmente $RTT_{DEV} = \frac{RTT_{sample}}{2}$.
\end{flushleft}
$RTT_{DEV}$ rappresenta una \textbf{stima di quanto $RTT_{SAMPLE}$ si discosta da $RTT_{ESTIMATED}$}. Il valore di b viene posto a 1/4. Una volta ottenuti questi valori, \textbf{il timeout viene normalmente calcolato come}:
\begin{equation}
	RTO = RTT_{ESTIMATED} + 4 \times RTT_{DEV}
\end{equation}
In altre parole si prende il valore più recente di $RTT_{ESTIMATED}$ e gli si somma \textbf{quattro volte} $RTT_{DEV}$, solitamente piccolo, per \textbf{equilibrarlo}.

\pagebreak

\subsubsection{Controllo della congestione}
Ricordiamo che il fenomeno della \textbf{congestione} è originato dal tentativo delle
sorgenti di \textbf{richiedere più banda di quella disponibile} sul percorso fino alle destinazione.\newline
Il \textbf{traffico eccessivo} nella rete \textbf{può provocare}:
\begin{itemize}
	\item \textbf{Lunghi ritardi} causati dall'accodamento dei pacchetti nei buffer dei router.
	\item \textbf{Perdita di pacchetti} causata dall'overflow nei buffer dei router.
\end{itemize}
Il \textbf{protocollo TCP} utilizza la \textbf{finestra di congestione} come principale strategia per evitare la congestione.\newline\newline
\textbf{TCP} usa le \textbf{finestre di ricezione} e le \textbf{finestre di trasmissione} per far sì che i due rispettivi buffer non vengano sovraccaricati. Fondamentalmente però la congestione è un \textbf{problema del livello di rete} e sebbene il protocollo IP non lo gestisca, la soluzione delle due finestre assicura l'assenza di congestione \textbf{agli estremi} della comunicazione ma \textbf{non nel mezzo}. La politica di rispedizione dei segmenti persi di TCP in combinazione con la congestione di rete potrebbe portare al \textbf{collasso dell'intera rete}.
\textbf{TCP} non può quindi ignorare la congestione della rete ma non può nemmeno essere troppo conservativo più di quello che è già nell'inoltrare i segmenti. Si utilizza perciò una \textbf{seconda variabile} chiamata \textbf{cwnd} o \textbf{congestion window} il cui valore dipende dal \textbf{livello di congestione della rete}. Con l'aggiunta di questa seconda variabile il valore della finestra d'invio è determinato anche dalla congestione presente in rete.
\begin{center}
	\textbf{Dimensione della finestra = min(rwnd,cwnd)}
\end{center}
\begin{flushleft}
	\textit{Ma come si determina il valore di cwnd?}
\end{flushleft}
Prima di rispondere a questa domanda è bene spiegare \textbf{come fa il protocollo TCP ad accorgersi della presenza di congestione sulla rete}.
Il \textbf{TCP mittente} interpreta come sinonimi di congestione:
\begin{enumerate}
	\item Il \textbf{timeout}.
	\item La ricezione di \textbf{tre riscontri duplicati}.
\end{enumerate}
Il secondo caso è \textbf{probabilmente meno critico del primo} poiché significa che un segmento è stato smarrito ma tre sono stati ricevuti. Può indicare o che la \textbf{rete è al limite della congestione o vi che è appena uscita}. L'\textbf{assenza} di una ricezione rapida e regolare dei riscontri è invece \textbf{evidenziata} dalla scadenza del \textbf{timeout}.

\pagebreak

La strategia principale usata da TCP per controllare la congestione prevede \textbf{tre fasi}:
\begin{enumerate}
	\item \textbf{Slow Start}.
	\item \textbf{Congestion Avoidance}.
	\item \textbf{Fast Recovery}.
\end{enumerate}
A ogni fase corrisponde un algoritmo diverso.
\begin{itemize}
	\item \textbf{Slow Start}: si basa sull'inizializzare la dimensione della finestra di congestione rendendola pari a quella della \textbf{MSS} o \textbf{Maximum Segment Size}. Aumentandola poi di MSS ogni volta che \textbf{un} segmento viene riscontrato. La MSS è stabilita all'inizio della connessione. Così facendo l'algoritmo parte lentamente ma procede con velocità via via crescente. La dimensione di cwnd nella fase di \textbf{slow start} può essere espressa come $2^{n}$ dove n sono i \textbf{riscontri ricevuti}. \textbf{Se due segmenti vengono confermati con lo stesso riscontro cwnd aumenta solo di 1}. La crescita è comunque \textbf{esponenziale} nell'unità di tempo RTT, ma di esponente diverso. La fase continua \textbf{fino} al raggiungimento da parte di cwnd di una soglia chiamata \textbf{ssthresh} o \textbf{slow start threshold}, mantenuta dal \textbf{mittente}. Al raggiungimento di questa soglia si entra nella fase di \textbf{congestion avoidance}.
	\item \textbf{Congestion Avoidance}: una volta che \textbf{cwnd} ha raggiunto una dimensione \textbf{relativamente} grande, per evitare che la crescita esponenziale finisca per causare problemi di congestione, \textbf{il protocollo TCP} usa un altro algoritmo che incrementa in modo \textbf{lineare} anziché \textbf{esponenziale} il valore di cwnd. La fase di \textbf{congestion avoidance} prevede che ogni volta che \textbf{l'intera finestra di ricezione viene riscontrata} la sua dimensione aumenti \textbf{di un'unità}.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.35]{Immagini/CA_tcp.png}
		      \centering
		      \caption{In figura la crescita della cwnd nella fase di congestion avoidance.}
	      \end{figure}\newline

	      \pagebreak

	\item La terza fase chiamata \textbf{Fast Recovery} è \textbf{opzionale} in TCP\@. La \textbf{versione originale non ne faceva uso}. Inizia quando arrivano \textbf{tre riscontri duplicati} interpretati come inizio di leggera congestione della rete. Aumenta la dimensione di cwnd in modo \textbf{lineare}, incrementandola di un'unità ogni volta che riceve \textbf{due riscontri duplicati}.
\end{itemize}
Analizziamo ora come, attraverso l'affermarsi di modelli sempre più recenti del protocollo TCP siano \textbf{cambiate le modalità di transizione da una fase all'altra}.
La \textbf{prima versione di TCP} chiamata \textbf{TCP Tahoe} utilizzava \textbf{solo le prime due fasi}. Se durante la fase di \textbf{slow start} rileva la presenza di congestione allora \textbf{resetta} la dimensione di \textbf{cwnd} a 1 e \textbf{assegna} a \textbf{ssthresh} il vecchio valore di \textbf{cwnd dimezzato}. Se non la rileva entro il raggiungimento di ssthresh passa alla fase di \textbf{congestion avoidance}.
In questa fase \textbf{non vi è un limite sulla dimensione di rwnd} e se non è rilevata congestione \textbf{aumenta linearmente fino alla chiusura della connessione}, se invece viene rilevata si riparte dalla fase di slow start con cwnd pari a 1 e ssthresh pari al vecchio valore di \textbf{cwnd dimezzato}.
\begin{figure}[!h]
	\includegraphics[scale=0.33]{Immagini/Taho.png}
	\centering
	\caption{TCP Tahoe rappresentato come ASF.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.23]{Immagini/Taho2.png}
	\centering
	\caption{In figura l'evoluzione della dimensione di cwnd con TCP Tahoe.}
\end{figure}

\pagebreak

In una versione più recente del protocollo TCP chiamata \textbf{TCP Reno}, è prevista anche la terza fase di \textbf{fast recovery}. TCP Reno inoltre \textbf{tratta i due sintomi della congestione in modo differente}. La mancata ricezione di un riscontro e il conseguente \textbf{timeout} portano TCP Reno a tornare nella fase di \textbf{slow start }, mentre la ricezione di \textbf{tre ACK duplicati}, sia che avvenga in \textbf{slowstart che in congestion avoidance}, portano TCP Reno ad \textbf{assegnare} a \textbf{ssthresh} il valore di \textbf{cwnd dimezzato}, a \textbf{cwnd il nuovo valore di ssthresh aumentato di tre unità} e a spostarsi nella fase di \textbf{fast recovery}, che può essere visto come uno \textbf{stato intermedio tra slow start e congestion avoidance}. In \textbf{fast recovery cwnd continua a crescere esponenzialmente}, se arriva un \textbf{ACK non duplicato} si giunge nello stato di \textbf{congestion avoidance} se invece giunge un altro \textbf{ACK duplicato} rimane in \textbf{fast recovery} e si \textbf{aumenta la cwnd di un'unità}, infine se scatta un timeout si torna in \textbf{slow start} con le modalità descritte per TCP Tahoe.
\begin{figure}[!h]
	\includegraphics[scale=0.33]{Immagini/Reno.png}
	\centering
	\caption{TCP Reno rappresentato come ASF.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.31]{Immagini/Reno2.png}
	\centering
	\caption{In figura l'evoluzione della dimensione di cwnd con TCP Reno.}
\end{figure}

\pagebreak

\subsubsection{Throughput}
Il \textbf{throughput di TCP dipende dal comportamento della finestra di congestione} e non è quindi costante, se riportato su un grafico avrebbe un profilo simile a quello dei denti di una sega detto anche \textbf{AIMD} o \textbf{addictive increase multiplicative decrease}. Ciò è dovuto a come è determinata, dopo la prima fase di \textbf{slow start}, la dimensione della finestra di congestione. Se i denti fossero tutti uguali il throughput sarebbe uguale a:\[\frac{\frac{\mid max + min \mid }{2}}{RTT}\]
Sapendo che ogni rilevazione di congestion cwnd è impostato alla metà del suo valore precedente, \textbf{il throughput può essere calcolato come:}
\[\frac{ 0.75 \times W_{max}}{RTT}\]
\textbf{Dove $W_{MAX}$ è la dimensione media di cwnd in presenza di congestione}.
\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Cwnd_ex.png}
	\centering
	\caption{In figura il profilo AIMD.}
\end{figure}\newline
Proviamo a \textbf{calcolare} il \textbf{throughput} avendo come dati il \textbf{grafico}, l' \textbf{MSS} pari a 10 KB (kilobyte) e un \textbf{RTT} di 100 ms. Otteniamo
\[W_{MAX} = \frac{10 + 12 + 10 + 8 + 8}{5} = 9.6 \ MSS\]
da cui
\[throughput =  \frac{0,75 \times W_{MAX}}{RTT}  = \frac{0,75 \times (96 \times 8)_{Kbit}}{100_{ms}} = 5,76 Mbit/s\]

\pagebreak

\subsection{Esercizi}
\begin{enumerate}
	\item L’utente \begin{center}
		      \textbf{mickey@disney.com}
	      \end{center} invia dal suo PC una email a \begin{center}
		      \textbf{donald@disney.com}
	      \end{center}. Indicare la sequenza di comandi SMTP inviati e ricevuti dal PC di \textbf{mickey@disney.com} se:
	      \begin{enumerate}
		      \item Il mailserver di disney.com non è raggiungibile.
		      \item Il mailserver di disney.com è raggiungibile.
	      \end{enumerate}
	      \textbf{Soluzione}:
	      \begin{enumerate}
		      \item Il PC di mickey@disney.com non riesce a stabilire una connessione TCP con il mailserver di disney.com, quindi \textbf{nessun} messaggio SMTP viene inviato o ricevuto.
		      \item  Il PC di mickey@disney.com stabilisce una connessione TCP con il mailserver di
		            disney.com su cui scambia i seguenti comandi SMTP:\newline
		            R: 220 service ready \newline
		            I: HELO …\newline
		            R: 250 OK\newline
		            I: MAIL FROM: mickey@disney.com\newline
		            R: 250 OK \newline
		            I: RCPT TO: donnald@disney.com\newline
		            R: 250 OK \newline
		            I: DATA\newline
		            I: …\newline
		            I: …\newline
		            R: 250 OK\newline
		            I: QUIT\newline
		            R: 221 service closed\newline
	      \end{enumerate}
	      È bene ricordarsi che il corpo del messaggio termina \textbf{sempre} con ritorno a capo e fine linea.

	      \begin{flushleft}
		      Per eventuali chiarimenti è consigliato il ripasso del capitolo sull'\hyperref[sec:SMTP]{\textbf{SMTP}}.
	      \end{flushleft}

	      \pagebreak

	\item Un host deve risolvere il nome simbolico:
	      \begin{center}
		      \textbf{host.engineering.vanderbilt.edu}
	      \end{center} il cui indirizzo IP \textbf{non} è noto al suo resolver (i.e.\ servizio DNS dell’host). Supponendo che la gerarchia dei name server abbia \textbf{4} livelli, indicare, giustificando la risposta, il numero di messaggi DNS che, nel caso peggiore, circoleranno in Internet per risolvere tale nome simbolico, se:
	      \begin{enumerate}
		      \item Si utilizza ad ogni livello una risoluzione ricorsiva.
		      \item Si utilizza ad ogni livello una risoluzione iterativa.
	      \end{enumerate}
	      \textbf{Soluzione}:
	      \begin{enumerate}
		      \item  Bisogna	percorrere tutto l'albero dei name server, dal name server locale fino ad un root server, e poi da questo al name server autoritativo, che nel caso peggiore è il name server locale per engineering.vanderbilt.edu, per poi tornare indietro: in totale sono $4 + 4$ messaggi a cui vanno aggiunti i 2 messaggi dal resolver al name server locale del client, e viceversa: quindi \textbf{10 messaggi}.
		            \begin{figure}[!h]
			            \includegraphics[scale=0.25]{Immagini/Es1_1.png}
			            \centering
		            \end{figure}\newline
		      \item Anche ora i messaggi saranno \textbf{10}, perchè i name server coinvolti saranno 4, nel caso pessimo, più i 2 messaggi dal resolver al name server locale del client, e viceversa.
		            \begin{figure}[!h]
			            \includegraphics[scale=0.25]{Immagini/Es1_2.png}
			            \centering
		            \end{figure}\newline
	      \end{enumerate}

	      \pagebreak

	\item Un client C chiede la pagina web
	      \textbf{\begin{center}
			      www.acme.com/home/products.html
		      \end{center}} al server B di
	      \textbf{\begin{center}
			      www.acme.com
		      \end{center}} con una GET che è contenuta in un segmento
	      TCP il cui payload (campo Dati) è lungo X byte. Indicare, giustificando la risposta, i valori dei campi sequence number, ack number, e dei flags ACK ed SYN e lunghezza del
	      campo DATA, in ciascuno dei segmenti che C e B si scambiano per aprire la connessione nell’ipotesi che l’ack finale dell’apertura della connessione sia inviato in piggybacking
	      assieme alla GET\@. Si supponga che in B ed in C rwnd sia molto grande, che
	      non scada alcun timeout, che non ci siano errori di trasmissione, che nessun segmento vada perduto, e che il numero di sequenza iniziale di C sia 1111 e quello di B sia 2222.
	      \begin{flushleft}
		      \textbf{Soluzione}:
	      \end{flushleft}
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Es2.png}
		      \centering
	      \end{figure}
	      Si ricorda che per \textbf{piggybacking} si indica la tecnica mediante la quale l'invio dell'ACK è unito all'invio dei dati. La tecnica migliora l'efficienza dei protocolli bidirezionali.

	      \pagebreak

	\item Un client C ha stabilito una connessione TCP con un server web S per
	      scaricare una pagina web che consiste di tre oggetti. Al tempo t, subito
	      dopo avere inviato la richiesta per il terzo oggetto, l’host di C invia a S
	      un segmento con il flag FIN a true.
	      Indicare, giustificando la risposta,  il tempo minimo necessario al TCP
	      di C per chiudere definitivamente la connessione supponendo che:
	      \begin{itemize}
		      \item La dimensione del terzo oggetto sia 1,5 MSS.
		      \item RTT sia costantemente 700 msec e il maximum segment lifetime sia
		            1100 msec.
		      \item Tutti i segmenti vengano ricevuti corretti ed in ordine, e che il valore
		            di cwnd del TCP di S sia 1MSS quando esso riceve il FIN inviato
		            dall’host di C.
		            Trascurare i tempi di preparazione e di trasmissione dei segmenti e
		            assumere che S abbia già a disposizione tutti i dati da inviare.
	      \end{itemize}
	      \textbf{Soluzione:}
	      \begin{center}
		      \fbox{\LARGE $3 RTT + 2 MSL = 4300$msec}
	      \end{center}
	      Il TCP di C riceve al tempo t + RTT il riscontro S1 del segmento FIN da lui
	      inviato. Se S1 trasporta in piggybacking il primo MSS dei dati del terzo oggetto e il TCP di C invierà un riscontro C2 per tali dati, quindi S potrà inviare l’ultima porzione di dati e attenderne il riscontro, infine il TCP
	      di S invierà un segmento con il flag FIN a true. Il TCP di C invierà un riscontro del FIN e considererà chiusa la connessione
	      dopo avere atteso 2MSL, ovvero al tempo $t + 3 RTT + 2 MSL = t + 4300$ msec.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Es3.png}
		      \centering
	      \end{figure}

	      \pagebreak

	\item Si descriva il meccanismo di controllo di flusso in
	      TCP.
	      \begin{flushleft}
		      \textbf{Una possibile soluzione}:
	      \end{flushleft}
	      Con controllo di flusso si intende  la capacità del mittente di evitare la possibilità di saturare il buffer del ricevitore. Infatti, a livello TCP ogni host imposta un buffer di invio e uno di ricezione. Il processo applicativo
	      destinatario legge i dati dal buffer di ricezione (non necessariamente nell'istante in cui arrivano). Il controllo di flusso ha lo scopo di regolare la frequenza di invio del mittente in base alla frequenza di lettura
	      dell'applicazione ricevente allo scopo di non saturare il buffer del ricevente.
	      TCP implementa questa funzione tramite una variabile detta \textbf{receive
		      window} mantenuta nel mittente: questa variabile fornisce un'idea di
	      quanto spazio è ancora a disposizione nel buffer del ricevitore. Tale valore
	      è comunicato nel \textbf{campo window} dell'header TCP dall’host destinatario.
	      \begin{itemize}
		      \item Il valore di \textbf{receive window} è pari a: \newline
		            rwnd = RcvBuffer - ( LastByteReceived - LastByteRead)
		      \item L'host destinatario comunica la dimensione di RcvWindow al mittente.
		      \item Il mittente si assicura che $LastByteSent - LastByteAcked < rwnd$ pari ovvero alla quantità di dati trasmessi e non ancora riscontrati.
	      \end{itemize}
	      Nelle situazioni in cui il buffer risulta pieno (rwnd = 0), il mittente
	      continua a mandare \textbf{segmenti sonda} di 1 byte per ricevere
	      l’aggiornamento sulla dimensione di rwnd ed evitare lo stallo.
	      \begin{flushleft}
		      Per approfondire l'argomento recarsi al \hyperref[sec:TCP]{\textbf{capitolo sul TCP}}.
	      \end{flushleft}
	\item Due host H1 e H2 comunicano tramite un canale che attraversa tre router R1, R2 e R3 e 4 link di capacità C1, C2, C3 e C4, rispettivamente come mostrato in figura.
	      La comunicazione avviene tramite commutazione di pacchetto con trasmissione di
	      tipo store and forward. Assumendo che il ritardo di propagazione sia trascurabile, che i ritardi di accodamento nei router R1, R2 e R3 sia rispettivamente a1, a2 e a3, e che il ritardo di elaborazione nei tre router sia uguale a 1 ms, dire quanto tempo è necessario per la trasmissione da H1 a H2 di un pacchetto di dimensione L nel
	      seguente caso:
	      \begin{itemize}
		      \item L = 10 KBytes.
		      \item C1=C2=C3=C4 = 2 Mbps.
		      \item a1=a2=a3 = 0,01 s.
	      \end{itemize}

	      \pagebreak

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Es4.png}
		      \centering
	      \end{figure}
	      \begin{flushleft}
		      \textbf{Soluzione}:
		      Il ritardo introdotto da ogni router è dato dalla somma tra: ritardo di
		      trasmissione, ritardo di propagazione, ritardo di accodamento e tempo di
		      elaborazione. In particolare:
		      \begin{itemize}
			      \item il tempo di trasmissione di H1 è pari a $\frac{L}{C1}$ = 40 ms.
			      \item il tempo di trasmissione di R1 è pari a $\frac{L}{C2}$ = 40 ms.
			      \item il tempo di trasmissione di R2 è pari a $\frac{L}{C3}$ = 40 ms.
			      \item il tempo di trasmissione di R3 è pari a $\frac{L}{C4}$ = 40 ms.
		      \end{itemize}
		      Quindi il ritardo introdotto dai router è:
		      ritardo introdotto dai router R1,R2,R3 $= 40 + 10 + 1 = 51$ ms.\newline
		      Il ritardo dovuto alla trasmissione da H1 è pari a $\frac{L}{R} = 40$ ms.
		      Quindi il tempo complessivo per la trasmissione del pacchetto da H1 a H2
		      è: \begin{center}
			      \fbox{\LARGE$51 \times 3 + 40 = 193$ ms}
		      \end{center}
	      \end{flushleft}
	\item Tizio manda dal suo account di email
	      \begin{center}
		      \textbf{tizio@libero.it}
	      \end{center}
	      un messaggio di posta elettronica con testo di 256 caratteri a Caio
	      \begin{center}
		      \textbf{caio@occupato.it}
	      \end{center}
	      \begin{enumerate}
		      \item Specificare il contenuto dei primi due messaggi
		            TCP inviati dal mailserver di libero.it, ms.libero.it,
		            per ricevere tale messaggio.
		      \item Specificare, per ciascun segmento, payload,
		            numero di sequenza, ack number, flags posti ad 1,
		            porta origine e porta destinazione.
	      \end{enumerate}
	      \textbf{Soluzione}:
	      \begin{enumerate}
		      \item Il primo segmento avrà il payload vuoto e il payload del secondo conterrà 220 service ready.
		      \item Il primo segmento sarà SYNACK, e quindi: come già detto, payload vuoto, flags SYN e ACK ad 1, numero sequenza Z, ack number Y, \textbf{porta mittente 25}, porta destinazione effimera. Il secondo segmento conterrà come payload 220 service ready, nessun flag ad 1, numero sequenza Z+1, ack number Y, porta	mittente 25, porta destinazione effimera.
	      \end{enumerate}

	      \pagebreak

	\item Dire in quali delle seguenti circostanze il TCP cambia la dimensione della
	      finestra di congestione \textbf{cwnd}, e, nel caso, come viene ricalcolata.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Es5_1.png}
		      \centering
	      \end{figure}
	      \begin{flushleft}
		      \textbf{Soluzione}:
	      \end{flushleft}
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Es5_2.png}
		      \centering
	      \end{figure}
	\item Si consideri il seguente scenario TCP in cui, per semplicità, non sono
	      indicati i segmenti inviati o re-inviati dal sender TCP al receiver TCP, che si
	      suppone essere quelli necessari per avere i riscontri descritti di seguito.
	      \begin{itemize}
		      \item Al tempo t0 il TCP di un host A ha una connessione già stabilita, per la
		            quale ha 4 segmenti full sized in volo (inviati ma non riscontrati) e nessun
		            nuovo dato da spedire, il primo byte dei segmenti in volo è il byte Y,
		            ssthresh = 6.5 MSS, cwnd = 5 MSS\@. Inoltre, non ha ricevuto nessun riscontro
		            duplicato.
		      \item Tra il tempo t0 e il tempo t1 riceve 7 riscontri: i primi due non duplicati e
		            con acknumber uguale a Y + 1 MSS per il primo, e Y + 3 MSS per il secondo. I
		            seguenti 4 riscontri sono tutti duplicati, ed infine, al tempo t1, riceve un
		            settimo riscontro con acknumber uguale a Y + 4 MSS.
	      \end{itemize}
	      Si supponga che non scatti alcun timeout tra t0 e t1. Indicare, per ciascun riscontro ricevuto, lo stato del TCP e i valori di ssthresh e cwnd, giustificando la risposta.

	      \pagebreak

	      \textbf{Soluzione}:
	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Es6.png}
		      \centering
	      \end{figure}
	\item Descrivere in modo dettagliato e mediante uno \textbf{pseudocodice} le azioni svolte da un \textbf{destinatario TCP} per realizzare il controllo di flusso. Si assuma che ogni segmento ricevuto dal destinatario contenga anche lo pseudoheader (lunghezza segmento TCP). Inoltre, si supponga che la chiusura della connessione venga
	      fatta dal mittente e che i segmenti di chiusura non contengano dati in piggybacking. Non occorre realizzare la parte iniziale delle azioni svolte (quindi le inizializzazioni delle variabili e l’apertura della connessione).
	      Infine, si supponga che si invii un riscontro appropriato per ogni segmento ricevuto, e che il destinatario non debba inviare dati al mittente. Inoltre, per semplicità, si specifichino solamente i campi dell’header del riscontro relativi al controllo del flusso e al riscontro. Non occorre realizzare le interazioni con il livello
	      applicativo (processo che legge dal buffer), ma solamente quelle con il mittente TCP\@.
	      Si hanno a disposizione le seguenti procedure:
	      \begin{flushleft}
		      \texttt{receive(segm)} //\textit{per ricevere il segmento segm dal livello di rete}\newline
		      \texttt{OK(segm)} //\textit{restituisce true solo se segm è corretto}\newline
		      \texttt{nuovo(segm.x)} //\textit{vettore di booleani che vale true se dal campo x di segm si deduce che i dati contenuti in segm non sono doppioni (specificare x nella soluzione)}\newline
		      \texttt{insert(segm.y,finestra)} //\textit{per inserire segm.y nel buffer di ricezione nella posizione corretta}\newline
		      \texttt{calcolacknum(segm)} //\textit{restituisce il numero di riscontro per il riscontro associato a segm}\newline
		      \texttt{send(risp)} //\textit{per inviare risp al mittente}\newline
	      \end{flushleft}
	      Descrivere il contenuto o la funzionalità delle variabili e delle altre funzioni o procedure eventualmente utilizzate.

	      \pagebreak

	      \begin{flushleft}
		      \textbf{Soluzione}:
		      \begin{lstlisting}[gobble=2,language=C,basicstyle=\footnotesize]
	finito = false;
	while (!finito) {
	receive(segm);
	finito = segm.FIN; 
		#controllare inizio della chiusura della conn.
		if (!finito) {
			#se segmento non corrotto
			if (OK(segm)) { 
				#se il segmento contiene nuovi dati
				if (nuovo(segm.seqnum)) { 
					#inserisco i dati nel buffer
					insert(segm.dati, finestra); 
					#nuovo valore di rwnd
					rwnd = rwnd - (segm.lungtotTCP - segm.HLEN); 
					#flag ack settato a true
					risposta.ACK = true; 
					risposta.ACKnum = calcolacknum(segm);
					risposta.rwnd = rwnd;
				}
 				#invia o il nuovo ack o ultimo ack inviato
				send(risposta); 
			}
		}
	}
	\end{lstlisting}
	      \end{flushleft}
	\item Discutere l'affermazione: \textit{poiché FTP e HTTP sono protocolli adatti a trasferire file, possono essere usati indifferentemente}.
	      \begin{flushleft}
		      \textbf{Soluzione possibile:}
	      \end{flushleft}
	      Esempio di risposta (schema per punti):
	      \begin{itemize}
		      \item Descrivere brevemente obiettivo HTTP e FTP.
		      \item Entrambi usano TCP (trasferimento affidabile dei dati),  elencare le differenze ai fini del trasferimento file.
	      \end{itemize}
	      e.g.\   \hyperref[sec:FTP]{\textbf{FTP}}
	      \begin{itemize}
		      \item connessione controllo, persistente, inizializzata dal client, porta 21. comandi in formato ASCII a 7 bit
		      \item connessione dati, inizializzata da server, porta 20, non persistente
		      \item  FTP è Stateful
		      \item Offre funzionalità aggiuntive rispetto a HTTP per la gestione di file e directory (list, retr, put).
	      \end{itemize}
	      e.g.\  \hyperref[sec:HTTP]{\textbf{HTTP}}
	      \begin{itemize}
		      \item Un'unica connessione per dati e comandi.
		      \item Interazione stateless.
	      \end{itemize}
\end{enumerate}

\pagebreak

\section{Lo strato di rete}
\begin{figure}[!h]
	\includegraphics[scale=0.2]{Immagini/Ip.png}
	\centering
	\caption{Lo strato di rete all'interno dello stack protocollare TCP/IP.}
\end{figure}
Nello stack protocollare TCP/IP \textbf{il livello rete} è collocato tra \textbf{il livello trasporto} e \textbf{il livello collegamento}, \textbf{offre} servizi al livello trasporto e ne \textbf{riceve} dal livello collegamento. Realizza una connessione logica fra host system
diversi facenti parte di reti eterogenee. Si occupa di:
\begin{itemize}
	\item \textbf{Suddividere i dati in pacchetti}, \textbf{frammentandoli} nel caso in cui il payload sia troppo grande per entrare in un singolo pacchetto.\\
	      \begin{figure}[!h]
		      \includegraphics[scale=0.2]{Immagini/Ip_p.png}
		      \centering
		      \caption{Un pacchetto IP.}
	      \end{figure}
	\item \textbf{Instradare i pacchetti} così ottenuti dall'host sorgente all'host destinazione. La vastità di Internet, infatti, fa sì che con ogni probabilità sia possibile scegliere \textbf{più di un percorso}. Il livello di rete deve trovare \textbf{il migliore} tra questi.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.3]{Immagini/Ip_instr.png}
		      \centering
		      \caption{Il processo di instradamento in una rete priva di connessione.}
	      \end{figure}
	\item \textbf{Inoltrare i pacchetti}, ovvero trasferire il pacchetto arrivato al router sull’\textbf{appropriato} collegamento di uscita.
	      \begin{figure}[!h]
		      \includegraphics[scale=0.25]{Immagini/Ip_table.png}
		      \centering
		      \caption{Il processo d'inoltro in una rete priva di connessione. La tabella d'inoltro è il risultato del processo di instradamento.}
	      \end{figure}
\end{itemize}
D'altro canto \textbf{il livello di rete non si occupa di}:
\begin{itemize}
	\item \textbf{Controllare gli errori nel payload dei pacchetti}; sebbene nel pacchetto sia presente un campo \textbf{checksum} la sua funzione è di rilevare errori \textbf{solo nell'intestazione}.
	      Inoltre i pacchetti del livello rete possono essere \textbf{frammentati} da ciascun router a cui giungono, un eventuale controllo degli errori sul payload sarebbe molto \textbf{inefficiente}.
	\item \textbf{Controllare il flusso}; il controllo di flusso è delegato del tutto agli strati superiori, in Internet il livello di rete non fornisce \textbf{pressoché} alcun meccanismo di controllo di flusso.
	\item \textbf{Controllare la congestione}; al livello rete non è implementato alcun controllo della congestione.
	\item \textbf{Controllare la qualità del servizio}; tutte le tecniche di controllo della qualità del servizio sono implementate \textbf{a livelli superiori}.
	\item \textbf{Offrire sicurezza}; quando il livello di rete è stato progettato la sicurezza non era un problema.
\end{itemize}
Per la trasmissione dei dati è usata la tecnica di \textbf{packet switching}, sia con \textbf{approccio a datagramma} che \textbf{a circuito virtuale}, l'approccio dipende dalla tecnologia della rete.
\begin{itemize}
	\item \textbf{Approccio a datagramma}: offre un servizio \textbf{connection-less}, ogni datagramma è un'unità \textbf{indipendente} che viaggia sulla rete e il suo \textbf{inoltro} si basa \textbf{solamente} \textbf{sull'indirizzo di destinazione} contenuto nella sua \textbf{intestazione}. I datagrammi che compongono un messaggio \textbf{possono} viaggiare tutti sullo \textbf{stesso} percorso \textbf{o} seguire ognuno una strada completamente \textbf{diversa}. Il livello di rete di \textbf{\underline{Internet}} è stato progettato per essere in grado di fornire un servizio \textbf{connection-less}.

	      \pagebreak

	\item \textbf{Approccio a circuito virtuale}: offre un servizio conection-oriented. Viene
	      stabilita una \textbf{connessione logica} prima dell'invio dei datagrammi che compongono il messaggio. \textbf{I datagrammi} seguono tutti lo \textbf{stesso percorso} all'interno della rete e oltre agli indirizzi sorgente e destinazione, utili nel caso i cui il datagramma debba attraversare una rete che non offre un servizio connection-oriented, contengono anche un'\textbf{etichetta di flusso} che identifica \textbf{il circuito virtuale} che a sua volta definisce \textbf{il percorso virtuale} che il datagramma deve seguire. \textbf{L'inoltro del datagramma di basa quindi sulla sua etichetta di flusso}. Per implementare un servizio \textbf{connection-oriented} si utilizza un processo composto da \textbf{tre} fasi:
	      \begin{enumerate}
		      \item \textbf{Setup}: creazione del circuito virtuale, configurazione dei router intermedi e creazione delle tabelle d'inoltro.
		      \item \textbf{Data transfer}: trasferimento dei dati.
		      \item \textbf{Teardown}: distruzione del circuito virtuale.
	      \end{enumerate}
	      \begin{figure}[!h]
		      \includegraphics[scale=0.3]{Immagini/IP_conn.png}
		      \centering
		      \caption{Il processo d'istradamento in una rete connection-oriented.}
	      \end{figure}
	      \begin{figure}[!h]
		      \includegraphics[scale=0.3]{Immagini/Ip_conn_table.png}
		      \centering
		      \caption{Il processo d'inoltro in una rete connection-oriented.}
	      \end{figure}
\end{itemize}

\pagebreak

\subsection{Internet Protocol}
Il \textbf{protocollo IP} è un protocollo di tipo \textbf{connection-less}, \textbf{sono} perciò \textbf{assenti} sia \textbf{il circuito virtuale che quello fisico} fra i due sistemi terminali. Adotta una \textbf{politica di invio} dei datagrammi di tipo \textbf{send and pray}, \textbf{senza} controllo degli errori, \textbf{non} garantisce il controllo di flusso e presenta una \textbf{politica di gestione della qualità} del servizio di tipo \textbf{best effort} ovvero con prestazioni estremamente \textbf{variabili}.

\begin{figure}[!h]
	\includegraphics[scale=0.2]{Immagini/IPv4.png}
	\centering
	\caption{I protocolli di livello rete dello stack protocollare TCP/IP\@. In realtà il protocollo RSVP è un protocollo di livello trasporto.}
\end{figure}

Nel corso del tempo \textbf{i protocolli di livello rete} hanno avuto \textbf{diverse versioni}, di particolare interesse sono la \textbf{versione 4} e la \textbf{versione 6}.
L'\textbf{IP} è \textbf{responsabile} della \textbf{suddivisione} in pacchetti, dell'\textbf{inoltro} e della \textbf{consegna} dei datagrammi. Sono inoltre presenti altri 4 \textbf{protocolli ausiliari}:
\begin{enumerate}
	\item L'\textbf{Internet Control Message Protocol} o \textbf{ICMP} aiuta a \textbf{gestire} alcuni \textbf{errori} che possono avvenire \textbf{nell'inoltro dei datagrammi}.
	\item L'\textbf{Internet Group Management Protocol} o \textbf{IGMP} supporta l'IP nella gestione del \textbf{multicasting}.
	\item L'\textbf{Open Shortest Path First} o \textbf{OSPF} è un protocollo di \textbf{routing}.
	\item Il \textbf{Resource Reservation Protocol} o \textbf{RSVP} è un protocollo di \textbf{livello trasporto}, \textbf{non trasporta dati applicativi} bensì implementa un meccanismo, dal lato del ricevente, per riservare risorse lungo la rete.
\end{enumerate}

\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/Ip_d.png}
	\centering
	\caption{La struttura di un datagramma IP.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Ip_datagram.png}
	\centering
	\caption{Un datagramma IP\@. I campi evidenziati in rosso riguardano la frammentazione dei datagrammi.}
\end{figure}

Un \textbf{datagramma IP} è un pacchetto di lunghezza variabile composto da due parti: \textbf{un'intestazione} o \textbf{header} e \textbf{un campo dati} o \textbf{payload}.
L'intetazione è lunga da \textbf{20} a \textbf{60} byte e contiene le informazioni fondamentali per il \textbf{routing} e \textbf{la consegna} dei datagrammi.
\begin{itemize}
	\item \textbf{Numero di versione}: definisce la versione del protocollo IP, attualmente: \textbf{v4} o \textbf{v6}.
	\item \textbf{Lunghezza dell'intestazione}: definisce la lunghezza totale dell'intestazione del datagramma misurata in \textbf{parole} formate da \textbf{4 byte} per via della lunghezza del campo stesso, ovvero 4 bit. L'effettiva lunghezza totale corrisponde al valore di questo campo \textbf{moltiplicato per 4}.
	\item \textbf{Tipo di servizio}: campo riservato per i servizi differenziati.
	\item \textbf{Lunghezza totale}: definisce la \textbf{lunghezza} totale del \textbf{datagramma}.
	\item \textbf{Identificazione, Flag e Scostamento}: questi tre campi riguardano la \textbf{frammentazione} del datagramma IP che \textbf{avviene} quando la sua  \textbf{dimensione} è \textbf{maggiore} rispetto alla \textbf{capacità di trasporto del livello di collegamento sottostante}.
	\item \textbf{Time To Live}: campo utilizzato per definire il \textbf{numero massimo di salti} (hops) che un datagramma può effettuare da un router all'altro. Il suo \textbf{scopo} è quello di \textbf{eliminare dalla rete} il traffico superfluo causato da \textbf{datagrammi instradati male}. È \textbf{pari} a circa \textbf{il doppio del numero massimo di salti tra due host qualsiasi} presenti su Internet. Ogni router decrementa il valore del campo di una unità, \textbf{quando è pari a 0} il prossimo \textbf{router} di \textbf{scarta il datagramma}.

	      \pagebreak

	      \textbf{Protocollo}: è il campo contenente un numero di 8 bit, \textbf{individua il protocollo che fa uso di IP}. I numeri sono assegnati \textbf{univocamente}. Quando il datagramma arriva a destinazione il valore di questo campo permette di individuare il protocollo a cui consegnare il payload del datagramma. Il campo fornisce \textbf{multiplexing alla sorgente} e \textbf{demultiplexing alla destinazione}. Per il livello rete ha quindi una funzione molto simile ai numeri di porta del livello trasporto.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.22]{Immagini/Ip_proto.png}
		      \centering
		      \caption{Multiplexing e demultiplexing utilizzando il valore del campo protocollo.}
	      \end{figure}

	\item \textbf{Checksum dell'intestazione}: il protocollo IP \textbf{non} si cura di \textbf{individuare} nè tanto meno di \textbf{correggere eventuali errori del payload dovuti alla trasmissione}. Tuttavia l'\textbf{intestazione} dei datagrammi viene \textbf{aggiunta}, durante il processo di incapsulamento, \textbf{al livello rete} ed è perciò \textbf{responsabilità dell'IP verificarne la correttezza}. Inoltre gli \textbf{errori} nell'\textbf{intestazione} possono comportare la consegna dei datagrammi a host e/o protocolli \textbf{sbagliati}. Tali ragioni giustificano la presenza del campo checksum per l'intestazione. \textbf{La checksum va ricalcolata in ogni router} a causa della possibile \textbf{variazione dei campi dell'intestazione} come il TTL o i campi relativi alla frammentazione.
	\item \textbf{Indirizzi sorgente e destinazione}: contengono rispettivamente l'indirizzo dell'\textbf{host sorgente} e quello dell'\textbf{host destinatario}. L'host sorgente dovrebbe conoscere a priori il proprio indirizzo IP, mentre quello dell'host destinatario è noto al protocollo di livello superiore che sta usando l'IP\@. Il valore di questi campi \textbf{non dovrebbe cambiare} per tutta la durata della vita del datagramma per ovvie ragioni.
	\item {\textbf{Opzioni}}: contiene opzioni che possono essere usate per il test o il debug della rete.
	\item \textbf{Payload}: contiene \textbf{i dati trasportati dal datagramma}. Il \textbf{payload} è il pacchetto che deriva dagli altri protocolli che fanno uso del servizio offerto da IP, siano essi del livello di trasporto o del livello di rete, come ad esempio ICMP.
\end{itemize}

\pagebreak

\subsubsection{Frammentazione}
Per giungere a destinazione un \textbf{datagramma IP} potrebbe dover \textbf{attraversare varie reti}, \textbf{ognuna con caratteristiche differenti}. Supponiamo ad esempio che il datagramma sia \textbf{arrivato} a un \textbf{generico router}, a quel punto verrà \textbf{estratto dal frame di livello collegamento}, \textbf{elaborato}, \textbf{incapsulato in un altro frame} e poi \textbf{rispedito}. Il \textbf{formato} e la \textbf{dimensione} del frame in entrata nel router \textbf{dipendono} dalla \textbf{tecnologia fisica} e da quella di \textbf{collegamento} utilizzati per trasportare il frame, analogamente, formato e dimensione in uscita dipenderanno dalle caratteristiche di livello fisico e di livello collegamento della rete su cui il frame verrà inviato.

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/MTU.png}
	\centering
	\caption{Maximum Transfer Unit o MTU.}
\end{figure}

Ogni protocollo di livello collegamento ha il suo formato di frame e ogni formato di frame ha il suo \textbf{MTU} che indica \textbf{la dimensione massima del payload che può essere incapsulato nel frame}. In altre parole la dimensione massima dell'intero datagramma IP deve essere minore o uguale all'MTU del livello di collegamento sul quale verrà inoltrato. Quando ciò non dovesse avvenire il datagramma viene \textbf{frammentato} in parti più piccole per poter essere trasportato. \textbf{\underline{N.B.}} I \textbf{frammenti} così ottenuti hanno  \textbf{una propria intestazione}, possono seguire \textbf{percorsi diversi} sulla rete e possono essere a loro volta frammentati da qualsiasi entità IP, tuttavia il \textbf{riassemblaggio} avviene solo all'host di destinazione, se manca qualche frammento l'intero datagramma viene scartato.

L'host o il router che frammenta il datagramma IP deve, per l'intestazione di ogni frammento, cambiare i seguenti campi: \textbf{flag}, \textbf{scostamento} e \textbf{lunghezza totale} e copiare il resto dei campi del datagramma originale.
\begin{itemize}
	\item \textbf{Identificazione}: è un numero positivo di 16 bit associato al datagramma dall'host sorgente, \textbf{IP utilizza un contatore per etichettare i datagrammi}. La combinazione dell'\textbf{identificazione} e degli \textbf{indirizzi IP sorgente e destinazione} identifica il datagramma per un tempo ragionevolmente lungo. Il valore del campo \textbf{identificazione} viene copiato in tutti i frammenti, quindi \textbf{tutti i frammenti} di un messaggio hanno lo \textbf{stesso valore} per il campo \textbf{identificazione}.

	      \pagebreak

	\item \textbf {I tre bit di Flag} definiscono \textbf{tre flag} distinti:
	      \begin{enumerate}
		      \item Il \textbf{bit 0 è riservato}.

		      \item Il \textbf{bit 1, do not fragment,} vale 0 se il datagramma può essere frammentato e 1 se non deve essere frammentato, in tal caso il dispositivo \textbf{scarta} il datagramma se non è in grado di trasmetterlo lungo nessuna rete fisica a cui è collegato e invia un messaggio d'errore ICMP all'host sorgente.

		      \item Il \textbf{bit 2, more fragments,} vale 0 se il frammento è l'ultimo del datagramma o 1 se non è l'ultimo e ci sono altri frammenti dopo di lui.
	      \end{enumerate}

	\item \textbf{Scostamento di frammentazione}: mostra la posizione relativa del frammento rispetto al datagramma originario.

	      \textbf{Esprime l'offset dei dati del frammento nel datagramma originario misurato in unità di 8 byte}. I 13 bit del campo non consentono di rappresentare numeri maggiori di 8191 ed essendo la lunghezza massima del datagramma IP 65535 byte \textbf{la divisione per 8 è necessaria}.

	      Ciò comporta che \textbf{l'host sorgente o i router che frammentano il datagramma debbano scegliere la dimensione dei frammenti in modo tale che sia un multiplo di 8}, ad eccezione dell'ultimo frammento.

	      Nel caso in cui avvengano \textbf{multiple frammentazioni} lo \textbf{scostamento di frammentazione} è sempre \textbf{relativo al datagramma originario}.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.33]{Immagini/Ip_frag.png}
		      \centering
		      \caption{Un esempio di frammentazione, l'offset è espresso in unità di 8 byte.}
	      \end{figure}

\end{itemize}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/Ip_frag1.png}
	\centering
	\caption{I frammenti potrebbero seguire un percorso alternativo.}
\end{figure}

\subsubsection{Indirizzi}
La versione 4 del protocollo IP, comunemente chiamata \textbf{IPv4}, \textbf{usa indirizzi a 32 bit} o \textbf{4 byte}, ciò comporta che lo spazio degli indirizzi abbia dimensione pari a 4.294.967.296 indirizzi possibili.

Ogni host è connesso ad Internet attraverso \textbf{un'interfaccia di rete}, che marca il confine fra l'host ed il collegamento su cui vengono inviati i datagrammi. Ad ogni interfaccia \textbf{è assegnato un indirizzo IP}. \textbf{I router sono dispositivi intermedi che devono necessariamente essere connessi ad almeno due collegamenti e per questo motivo hanno almeno due interfacce di rete.}

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_not.png}
	\centering
\end{figure}

Come gli indirizzi di ogni altra rete di comunicazione anche \textbf{gli indirizzi IPv4 hanno una struttura gerarchica} che si compone di \textbf{due parti}:

\begin{enumerate}
	\item \textbf{Prefisso} o \textbf{network ID}: identifica una rete IP su internet.
	\item \textbf{Suffisso} o \textbf{host ID}: identifica l'host sulla rete.
\end{enumerate}

\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/IPv4_add.png}
	\centering
\end{figure}

\pagebreak

\textbf{Originariamente} l'indirizzo IPv4 era stato progettato con un prefisso di \textbf{lunghezza fissa}, ma la necessità di identificare \textbf{reti di varie dimensioni} ha portato all'introduzione di un prefisso a \textbf{lunghezza variabile}. Sono state previste \textbf{tre lunghezze di prefissi} e l'intero \textbf{spazio degli indirizzi} è stato \textbf{diviso} in \textbf{cinque classi}.

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/IPv4_c_add.png}
	\centering
	\caption{Class addressing.}
\end{figure}

Nella \textbf{classe A} la lunghezza della parte di rete è \textbf{8 bit} ma poichè il primo bit, che è 0, identifica la classe si hanno solo \textbf{7 bit per identificare 128 reti} e \textbf{24 bit di suffisso per 16 milioni di host}. Gli indirizzi di classe A vanno dal 0.0.0.0 al 127.255.255.255.

Nella \textbf{classe B} la lunghezza della parte di rete è di 16 bit ma poichè i primi due sono uguali a $(10)_{2}$ e identificano la classe si hanno \textbf{14 bit per identificare le reti}, circa 16000, e \textbf{16 bit per circa 64.000 host}. Gli indirizzi di classe B vanno dal 128.0.0.0 al 191.255.255.255.

Nella \textbf{classe C} la lunghezza della parte di rete è di 24 bit, i primi tre bit identificano la classe e sono uguali a $(110)_{2}$. Si hanno \textbf{21 bit per le reti IP e 8 bit per 256 host}. Gli indirizzi di classe C vanno dal 192.0.0.0 al 223.255.255.255.

La \textbf{classe D} è riservata per il \textbf{multicasting}. I suoi indirizzi vanno dal  224.0.0.0 al 239.255.255.255. La \textbf{classe E} è riservata per \textbf{uso futuro}. I suoi indirizzi vanno dal 240.0.0.0 al 255.255.255.255.

Analizziamo alcuni indirizzi per fare un esempio:
\textbf{15.10.10.90}: si tratta di un indirizzo di classe A, poiché il primo
numero è compreso fra 0 e 127. Dunque i seguenti campi indicano l’host: 10.10.90 nella rete IP: 15.

\textbf{130.250.42.53}: si tratta di un indirizzo di classe B, poiché il primo
numero è compreso fra 128 e 191. Dunque i primi due campi indicano la rete IP: 130.250, gli altri indicano l’host: 42.53.

\textbf{196.234.12.14}: si tratta di un indirizzo di classe C, poiché il primo
numero è compreso fra 192 e 223. Dunque i primi tre campi indicano la rete IP 196.234.12, e l’ultimo indica l’host: 14.

\pagebreak

L'\textbf{indirizzamento con classi}, sebbene consenta di risalire al prefisso senza l'aggiunta di ulteriori informazioni, \textbf{è diventato obsoleto} a causa dello \textbf{scorretto assegnamento degli indirizzi} e del \textbf{conseguente esaurimento} degli stessi. È chiaro che la \textbf{soluzione a lungo termine} sia di \textbf{adottare degli indirizzi più lunghi} (IPv6). Ciò comporterebbe però di modificare anche la \textbf{struttura dei datagrammi IP}.

Per tale motivo e anche a causa dell'affermarsi degli \textbf{Internet Service Providers} durante gli anni '90, si è ideata, oltre alla soluzione a lungo termine, anche una \textbf{soluzione a breve termine} facente sempre uso \textbf{dell'indirizzo IPv4} ma \textbf{non dell'indirizzamento con classi}.

\begin{flushleft}
	\textit{Gli \textbf{ISP} sono organizzazioni che forniscono \textbf{accesso a Internet} a persone o altre organizzazioni il cui interesse è \textbf{solo} quello di utilizzare i servizi offerti ma \textbf{non} di far parte di Internet o di offrire a loro volta servizi. \textbf{Un ISP ottiene un insieme molto ampio di indirizzi e lo suddivide in gruppi}.}
\end{flushleft}

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_classless.png}
	\centering
	\caption{Indirizzamento senza classi, con spazio degli indirizzi diviso in blocchi di lunghezza variabile.}
\end{figure}

Tale soluzione, chiamata \textbf{indirizzamento senza classi}, prevede che lo spazio delgi indirizzi venga suddiviso in blocchi di lunghezza variabile. Il \textbf{prefisso di un indirizzo individua il blocco (la rete) e il suffisso individua il dispositivo}.

Un \textbf{prefisso grande} individua una \textbf{rete più piccola} e viceversa un \textbf{prefisso piccolo} individua una \textbf{rete più grande}.

\textbf{Per individuare il prefisso}, data l'assenza delle classi, \textbf{è stata aggiunta all'indirizzo una barra slash "/" che separa l'indirizzo dalla lunghezza del prefisso}. Tale notazione è definita \textbf{CIDR} o \textbf{Class-less Inter Domain Routing}.

\begin{figure}[!h]
	\includegraphics[scale=0.2]{Immagini/Ip_cidr.png}
	\centering
	\caption{CIDR.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_inf_ex.png}
	\centering
	\caption{Estrazione delle informazioni nell'indirizzamento senza classi.}
\end{figure}

\begin{enumerate}
	\item Il \textbf{numero degli indirizzi nel blocco} è N = $2^{32 - n}$.
	\item Il \textbf{numero di host è dato da } $N - 2$, devo sottrarre l'indirizzo di rete e l'indirizzo di broadcast. \textit{[spiegazione avanti]}
	\item Il \textbf{primo indirizzo} è \textbf{l'indirizzo di rete} ed è ricavato tenendo invariati i primi n bit e azzerando tutti gli altri.
	\item L' \textbf{ultimo indirizzo} è \textbf{l'indirizzo di broadcast} ed è ricavato tenendo invariato i primi n bit e impostando ad 1 tutti gli altri.
\end{enumerate}

Un altro modo per ricavare il primo e l'ultimo indirizzo del blocco è usare la \textbf{maschera dell'indirizzo}, ovvero un numero di 32 bit in cui i \textbf{primi n bit} sono impostati a 1 e gli altri $32 - n$ a 0, con \textbf{n lunghezza del prefisso}.

La \textbf{maschera dell'indirizzo} o \textbf{subnet mask} può essere utilizzata molto \textbf{efficientemente} da un un \textbf{programma} per ricavare le informazioni di un blocco usando tre operatori sui bit: \textbf{NOT}, \textbf{AND} e \textbf{OR}.

\begin{enumerate}
	\item Il \textbf{numero degli indirizzi nel blocco} è:
	      \begin{center}
		      $N = \textbf{NOT}(maschera) + 1$.
	      \end{center}
	\item Il \textbf{primo indirizzo del blocco} è:
	      \begin{center}
		      (qualsiasi indirizzo del blocco) \textbf{AND} (maschera)
	      \end{center}
	\item L'\textbf{ultimo indirizzo del blocco} è:
	      \begin{center}
		      (qualsiasi indirizzo del blocco) \textbf{OR} (\textbf{NOT}(maschera))
	      \end{center}
\end{enumerate}

L'\textbf{indirizzo di rete} è usato per instradare i datagrammi.

\pagebreak

Esempio:\newline
All'indirizzo IP: \textbf{150.217.8.42} è definita la netmask \textbf{255.255.255.0}.

La rete o subnet effettiva ha indirizzo \textbf{150.217.8.0/24}.
\begin{verbatim}
Indirizzo IP 150.217.8.42 10010110 11011001 00001000 00101010
Subnet Mask 255.255.255.0 11111111 11111111 11111111 00000000
AND           150.217.8.0 10010110 11011001 00001000 00000000
\end{verbatim}
Gli indirizzi \textbf{150.193.4.1/22}, \textbf{150.193.8.18/22}, \textbf{150.193.11.3/22} appartengono alla stessa sottorete o subnet?
\begin{alltt}
	Indirizzo IP 150.193.4.1  10010110 11000001 00000100 00000001
	Subnet Mask 255.255.252.0 11111111 11111111 11111100 00000000
	AND           150.217.4.0 10010110 11000001 00000\underline{1}00 00000000
\end{alltt}
\begin{verbatim}
Indirizzo IP 150.193.8.18 10010110 11000001 00001000 00010010
Subnet Mask 255.255.252.0 11111111 11111111 11111100 00000000
AND           150.217.8.0 10010110 11000001 00001000 00000000
\end{verbatim}
\begin{verbatim}
Indirizzo IP 150.193.11.3 10010110 11000001 00001011 00000011
Subnet Mask 255.255.252.0 11111111 11111111 11111100 00000000
AND           150.217.8.0 10010110 11000001 00001000 00000000
\end{verbatim}
Il primo indirizzo \textbf{non} vi appartiene.

Esiste un modo più adatto a noi esseri umani? Sì, basta che \textbf{confrontiamo i primi 22 bit degli indirizzi} per arrivare alla stessa conclusione.

\begin{alltt}
	Indirizzo IP 150.193.4.1  10010110 11000001 00000\underline{1} | 00 00000001
	Indirizzo IP 150.193.8.18 10010110 11000001 000010 | 00 00010010
	Indirizzo IP 150.193.11.3 10010110 11000001 000010 | 11 00000011
\end{alltt}

Altro esempio:\newline
Indirizzo IP: \textbf{167.199.170.82/27}, maschera: \textbf{255.255.255.224}. Si ha che:
\begin{verbatim}
Primo indirizzo del blocco o i. di rete = (address) AND (mask)
10100111 11000111 10101010 01010010 AND
11111111 11111111 11111111 11100000
10100111 11000111 10101010 01000000

Ultimo indirizzo del blocco o i. di broadcast = (address) OR (NOT(mask))
10100111 11000111 10101010 01010010 OR
00000000 00000000 00000000 00011111
10100111 11000111 10101010 01011111
\end{verbatim}

\pagebreak

\subsubsection{Curiosità}
Per quale motivo UDP e TCP si preoccupano di controllare l’integrità di informazioni di livello
network se anche \textbf{IP usa un suo checksum}?

Stando a \textbf{David Patrick Reed}, noto per essere l'ideatore del protocollo UDP nonché una delle principali menti dietro allo stack protocollare TCP/IP:

\textit{As I was there in 1976, when we split TCP into IP, TCP, and other protocols, such as UDP, for the decision to separate the checksums and
	to create a pseudo-header, here is the rationale, which is highly relevant.}

\textit{TCP and UDP are end-to-end protocols.   In particular, the TCP
	checksum is "end-to-end". It is a "private matter" between end points
	implementing the TCP layer, guaranteeing end-to-end reliability, not
	hop-by-hop reliability.}

\textit{IP is a wrapper for TCP, which instructs the transport layer, the
	gateways and routers, where the packet is to be transported, how big it
	is, and how it may be fragmented in the process of delivery.}

\textit{The Source Address, Destination address, length, etc.\ are part of the
	meaning of the TCP frame - in that the end point machines use that
	information in the TCP application.}

\textit{Thus the function of source address, destination address,
	etc.\ are "shared" because they are
	meaningful to both layers IP and TCP\@. Rather than include the same
	information twice in the packet format, the concept of a "virtual
	header" was invented to encapsulate the idea that IP is not allowed to
	change the SA and DA because they are meaningful.}

\textit{Further, in the case of end-to-end encryption, in 1976 we had a complete
	design by Steven T. Kent, my office mate, which was blocked by NSA from
	being deployed, it is essential that all end-to-end meaning be
	protected.The plan was to leave the source address and destination address in the clear, but  encrypt the rest of the TCP payload, including the checksum.  This would
	protect against a man-in-the-middle attack that delivered valid packets
	with an incorrect source address.}

\textit{This was a careful design decision, wrecked irrevocably by the
	terrorists who invented NAT, which doesn't allow end--to-end encryption,
	because NAT is inherently a "man-in-the-middle" attack!}

\textit{The rise of the middleboxen have now so thoroughly corrupted the
	Internet protocol design that it's not surprising that the original
	designs are difficult to decode.   If we actually had end-to-end
	encrypted TCP, now impossible because of the NATs, we would have a much
	more secure and safe Internet, while preserving its open character.
	Instead we have a maze of twisty, disconnected passages, vulnerable to a
	zillion hackers.}

\pagebreak

\subsubsection{Assegnazione dei blocchi di indirizzi}
Uno dei \textbf{principali problemi} dell'\textbf{indirizzamento senza classi} è rappresentato dall'\textbf{assegnazione dei blocchi}. La responsabilità di questo compito ricade su un ente globale chiamato \textbf{ICANN} o \textbf{Internet Corporation for Names and Numbers}. L'\textbf{ICANN} non assegna gli indirizzi ai singoli utenti bensì \textbf{assegna grandi blocchi di indirizzi a ISP} o organizzazioni di dimensione comparabile.

Per il corretto funzionamento del CIDR bisogna operare due restrizioni sui blocchi assegnati:
\begin{enumerate}
	\item Il \textbf{numero degli indirizzi assegnati N deve essere una potenza di 2}. N sarà uguale a $2^{32 - n}$ e $n = 32 - log_{2}N$. Se N non fosse una potenza di 2 n non sarebbe un numero intero.
	\item Il blocco assegnato deve essere uno spazio libero \textbf{contiguo} e \textbf{il primo indirizzo deve essere divisibile per il numero degli indirizzi nel blocco}. La ragione è che il primo indirizzo deve essere composto dal prefisso seguito da $32 - n$ zeri e sarà uguale a: $(prefisso)_{10} \times N$
\end{enumerate}
Esempio:

Supponiamo che un ISP richieda un blocco 190 indirizzi.

Ne otterrà 256, poichè $2^{8}$ è la potenza di 2 immediatamente maggiore di 190.
Supponiamo che ottenga il seguente blocco: \textbf{14.24.74.0/24}

L'ISP vuole ora partizionare il blocco ottenuto in \textbf{tre sottoblocchi} da 120, 60 e 10 indirizzi,rispettivamente. Come può disegnare tali sottoblocchi?

Partiamo dal sottoblocco più grande, quello da 120 indirizzi. La potenza di 2 maggiore di 120 è $2^{7} = 128$. Quindi $32 - 7 = 25$ bit per la rete. Il blocco è 14.24.74.0/25.	Il primo indirizzo 14.24.74.0 e l'ultimo sarà 14.24.74.127.
\begin{alltt}
	00001110.00011000.01001010.0\underline{0000000}
\end{alltt}
Secondo sottoblocco $60 < 2^{6} = 64$. Quindi $32 - 6 = 26$ bit per la rete. Il blocco è 14.24.74.128/26. Il primo indirizzo sarà 14.24.74.128 e l'ultimo sarà 14.24.74.191.
\begin{alltt}
	00001110.00011000.01001010.10\underline{000000}
\end{alltt}
Terzo sottoblocco $10 < 2^{4} = 16$. Quindi $32 - 4 = 28$ bit per la rete. Il blocco è 14.24.74.192/28. Il primo indirizzo sarà 14.24.74.192 e l'ultimo sarà 14.24.74.207
\begin{alltt}
	00001110.00011000.01001010.1100\underline{0000}
\end{alltt}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_es.png}
	\centering
	\caption{Il blocco dell'esempio di prima partizionato. \newline\small{\underline{L'indirizzo dell'ultimo blocco in figura è sbagliato.}}}
\end{figure}

\subsubsection{Aggregazione degli indirizzi}
Per contenere il numero degli indirizzi di rete è la possibile \textbf{aggregare gli indirizzi} in vari blocchi per ottenere un blocco più grande. L'instradamento può poi essere effettuato usando il prefisso del blocco aggregato in tempo molto minore.

\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Ip_aggr.png}
	\centering
	\caption{Un ISP ha assegnato a 4 organizzazione piccoli blocchi
		di indirizzi. L’ISP aggrega i 4 blocchi in 1 singolo blocco e
		annuncia al resto della rete solo il blocco aggregato. Sarà poi sua responsabilità inoltrare i datagrammi all'organizzazione corretta.}
\end{figure}

\pagebreak

\subsubsection{Indirizzi speciali}

\begin{itemize}
	\item \textbf{0.0.0.0 this-host}, è usato quando un host ha necessità di inviare un
	      datagramma ma non conosce il proprio indirizzo IP.
	\item \textbf{127.0.0.1 loopback}, il datagramma con questo indirizzo di
	      destinazione non lascia l’host locale. Per test e debug.
	\item \textbf{255.255.255.255 limited broadcast}, usato quando un router o un
	      host devono inviare un datagramma a tutti i dispositivi che si
	      trovano all’interno della loro rete. I router bloccano la propagazione alla
	      sola rete locale.
	\item  \textbf{10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16,
		      169.254.0.0/16}, quattro blocchi di indirizzi privati per reti locali.
	\item \textbf{Blocco 224.0.0.0/4}, indirizzi multicast.
\end{itemize}


\subsubsection{DHCP}
Una volta che un blocco è stato assegnato a un'organizzazione l'amministratore di rete può assegnare \textbf{manualmente} gli indirizzi ai singoli host o router. L'assegnazione degli indirizzi può \textbf{però anche essere automatizzata} mediante il protocollo \textbf{DHCP} o \textbf{Dynamic Host Configuration Protocol}. Il DHCP è un programma \textbf{client-server} di \textbf{livello applicazione}, viene usato per \textbf{assegnare indirizzi IP} permanentemente agli host e ai router di una rete, o anche temporaneamente, a richiesta degli host.

Quest'ultima funzione è particolarmente \textbf{utile nel caso in cui} ad esempio si voglia fornire un servizio a 4000 persone avendo però solo 1000 indirizzi, assumendo che non più di un quarto delle persone si connetta contemporaneamente.

\textbf{Oltre} all'indirizzo IP \textbf{DHCP} fornisce all'host anche il \textbf{prefisso della propria rete}, \textbf{l'indirizzo del router di dafault} e \textbf{l'indirizzo IP del server dei nomi di dominio}. Illustriamone il funzionamento:

\begin{enumerate}
	\item Il \textbf{client DHCP} dell'host che vuole entrare in rete crea un messaggio \textbf{DCHPDISCOVER} nel quale imposta, non avendo altre informazioni, solo il campo \textbf{transaction id} ad identificare la richiesta.
	      \textbf{Tutti i messaggi DCHP vengono incapsulati in un datagramma UDP} con p.s 68 (client) e p.d. 67 (server) \textbf{ed esso, successivamente, in un datagramma IP}. In questo caso l' i.s vale 0.0.0.0 e i.d.d. 255.255.255.255.


	\item Il \textbf{server DHCP} risponde un un messaggio \textbf{DCHPOFFER} contenente l'indirizzo IP offerto al client, l'indirizzo IP del server e un \textbf{lease time}, il tempo a disposizione dell'host per usare l'indirizzo IP assegnatogli.

	      \pagebreak

	      L'i.d.d. è ancora l'indirizzo di broadcast in modo tale che \textbf{anche gli altri server DCHP ricevano l'offerta e nel caso ne inviino una migliore} qual'ora possano.

	\item Il \textbf{client}, che potrebbe aver ricevuto più offerte, a questo punto \textbf{sceglie l'alternativa migliore} e invia un messaggio \textbf{DHCPREQUEST} al server che l'ha proposta.

	      L'i.d.d. è sempre quello di broadcast \textbf{per comunicare agli altri server che la loro offerta non è stata accettata}.

	\item Il server a questo punto, se l'indirizzo IP offerto è ancora valido, risponde con un messaggio DHCPACK altrimenti con un messaggio DHCPNACK\@. L'i.d.d. è sempre il broadcast \textbf{per comunicare agli altri server che la richiesta è stata o meno soddisfatta}.
\end{enumerate}

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/DHCP.png}
	\centering
	\caption{Funzionamento del DHCP.}
\end{figure}

\pagebreak

\subsubsection{Inoltro dei datagrammi IP}
Inoltrare un datagramma significa \textbf{collocarlo nel giusto percorso} che lo porterà a destinazione.

Per \textbf{forwarding diretto} s'intende l'invio di un datagramma che ha come destinazione un host nella stessa rete del mittente. Il datagramma \textbf{non esce dalla rete} e l'invio è \textbf{diretto} sul destinatario, non viene interpellata nessun'altra entità. L'indirizzo di destinazione al livello collegamento è quello del destinatario stesso.

Per \textbf{forwarding indiretto} s'intende l'invio di un datagramma che ha come destinazione un \textbf{host di un'altra rete} rispetto a quella del mittente. Nell'inoltro si interpellano varie altre entità chiamate \textbf{routers}. L'indirizzo di destinazione al livello link è quello del router.

È bene far presente che in entrambi i casi le condizioni necessarie affinché tutto funzioni sono che \textbf{esista un collegamento diretto a livello link tra tutti gli host che appartengono a una stessa sottorete} e \textbf{ogni host coinvolto abbia un indirizzo IP corretto, cioè con uguale network ID  e con host ID univoco nella sottorete}.

Le \textbf{due condizioni insieme} diventano condizione \textbf{necessaria e sufficiente} perché la comunicazione \textbf{funzioni}.

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Ip_net.png}
	\centering
	\caption{Esempio di rete IP.}
\end{figure}

Come detto in precedenza, ogni host connesso a una rete IP è dotato di un interfaccia di rete e ad ogni interfaccia di rete è associato un indirizzo IP \textbf{univoco}.

Il \textbf{router è un dispositivo intermedio} che svolge funzioni di instradamento al livello IP ed è dotato di almeno due interfacce di rete.

Quando un \textbf{host} deve inviare un datagramma, o un \textbf{router} deve inoltrarne uno ricevuto, fanno entrambi riferimento alla loro \textbf{tabella d'inoltro} per ricavare il nodo della rete successivo a cui inviare il datagramma.

Nell'indirizzamento senza classi una \textbf{tabella d'inoltro deve includere quattro informazioni}: \textbf{la maschera}, \textbf{l'indirizzo di rete}, \textbf{il numero dell'interfaccia} e \textbf{l'indirizzo IP del router successivo}. Le prime due informazioni sono spesso combinate.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Ip_ex.png}
	\centering
	\caption{Una configurazione di hosts.}
\end{figure}
\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Ip_ex1.png}
	\centering
	\caption{La tabella d'inoltro del router R1.}
\end{figure}

Il \textbf{modulo d'inoltro si occupa di effettuare le ricerche nella tabella}. La ricerca \textbf{avviene nel modo seguente}: per ogni riga gli \textbf{n} bit a sinistra dell'indirizzo di destinazione, che costituiscono il \textbf{prefisso}, sono lasciati \textbf{invariati} e i \textbf{restanti settati a zero}. Se l'indirizzo di rete risultante \textbf{combacia} con l'indirizzo presente nella riga allora anche le informazioni delle altre due colonne, relative alla riga, vengono estratte. \textbf{Altrimenti la ricerca continua}.

Supponiamo che R1 debba inoltrare un datagramma con il seguente indirizzo di destinazione: \textbf{180.70.65.140}.
Il router esegue i seguenti passaggi:
\begin{enumerate}
	\item La maschera del primo indirizzo nella tabella, \textbf{/26}, è applicata all'indirizzo di destinazione. Il risultato è 180.70.65.128, che non combacia con 180.70.65.192.
	\item Successivamente la maschera del secondo indirizzo nella tabella, \textbf{/25}, è applicata all'indirizzo di destinazione. Il risultato è 180.70.65.128, che combacia con 180.70.65.128, quindi l'indirizzo del salto e il numero di interfaccia vengono estratti e usati per inoltrare il datagramma.
\end{enumerate}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.28]{Immagini/Ip_dir.png}
	\centering
\end{figure}\begin{figure}[!h]
	\includegraphics[scale=0.28]{Immagini/Ip_dir1.png}
	\centering
\end{figure}\begin{figure}[!h]
	\includegraphics[scale=0.28]{Immagini/Ip_dir2.png}
	\centering
	\caption{Inoltro diretto negli host.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_indir.png}
	\centering
\end{figure}\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_indir1.png}
	\centering
\end{figure}\begin{figure}[!h]
	\includegraphics[scale=0.32]{Immagini/Ip_indir2.png}
	\centering
	\caption{Inoltro indiretto negli host.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.2]{Immagini/Ip_forw.png}
	\centering
\end{figure}

L'\textbf{indirizzamento con classi} permette al router di avere una tabella di indirizzamento contenente \textbf{una riga per ogni rete esterna} alla rete a cui appartiene il router.

Utilizzando un \textbf{indirizzamento senza classi} si verifica inevitabilmente un \textbf{aumento delle righe}, poichè lo spazio degli indirizzi è diviso in blocchi più piccoli delle classi, con un conseguente \textbf{aumento del tempo richiesto per effettuare l'operazione di ricerca}.

Per attenuare questo problema, come detto in precedenza, è stato ideato il meccanismo di \textbf{aggregazione degli indirizzi}.

\begin{figure}[!h]
	\includegraphics[scale=0.37]{Immagini/Ip_aggre.png}
	\centering
	\caption{Inoltro e aggregazione degli indirizzi.}
\end{figure}

Il vantaggio è osservabile in figura: il router R2 ha una tabella di indirizzamento molto più corta del router R1, qualunque datagramma con indirizzo di destinazione compreso tra 140.24.7.0 e 140.24.7.255 verrà inviato a R1 che si occuperà poi di consegnarlo alla rete appropriata. In questo caso gli indirizzi dal 140.24.7.0 al 140.24.7.255 sono stati \textbf{aggregati} in un unico blocco.

\textbf{\underline{N.B.}} L'aggregazione è possibile solo con blocchi \textbf{contigui}.

\pagebreak
\textbf{Un'altra soluzione} possibile per risolvere il \textbf{problema della dimensione eccessiva della tabelle di inoltro} è quella di implementare una \textbf{gerarchia delle tabelle}.

Attualmente Internet ha una struttura gerarchica essendo divisa in \textbf{dorsali}, \textbf{ISP nazionali}, \textbf{ISP regionali} e \textbf{ISP locali}.

\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Internet_Concept.png}
	\centering
\end{figure}

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Ip_g_add.png}
	\centering
	\caption{Routing gerarchico con ISP.}
\end{figure}

In figura un ISP regionale, a cui è stato assegnato un blocco di 16.384 indirizzi a partire dal 120.14.64.0,  ha deciso di dividerlo in 4 sotto blocchi, ciascuno con
4096 indirizzi.

Ognuno di questi blocchi è stato poi assegnato a un ISP locale che ha a sua volta effettuato una divisione in sotto blocchi di 512 indirizzi.

Il \textbf{vantaggio}, similmente prima, è che il resto di \textbf{Internet non è consapevole di tale divisione}.
Tutti i singoli clienti degli ISP locali sono \textbf{noti} al resto della rete mediante l'indirizzo 120.14.64.0: \textbf{in ogni router del mondo vi è una sola riga per tutti questi clienti}.

\pagebreak

La \textbf{tabella d'inoltro} viene ordinata dalla maschera più lunga alla maschera più corta, secondo il principio della \textbf{Longest Matching Mask}.

\begin{figure}[!h]
	\includegraphics[scale=0.47]{Immagini/Ip_lmm.png}
	\centering
	\caption{Longest Mask Matching.}
\end{figure}

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Ip_int.png}
	\centering
	\caption{L'indirizzo IP delle interfacce di un router appartiene al blocco che individua le sottoreti con cui si interfaccia.}
\end{figure}

\pagebreak

\subsubsection{NAT}
Il \textbf{NAT} o \textbf{Network Address Translation} è una tecnologia che \textbf{consente} a una \textbf{rete privata} di usare una serie di \textbf{indirizzi privati} per la comunicazione \textbf{interna} e \textbf{almeno} un \textbf{indirizzo globale} per la \textbf{comunicazione con il resto del mondo}.

L'\textbf{accesso a Internet} è realizzato tramite un router abilitato alla \textbf{NAT}, il traffico in ingresso e in uscita hanno come \textbf{indirizzo di destinazione} e \textbf{indirizzo sorgente l'indirizzo IP del router in questione}.

Ciò si effettua nel seguente modo: tutti i \textbf{datagrammi in uscita} dalla rete privata passano attraverso il router NAT che \textbf{sostituisce l'indirizzo IP sorgente} del datagramma \textbf{con l'indirizzo NAT globale del router}. Analogamente tutti i \textbf{datagrammi in entrata} passano a loro volta attraverso il router NAT che \textbf{sostituisce l'indirizzo IP destinazione} del datagramma, ovvero l'indirizzo NAT globale del router, con \textbf{l'indirizzo privato appropriato}.

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Ip_nat.png}
	\centering
	\caption{Datagrammi in entrata ed uscita da un router NAT.}
\end{figure}

Per spiegare il meccanismo di traduzione NAT si osservi in primis la struttura della tabella d'inoltro del router NAT.

Quando il router sostituisce l'indirizzo sorgente nel datagramma in uscita \textbf{prende nota del suo indirizzo di destinazione e della porta sorgente} e inserisce nella sua tabella d'inoltro la riga con il \textbf{seguente valore}:

\begin{center}
	\textbf{[ ind.\ sorgente privato, porta | ind.\ destinazione, porta ]}
\end{center}

Quando dalla destinazione giungerà la risposta, il router sarà in grado di \textbf{indirizzare correttamente il datagramma} verso l'host della rete privata \textbf{utilizzando tale associazione}.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.37]{Immagini/Ip_nat_tr.png}
	\centering
	\caption{Traduzione NAT.}
\end{figure}

Per approfondire i problemi legati al NAT consultare \hyperref[sec:NATproblems]{gli esercizi 4 e 5 alla fine della sezione}. Critiche al NAT:

\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Ip_nat_crit.png}
	\centering
\end{figure}

\pagebreak

\subsubsection{ICMP}
L'\textbf{ICMP} o \textbf{Internet Control Message Protocol} è un protocollo di livello \textbf{rete} pensato per \textbf{sopperire alle mancanze del protocollo IP} circa:

\begin{itemize}
	\item \textbf{Segnalazione e correzione degli errori}.
	\item \textbf{Invio di richieste sullo stato di un sistema remoto}.
\end{itemize}

Sebbene sia un protocollo del livello di rete, i \textbf{messaggi ICMP} non vengono trasportati dal livello collegamento, bensì \textbf{vengono prima incapsulati all'interno di datagrammi IP} per poi essere passati al livello di collegamento. I pacchetti ICMP vengono instradati dai router \textbf{prima} dei pacchetti IP ordinari.

\textbf{\underline{N.B.}} \textbf{ICMP non corregge gli errori}, si limita a \textbf{segnalarli}. La vera a e propria correzione è lasciata ai protocolli di livello più alto.

I \textbf{messaggi ICMP} si dividono in \textbf{due categorie}: \textbf{messaggi di segnalazione errore} e \textbf{messaggio di interrogazione}. I \textbf{primi} sono usati dai routers o dagli hosts \textbf{per segnalare possibili errori} incontrati durante l'elaborazione dei datagrammi IP, \textbf{i secondi} permettono ad un host o ad un amministratore di rete di \textbf{chiedere informazioni ad un router o ad un host}.

\begin{figure}[!h]
	\includegraphics[scale=1.3]{Immagini/ICMP.png}
	\centering
	\caption{La struttura dei messaggi ICMP.}
\end{figure}

I \textbf{messaggi di errore sono sempre inviati alla sorgente originale} poichè le uniche informazioni presenti nel \textbf{datagramma IP} sono l'indirizzo sorgente e l'indirizzo di destinazione.

\textbf{I messaggi di errore contengono l'intestazione originale del datagramma IP che li ha generati e i primi 8 byte del loro payload}. I primi 8 byte del payload, infatti, contengono \textbf{informazioni sui numeri di porta}, per i protocolli TCP e UDP, \textbf{e i numeri di sequenza}, per il protocollo TCP\@. Sono informazioni necessarie per informare la sorgente dell'errore.

\pagebreak

Per snellire il processo di segnalazione degli errori \textbf{ICMP segue le seguenti regole}:

\begin{itemize}
	\item Per i \textbf{datagrammi IP frammentati}, i messaggi ICMP sono relativi al \textbf{solo}
	      frammento numero 0.
	\item I messaggi ICMP \textbf{non} sono mai inviati in risposta a pacchetti IP con un indirizzo mittente che \textbf{non} rappresenti un host unico e.g.\  0.0.0.0, 127.0.0.1 e indirizzi IP speciali.
	\item I messaggi ICMP non sono \textbf{mai} inviati in risposta a messaggi di errore ICMP, ma possono essere inviati in risposta a \textbf{messaggi ICMP di interrogazione}.
\end{itemize}

\textbf{I messaggi di richiesta ICMP} invece possono essere utilizzati \textbf{senza una particolare relazione con un datagramma IP} e son sempre incapsulati in datagrammi IP.

Sono usati per \textbf{verificare il funzionamento di un host o un router} sulla rete, per \textbf{trovare il tempo necessario a un datagramma per raggiungere la destinazione} e molto altro ancora$\dots$

Presentiamo di seguito \textbf{varie applicazioni} il cui funzionamento si basa sui messaggi di interrogazione IMCP.

\begin{itemize}

	\item Il programma \texttt{ping} è usato da un host per \textbf{verificare il funzionamento di un altro host}.

	      Si basa in particolare sui \textbf{messaggi di richiesta e risposta eco dell’ICMP}. Un host invia una richiesta eco, tipo 8 e codice 0,  a un altro host che, se attivo, può rispondere con una risposta eco, tipo 0 e codice 0.

	      \textbf{Fornisce anche una misura dell’RTT} e in maniera molto grossolana, \textbf{può anche misurare l’affidabilità e la congestione del router tra due host} inviando una sequenza di messaggi richiesta-risposta.

	      \begin{figure}[!h]
		      \includegraphics[scale=2.2]{Immagini/PING.png}
		      \centering
		      \caption{Il comando \texttt{ping}.}
	      \end{figure}

	      \pagebreak

	\item Il comando \texttt{traceroute} è  utilizzato per \textbf{tracciare il percorso di un
		      datagramma dalla sorgente alla destinazione} tramite l’identificazione dell’indirizzo IP di tutti i router che vengono visitati lungo il percorso.

	      Solitamente il programma viene impostato per un \textbf{massimo di 30 salti}, che sono quasi sempre sufficienti per raggiungere la destinazione.

	      Il programma \texttt{traceroute} ha un funzionamento \textbf{molto diverso da} \texttt{ping}. \texttt{ping} è basato su \textbf{due messaggi interrogazione}. \texttt{traceroute} è invece \textbf{implementato per mezzo di due messaggi di segnalazione degli errori: tempo scaduto e
		      destinazione non raggiungibile.}

	      Sebbene sia un programma di livello applicazione ne esiste \textbf{solo il client}, non esiste un programma \texttt{traceroute} server. Non è infatti necessario raggiungere il livello applicazione dell'host destinatario.

	      \texttt{traceroute} opera nel seguente modo: genera un \textbf{datagramma UDP}, usando un numero di porta che con alta probabilità non è in uso nell'host destinatario, che verrà poi incapsulato in un datagramma IP con un valore \textbf{TTL pari a  1}.

	      Il \textbf{primo router sul percorso verso la destinazione scarta questo datagramma IP} e invia un messaggio \textbf{errore ICMP di tempo scaduto}.

	      Tramite l'indirizzo IP  sorgente contenuto nel datagramma IP che trasportava il messaggio di errore ICMP, adesso \texttt{traceroute} conosce l'indirizzo IP del primo router. Invia quindi un altro datagramma UDP all'interno di un datagramma IP con \textbf{TTL stavolta impostato a 2} e così via.

	      In totale verranno inviati \underline{$n + 1$} datagrammi IP, \textbf{\underline{$n$} saranno scartati dai router intermedi} e \textbf{\underline{l'ultimo} verrà scartato dall'host destinatario}.

	      \begin{figure}[!h]
		      \includegraphics[scale=2.2]{Immagini/Traceroute.png}
		      \centering
		      \caption{Traceroute.}
	      \end{figure}

	      La maggior parte dei programmi \texttt{traceroute} invia \textbf{tre messaggi a ogni dispositivo}, con lo stesso valore di TTL, per poter \textbf{effettuare una stima del round-trip-time}.

	      \pagebreak

	      \begin{figure}[!h]
		      \includegraphics[scale=1.7]{Immagini/Traceroute1.png}
		      \centering
		      \caption{Il procedimento descritto in precedenza.}
	      \end{figure}

	      L'\textbf{ultimo datagramma IP} viene scartato dall'host inviando un messaggio ICMP diverso da tempo scaduto, ovvero, di \textbf{destinazione non raggiungibile}, non essendoci nessuna applicazione in ascolto sulla \textbf{porta specificata}.

	      Ricevuto il messaggio di destinazione non raggiungibile \texttt{traceroute} riconosce che la destinazione finale è stata \textbf{raggiunta}.

\end{itemize}

\subsection{Esercizi}
\begin{enumerate}
	\item Il sistema autonomo di una grande azienda è logicamente diviso in due sottosistemi: un sottosistema che usa indirizzi IP pubblici nel blocco 113.141.0.0/21, e uno che usa indirizzi IP privati nel blocco 192.168.0.0/16. Quali sono le maschere di rete, in notazione decimale puntata, usate nel sistema autonomo?

	      \textbf{Soluzione}: Ponendo uguali a uno i bit della maschera e azzerando gli altri, otteniamo:
	      \begin{alltt}
		      \centering
		      /21 -> 11111111 11111111 11111000 00000000
		      255.255. 248.0
		      /16 -> 11111111 11111111 00000000 00000000
		      255.255.0.0
	      \end{alltt}

	\item Un router IP connette tre sotto reti: 100.100.100.0/24, 111.99.99.0/24 e
	      200.200.200.0/24,, con MTU (Maximum Transfer Unit) pari a 900, 1000, e
	      1400, rispettivamente.

	      I datagrammi gestiti dal router rispettano il formato IPV4, in particolare
	      contengono i campi IP-S (indirizzo sorgente), IP-D (indirizzo destinazione), L
	      (lunghezza del datagramma, inclusa l’intestazione), Id (identificatore del
	      datagramma), F (flag di frammentazione) e O (offset).

	      Si considerino i seguenti datagrammi ricevuti dal router:
	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Ip_es2.png}
		      \centering
	      \end{figure}

	      Per ognuno di questi datagrammi dire da quale sotto rete è stato ricevuto, e
	      quali datagrammi il router invia in uscita specificandone anche la sotto rete di
	      destinazione. \textit{Nella frammentazione fare molta attenzione ai 20 byte d'intestazione}.


	      \textbf{Soluzione}:
	      Il datagramma D1 è ricevuto dalla sotto rete: 100.100.100.0/24 ed è inviato sulla sotto rete: 200.200.200.0/24 e \textbf{non} è frammentato in uscita.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Ip_es2_1.png}
		      \centering
	      \end{figure}

	      Il datagramma D2:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Ip_es2_2.png}
		      \centering
	      \end{figure}

	      Per il datagramma D3 si ha:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Ip_es2_3.png}
		      \centering
	      \end{figure}

	      Infine per D4:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Ip_es2_4.png}
		      \centering
	      \end{figure}

	      \pagebreak

	\item Una rete aziendale che contiene 8000 hosts e quattro server : web, email, ftp e DNS, adotta al suo interno indirizzi privati del gruppo 192.168.0.0/16, ed usa per i suoi \textbf{router NAT 6} degli indirizzi pubblici del gruppo 114.113.87.24/29.

	      Dire, giustificando la risposta, qual è il numero massimo di connessioni TCP uscenti da AS e relative agli host che possono essere contemporaneamente attive nell’AS.


	      \textbf{Soluzione}:
	      Il \textbf{numero massimo} di connessioni TCP relative agli host può essere limitato dagli host o dai router NAT.

	      I numeri di porta utilizzabili da ogni entità, host o router, è al massimo 65536,
	      ovvero tutti i numeri di porta, a cui bisogna sottrarre 1024, i numeri di porta noti, cioè 64512.

	      Dato che gli host sono 8000, con almeno 8000 indirizzi IP, il limite è dato dai router NAT\@. In particolare, ogni indirizzo IP pubblico dei router NAT deve avere assegnata una porta.

	      Gli indirizzi pubblici sono 6, ed il numero delle porte per ciascuno di essi è
	      65536, tutti i numeri di porta, meno 1024 porte, cioè 64512.

	      Pertanto, in totale si possono avere al massimo $64512 \times 6 = 387062$ possibili connessioni TCP uscenti dall'AS e relative agli hosts.
	      \label{sec:NATproblems}
	\item Cosa succede se un client FTP sotto NAT invia
	      RETR e il suo router NAT non accetta richieste di connessioni TCP?

	      \textbf{Soluzione}: Il router NAT blocca le connessioni in ingresso
	      perchè non ha una entry nella tabella.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Natp.png}
		      \includegraphics[scale=0.31]{Immagini/Natp1.png}
		      \centering
	      \end{figure}

	      Come ovviare? Con \textbf{FTP in passive mode}, il client inizierà entrambe le connessioni: \textbf{dati} e \textbf{controllo}.


	      \pagebreak

	\item In una applicazione P2P come può un peer chiedere di
	      utilizzare una certa porta per poter essere contattato?

	      \textbf{Solzuione}: Ogni applicazione \textbf{peer to peer} si basa infatti sulla possibilità di ogni peer A di essere in grado di iniziare una connessione TCP con un altro peer B. Se il peer B è sotto un router NAT, \textbf{non può accettare connessioni TCP e di conseguenza fare da server}.

	      Esistono vari meccanismi per far fronte a ciò:

	      \begin{enumerate}
		      \item Configurare \textbf{staticamente} il router NAT in modo tale che inoltri le richieste di connessioni che gli arrivano a una porta su un determinato server. Questo meccanismo è chiamato anche \textbf{port forwarding}.

		      \item  \textbf{Internet Gateway Device} o \textbf{IGD Protocol}. Permette agli host sotto NAT di effettuare \textbf{automaticamente} l'operazione di port forwarding utilizzando dei \textbf{lease times} per le porte.

		            \begin{figure}[!h]
			            \includegraphics[scale=0.35]{Immagini/Natp2.png}
			            \centering
		            \end{figure}

		      \item \textbf{Connection reversal}:  Il problema descritto sopra può essere evitato se peer A non è sotto NAT\@. In questo caso, A può contattare B attraverso un peer intermedio C, il quale a sua volta non è sotto NAT e con B ha stabilito una connessione TCP.

		            A può quindi chiedere a B, tramite il peer C, di iniziare una connessione TCP verso se stesso. Una volta che la connessione diretta tra di loro è stata stabilita A e B possono scambiarsi messaggi.

		            \begin{figure}[!h]
			            \includegraphics[scale=0.5]{Immagini/Natp3.png}
			            \centering
		            \end{figure}
	      \end{enumerate}

	      \pagebreak


\end{enumerate}

\pagebreak

\subsection{Struttura di un router}
\begin{flushleft}
	\textit{Com'è fatto un router?}
\end{flushleft}

Un router è \textbf{uno switch di terzo livello} composto da \textbf{quattro} componenti principali:

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Router_struc.png}
	\centering
	\caption{La struttura di un router.}
\end{figure}

\begin{itemize}
	\item \textbf{Porte di input}:
	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/In_port.png}
		      \centering
	      \end{figure}

	      Le porte di input svolgono diverse funzioni chiavi: sono il punto di sbocco nel router del collegamento fisico, decapsulano i frame in entrata e ne verificano la correttezza, consegnano i frame contenenti le informazioni dei protocolli di routing al processore di routing e, specialmente, nei router moderni, \textbf{effettuano il lookup nella forwarding table}.

	      Per far ciò sono dotate di un \textbf{processore di livello fisico} che analizza il segnale e lo traduce in bit, un \textbf{processore di livello link} che opera al livello di frame e un \textbf{buffer} per memorizzare i pacchetti in attesa di essere inoltrati alla switch fabric.

	      \pagebreak

	\item \textbf{Porte di output}:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.3]{Immagini/Out_port.png}
		      \centering
	      \end{figure}

	      Le \textbf{porte di output} memorizzano i pacchetti ricevuti dalla switch fabric e li trasmettono poi sul collegamento in uscita. In sostanza svolgono lo stesso lavoro delle porte di input ma al contrario.

	      Se il collegamento dovesse essere bidirezionale le porte di output saranno accoppiate con delle porte di input.

	\item \textbf{Switch fabric}:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.25]{Immagini/Switch_f.png}
		      \centering
		      \caption{Cross-bar switch, gli switch sono disposti a forma di matrice.}
	      \end{figure}

	      La \textbf{switch fabric} connette le porte di input e le porte di output. La velocità con cui vengono trasmessi i datagrammi  dalle porte di input a quelle di output influisce sulla dimensione delle code di input/output e sul ritardo complessivo nella consegna del datagramma.

	\item \textbf{Processore di routing}:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.25]{Immagini/Rout_tab.png}
		      \centering
		      \caption{Le tabelle d'instradamento sono il risultato dell'esecuzione degli algoritmi d'instradamento.}
	      \end{figure}

	      Il \textbf{processore di routing} esegue i protocolli di routing e costruisce ed aggiorna la tabella d'inoltro.

	      Le tabelle d'instradamento sono simili alle tabelle d'inoltro ma sono entità separate, una tabella d'instradamento infatti può contenere molteplici percorsi verso uno stesso router, una d'inoltro invece \textbf{solo uno}.

	      La tabella d'instradamento può essere creata \textbf{dinamicamente} mediante i protocolli di routing ma anche \textbf{staticamente} tramite l'aggiunta da parte dell'amministratore del router di \textbf{routes statiche}.

\end{itemize}

\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/Forw_tab2.png}
	\centering
	\caption{La forwarding table e il forwarding engine compongono la parte decisionale del router o data plane. La parte di controllo o control plane invece comprende i protocolli di routing e il routing engine che vanno ad alimentare la routing table.}
\end{figure}

\begin{flushleft}
	Alcune precisazioni:
\end{flushleft}

Una volta costruita, la \textbf{tabella d'inoltro} viene \textbf{copiata} e \textbf{inoltrata} a tutte le porte in modo tale che possano automaticamente effettuare la decisione di forwarding.

\theoremstyle{definition}
\begin{definition}
	Il \textbf{control plane} fornisce le informazione necessarie al \textbf{data plane} o \textbf{forwarding plane} per creare e aggiornale le tabelle d'inoltro in base ai cambiamenti di stato nella topologia della rete.
\end{definition}

\theoremstyle{definition}
\begin{definition}
	Il \textbf{data plane} è la parte del router che si occupa di inoltrare il traffico da un'interfaccia all'altra.
\end{definition}

\pagebreak

\subsection{Routing}
Il processo attraverso il quale si calcola il percorso da seguire per consegnare un datagramma è detto \textbf{routing}.

Il \textbf{routing} si distingue in due tipi: quando il datagramma deve essere consegnato a \textbf{un solo destinatario} si parlerà di \textbf{routing unicast}, quando ci sono più destinatari invece di \textbf{routing multicast}.

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Graph.png}
	\centering
	\caption{Una internet può essere rappresentata come un grafo pesato.}
\end{figure}

L'astrazione di rappresentare Internet come un grafo pesato consente di riassumere l'obbiettivo del processo di routing con una \textbf{domanda chiave}:
\begin{flushleft}
	\textit{Qual è il percorso di costo minimo tra due nodi?}
\end{flushleft}
Per rispondervi ogni router dovrà trovare il \textbf{percorso di costo minimo} tra \textbf{sè stesso} e \textbf{gli altri routers}.

In una rete con N routers ci sono $N \times (N - 1)$ percorsi minimi totali, poiché per ogni router ce ne sono $N - 1$ verso tutti gli altri escluso sè stesso.

\theoremstyle{definition}
\begin{definition}
	Un \textbf{algoritmo di routing} è un algoritmo che, dato un insieme di routers interconnessi, trova il \textbf{percorso di costo minimo}, nel caso di un grafo pesato, o, alternativamente, il percorso più breve da un router sorgente a un router destinazione.
\end{definition}

Gli \textbf{algoritmi di routing} possono essere divisi secondo i seguenti criteri:
\begin{itemize}
	\item \textbf{Statici}: l'operatore aggiorna \textbf{manualmente} le righe della tabella di routing. Sono usati per reti di piccole dimensioni.
	\item \textbf{Dinamici}: sono algoritmi che aggiornano \textbf{dinamicamente} la tabella di routing in base ai cambiamenti nella topologia della rete e al traffico.
	\item \textbf{Decentralizzati}: gli algoritmi di routing locali \textbf{non} possiedono l'intera \textbf{conoscenza} della \textbf{topologia della rete}. Possiedono solo le informazioni relative ai costi dei cammini verso i nodi adiacenti al nodo sorgente.

	      \pagebreak

	      Il cammino di costo minimo viene calcolato \textbf{iterativamente} e in modo \textbf{distribuito}.
	\item \textbf{Globali}: ricevono in input la \textbf{conoscenza completa} circa la topologia della rete. Il cammino di costo minimo può essere calcolato in modo \textbf{centralizzato} (e.g.\  da un server) o \textbf{distribuito}.
\end{itemize}

\subsubsection{DVR ed Equazione di Bellman-Ford}

\theoremstyle{definition}
\begin{definition}
	Un \textbf{albero di costo minimo} è un albero con il router sorgente che fa da radice e che visita tutti gli altri nodi dell'albero seguendo sempre il percorso meno costoso tra quelli possibili.
\end{definition}

Nel \textbf{distance vector routing} ogni nodo crea il proprio \textbf{albero di costo minimo} con le sole informazioni che possiede circa i nodi a lui vicini. Gli \textbf{alberi incompleti} così ottenuti vengono inoltrati da ogni nodo ai suoi vicini. Dopo un certo numero di iterazioni l'algoritmo \textbf{converge} restituendo l'\textbf{albero di costo minimo}.

Il fulcro del \textbf{distance vector routing} è l'\textbf{equazione di Bellman-Ford}:

{\centering $ \displaystyle D_{xy} =  min(D_{xy},(C_{xz} + D_{zy}))$ \par }

Quest'equazione viene usata per trovare il cammino di costo minimo tra un nodo sorgente X e un nodo destinazione Y attraverso i nodi intermedi.

\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/Bell.png}
	\centering
	\caption{Rappresentazione grafica.}
\end{figure}

\theoremstyle{definition}
\begin{definition}
	Un \textbf{vettore distanza} è un array monodimensionale che rappresenta un albero di costo minimo.
\end{definition}

\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/Vect.png}
	\centering
\end{figure}

\pagebreak

Descriviamo ora il \textbf{distance vector algorithm}:

\begin{enumerate}
	\item Ogni nodo invia una copia del proprio vettore distanza
	      a ciascuno dei suoi vicini.
	\item Quando un nodo x riceve un nuovo vettore distanza DV, da qualcuno dei sui vicini, lo salva e usa la formula di Bellman-Ford per aggiornare in proprio vettore distanza come segue:
	      \begin{center}
		      $\displaystyle D_{xy} = min \{c(x,v) + D_{vy}\} \ \forall v \in N_{eighbor}(x)$
	      \end{center}
	      \begin{enumerate}
		      \item Dove $D_{xy}$ è pari alla stima del costo minimo dal nodo x al nodo y, x mantiene il vettore distanza $D_{x} = [D_{xy} \ \forall y \in N]$.
		      \item Il nodo x conosce il costo verso ciascun vicino v: c(x,v).
		      \item Ogni nodo mantiene i vettori distanza dei suoi vicini. Per ogni
		            vicino v, il generico nodo x mantiene $D_{v} = [D_{vy}  \ \forall y \in N ]$.
	      \end{enumerate}
	\item Tutti i nodi continuano a cambiare i propri DV in
	      maniera asincrona, finché ciascuna stima dei costi $D_{xy}$ converge al costo minimo $d_{x}(y)$.
\end{enumerate}
L'algoritmo è \textbf{decentralizzato} e \textbf{dinamico}: è \textbf{iterativo} e \textbf{asincrono}, viene eseguito da ogni nodo in modo indipendente, e ogni iterazione locale è causata da:

\begin{itemize}
	\item Il \textbf{cambio del costo di uno dei collegamenti locali}.
	\item La \textbf{ricezione da qualche vicino di un vettore distanza aggiornato}.
\end{itemize}

Ogni nodo notifica i suoi vicini solo quando il proprio DV cambia; i vicini avvisano i vicini \textbf{solo se necessario}.

\begin{figure}[!h]
	\includegraphics[scale=0.24]{Immagini/DV_al.png}
	\centering
	\caption{L'algoritmo schematizzato.}
\end{figure}

\pagebreak

\begin{flushleft}
	\textbf{Esempio}:
\end{flushleft}

Sia questa la \textbf{configurazione iniziale} dei vettori distanza dei nodi di una rete.

\begin{figure}[!h]
	\includegraphics[scale=0.33]{Immagini/DV_es.png}
	\centering
	\caption{Configurazione iniziale.}
\end{figure}

Supponiamo si susseguano i due eventi:

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.32]{Immagini/DV_es1.png}
	\includegraphics[scale=0.32]{Immagini/DV_es2.png}
\end{figure}

Si osservi come cambiano i distance vectors.

\pagebreak

Pseudocodice del \textbf{distance vector routing}:

\begin{lstlisting}
Distance_Vector_routing() {
	// Inizializzazione: 
	// creazione dei vettori 
	// istanza iniziali del nodo
	
	D[me_stesso] = 0;
	
	for(y = 1 to N) {
		
		if($y \in nodi\_vicini$) 
			
			D[y] = c[me_stesso][y];
			
		else $D[y] = \infty$;
	}
	
	speidisci il vettore {D[1], $\dots$, D[n]} a tutti i vicini;
	
	repeat(sempre) {
	
	// Aggiornamento:
	// usare il vettore ricevuto 
	// dal nodo vicino per aggiornare
	// quello locale
	
		wait(un vettore D_w da un vicino w o un qualsiasi 
			cambiamento negli archi);
			
		for (y = 1 to N) 
			
			D[y] = min_v [ c[me_stesso][v]+Dv[y] ];
		
		
		if (cambiamento nel vettore) 
			
				speidisci il vettore {D[1], $\dots$, D[n]} a tutti i vicini;
	
	}
}
\end{lstlisting}

\pagebreak

C'è però un \textbf{problema}, con il routing basato su distance vectors i decrementi di costo si diffondono rapidamente tra i nodi mentre i \textbf{peggioramenti} del costo si diffondono molto più \textbf{lentamente}. Ad esempio in caso di guasto:

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.32]{Immagini/C2i.png}
	\caption{Count to infinity.}
\end{figure}

Supponiamo che due i due routers in figura, A e B, siano collegati alla rete X. Se improvvisamente dovesse saltare il collegamento tra X e A, e A aggiornasse il suo DV con il peggioramento del costo, ma non inviasse \textbf{immediatamente} a B il suo DV aggiornato e anzi B lo inviasse ad A, A crederebbe che B abbia trovato un altro modo per raggiungere X. Di conseguenza A aggiornerebbe il suo DV e lo invierebbe a B, che lo aggiornerebbe a sua volta e così via, fino ad arrivare a un costo pari a \textbf{infinito}.

Questo scenario è chiamato \textbf{count to infinity}.

Una possibile soluzione a questo problema è chiamata \textbf{split horizon}: prevede che la tabella inviata da un router ad un suo vicino contenga solamente una riga per ogni destinazione raggiungibile passando per un router \textbf{diverso da quello a cui sta inviando la tabella}. Ad esempio: se B ritiene che il costo minore per raggiungere X passi da A, non invierà ad A tale informazione, ovvero $D_{B}[X]$.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{Immagini/split-horizon.jpg}
	\caption{Split horizon.}
\end{figure}

\pagebreak

Un'altra soluzione è chiamata \textbf{poisoned reverse}: consiste, nell'inviare, attraverso l'interfaccia da cui si hanno ricevuto informazioni circa un percorso, al posto del reale costo, il valore infinito. Nel nostro esempio quindi B invierà ad A $D_{B}[X] = \infty$, avendo ottenuto l'informazione circa il cammino di costo minore verso X dall'interfaccia che dà verso A.

\textbf{\underline{N.B.}} Poisoned reverse non risolve completamente il problema del count to infinity, se infatti avessimo un guasto che coinvolge \textbf{tre o più nodi} tale strategia si rivelerebbe inefficace.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.35]{Immagini/Three_nodes.png}
	\caption{Instabilità a tre nodi.}
\end{figure}

\subsubsection{LSR ed Algoritmo di Dijkstra}
Il \textbf{link state algorithm} è un algoritmo di routing \textbf{globale}, la topologia della rete deve essere infatti \textbf{nota} ad ogni nodo. Calcola \textbf{iterativamente} il cammino di costo minimo da un nodo di origine verso tutti gli altri nodi della rete. La mappa completa della rete posseduta da ogni nodo si chiama \textbf{Link State Database} ed è unica per l'intera rete. I nodi la usano per creare il proprio \textbf{albero di costo minimo}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.62]{Immagini/LSDB.png}
\end{figure}

\pagebreak

L' \textbf{LSDB} viene creato attraverso un'operazione detta \textbf{flooding}, durante la quale ogni nodo invia a tutti i suoi vicini un \textbf{Link State Packet}, contenente una coppia di informazioni: l' \textbf{identità del nodo vicino} e \textbf{il costo del collegamento}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.45]{Immagini/Flooding.png}
	\caption{Flooding.}
\end{figure}


L'\textbf{LSP} viene inviato attraverso ogni interfaccia del nodo.

Quando un nodo riceve un \textbf{LSP} da una delle sue interfacce ne confronta il \textbf{numero di sequenza} con quello che eventualmente ha già, se dovesse risultare più vecchio lo \textbf{scarta}, altrimenti, se invece dovesse risultare più recente, scarta la vecchia copia, qualora sia presente, memorizza la nuova e ne invia una copia a tutte le sue interfacce tranne quella da cui l'ha ricevuta.

Con tutti gli \textbf{LSP} ricevuti ogni nodo è in grado di crearsi la sua copia dell' \textbf{LSDB}.

Per crearsi poi il proprio albero di costo minimo utilizzando l'\textbf{LSBD} ogni nodo dovrà utilizzare l' \textbf{algoritmo di Dijkstra}.

Prima di presentarlo mostriamo un po' di \textbf{notazione}:
\begin{itemize}
	\item \textbf{c(x,y)}: indica il costo del collegamento dal nodo x al
	      nodo y, è pari ad $\infty$ se i due nodi non sono adiacenti.
	\item \textbf{D(v)}: costo del cammino dal nodo origine al nodo
	      destinazione v per quanto riguarda l’iterazione corrente.
	\item \textbf{p(v)}: immediato predecessore del nodo v lungo il
	      cammino.
	\item \textbf{N'}: sottoinsieme di nodi per cui il cammino a
	      costo minimo dall’origine è definitivamente noto.
\end{itemize}

\pagebreak

\begin{verbatim}
1 N' = {u}
2 Per tutti i nodi v : se v e u sono vicini
3 allora D(v) = c(u,v)
4 altrimenti D(v) = inf
5
6 Loop: finché tutti i nodi non sono in N'
7  trova w non in N' tale che D(w) sia minimo
8  aggiungi w a N'
9  aggiorna D(v) per tutti v adiacenti a w e non in N' :
10 D(v) = min( D(v), D(w) + c(w,v) )
11
12 #il nuovo costo verso v è il vecchio costo verso v oppure il
13 #costo del cammino minimo noto verso w più il costo da w a v
\end{verbatim}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.3]{Immagini/Dk2.png}
	\includegraphics[scale=0.3]{Immagini/Dk.png}
\end{figure}


\begin{itemize}
	\item \textbf{Complessità dei messaggi}:
	      \begin{itemize}
		      \item \textbf{LS}: con n nodi ed E
		            archi, comporta l’invio di
		            $O(n \times E)$ messaggi.
		      \item \textbf{DV}: ha un tempo di convergenza variabile.
	      \end{itemize}
	\item \textbf{Velocità di convergenza}:
	      \begin{itemize}
		      \item \textbf{LS}: ha complessità $O(n^2)$. Può subire oscillazioni di velocità.
		      \item \textbf{DV}: può convergere lentamente, presentare cicli d’instradamento e può
		            verificarsi il problema del \textbf{count to infinity}.
	      \end{itemize}
	\item \textbf{Robustezza}: cosa avviene se
	      un router funziona male?
	      \begin{itemize}
		      \item \textbf{LS}: un router può comunicare via
		            broadcast un costo sbagliato solo
		            per qualcuno dei suoi archi
		            ma non per tutti gli altri. I nodi si occupano di calcolare
		            \textbf{soltanto} le proprie tabelle.
		      \item \textbf{DV}:  un nodo può comunicare
		            cammini a costo minimo
		            errati a tutte le destinazioni. La tabella di ciascun nodo può
		            essere usata dagli altri. Un calcolo errato si può
		            \textbf{diffondere} per l’intera rete.
	      \end{itemize}
\end{itemize}

\pagebreak

\subsection{Routing gerarchico}
\begin{figure}[!h]
	\includegraphics[scale=0.85]{Immagini/Internet_Concept.png}
	\centering
	\caption{Un modello concettuale di Internet.}
\end{figure}

La visione di \textbf{Internet} come una rete costituita da un insieme di router omogenei e
interconnessi è semplicistica e molto lontana dalla realtà. Come già visto in precedenza la topologia di Internet si è evoluta nel corso degli anni, assumendo attualmente una struttura \textbf{gerarchica} con dorsali multiple gestite da aziende private.

Sopracitate dorsali sono connesse da infrastrutture fisiche chiamate \textbf{peering points}.

Nella topologia attuale di Internet i router sono organizzati in \textbf{sistemi autonomi} o \textbf{AS}.

\theoremstyle{definition}
\begin{definition}
	Un \textbf{AS} è un gruppo connesso di una o più reti IP gestite da uno o più
	operatori che adottano le \textbf{stesse politiche di routing} verso gli altri AS\@.
	In genere un AS è gestito da un ISP o da un’azienda.
\end{definition}

Gli AS decidono autonomamente i protocolli e le politiche di routing che
intendono adottare al loro interno. I protocolli di routing \textbf{interni} ad un AS sono detti \textbf{Interior Gateway Protocol} o \textbf{IGP}. I protocolli di routing tra \textbf{AS diversi} sono detti invece \textbf{Exterior Gateway Protocol} o \textbf{EGP}.

I router interni a un AS sono sotto uno stesso controllo amministrativo e usano lo \textbf{stesso} protocollo IGP, i più comuni sono il \textbf{RIP} e l'\textbf{OSPF}.

Esistono numerosi protocolli di routing IGP e ogni AS è libero di sceglierne uno. Invece per gli EGP è d'obbligo che se ne abbia \textbf{solamente} uno che gestisca il routing tra gli AS: il \textbf{BGP} o \textbf{Border Gateway Protocol}.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.37]{Immagini/ASes.png}
	\centering
\end{figure}

Ad ogni AS, piccolo o grande che sia, viene assegnato un un numero identificativo univoco di 16 bit dall'ICANN: l'\textbf{autonomous system number} o \textbf{ASN}.

Gli AS tuttavia non sono classificati in base alla loro dimensione ma in base al \textbf{modo in cui sono collegati agli altri AS}. Possiamo avere:

\begin{itemize}
	\item \textbf{AS stub}: sono gli AS collegati solo a un altro AS\@. Gli unici dati che vi passano attraverso sono dati che hanno come destinazione o sorgente l'AS stesso.
	\item \textbf{AS multihomed}: come AS stub ma sono collegati a più di un altro AS\@.
	\item \textbf{AS di transito}: sono AS che sono collegati ad altri AS e consentono il transito del traffico dati. Le \textbf{dorsali} e i \textbf{network providers} sono esempi di AS di transito.
\end{itemize}

Gli INTRA-AS o IGP routing protocols determinano \textbf{autonomamente} rotte per le
destinazioni interne ad un AS:

\begin{itemize}
	\item \textbf{Routing Information Protocol} o \textbf{RIP}: basato su DV.
	\item \textbf{Open Shortest Path First} o \textbf{OSPF}: basato su LS.
\end{itemize}

Gli INTRA-AS e gli INTER-AS routing protocols determinano \textbf{collaborativamente} le rotte per le destinazioni esterne ad un AS.

\begin{itemize}
	\item \textbf{Border Gateway Protocol} o \textbf{BGP}: è lo standard \textit{de facto}. Consente di conoscere le destinazioni raggiungibili attraverso sistemi
	      autonomi \textbf{vicini}. Propaga le informazioni di raggiungibilità ai router interni del proprio AS e determina percorsi buoni verso le sottoreti di destinazione.
\end{itemize}

\pagebreak

\subsubsection{RIP}
Il \textbf{RIP} o \textbf{Routing Information Protocol} è un protocollo IGP, ogni router di un AS che ne fa uso implementa il \textbf{DV algorithm}.

I costi sono misurati in \textbf{hops}. Un \textbf{hop}, o salto, non indica però il numero di router da attraversare bensì il numero di \textbf{sottoreti interne all'AS}.

I \textbf{costi} indicano quindi il \textbf{numero di sottoreti che il pacchetto deve attraversare} per andare dal router sorgente al router di destinazione, \textbf{esclusa} la sottorete sorgente.

In RIP il \textbf{costo massimo di un percorso} è di \textbf{15 hops}, il che significa che il valore 16 rappresenta l'$\infty$ del \textbf{poisoned reverse}, per questa ragione è possibile utilizzare RIP solamente negli AS il cui \textbf{diametro non supera i 15 hops}.

\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/RIP.png}
	\includegraphics[scale=0.4]{Immagini/RIPtab.png}
	\centering
\end{figure}

La terza colonna delle tabelle d'inoltro non è necessaria per inoltrare il pacchetto ma viene usata per \textbf{aggiornare} la tabella d'inoltro quando ci sono modifiche nel percorso.

RIP è implementato per mezzo di un \textbf{processo demone}: \texttt{routed}, sempre attivo in ascolto sulla porta nota \textbf{520 UDP}.

Il \textbf{protocollo RIP} lavora a livello applicazione ma crea tabelle d'inoltro per il livello rete, si basa su una coppia di processi, un client e un server che si scambiano messaggi di richiesta e risposta.

I \textbf{messaggi di richiesta} vengono inviati dai router \textbf{appena accesi} o dai router che hanno delle voci \textbf{scadute} in memoria e possono riguardare delle voci specifiche o tutte quelle disponibili.

I \textbf{messaggi di risposta} possono essere \textbf{sollecitati}, nel caso in cui vengano inviati come risposta a un messaggio di richiesta, o \textbf{non sollecitati}, nel caso in cui vengano inviati periodicamente ogni \textbf{30 secondi}.
A pagina seguente ne troviamo il funzionamento.

\pagebreak

\begin{enumerate}
	\item Un nodo invia la sua tabella di inoltro.
	\item Il nodo R riceve dal vicino V $D_{v}[y]$ e pone
	      $D_{R}[y] = 1 + D_{V}[y]$
	\item Il nuovo percorso viene inserito nella tabella se:
	      \begin{itemize}
		      \item Non è presente nella tabella.
		      \item Se $D_{Rold}[y] \geq 1 + D_{V}[y]$ e $nextHop_{Rold}[y] \neq V$, ovvero il costo ricevuto è inferiore a quello del vecchio percorso e il nextHop corrispondente è diverso.
		      \item Se $nextHop_{Rold}[y] = V$, il percorso era già noto essendo stato già
		            annunciato dal router V ma il costo è incrementato o diminuito.
	      \end{itemize}
\end{enumerate}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{Immagini/RIP_ex.png}
\end{figure}

\pagebreak

\subsubsection{OSPF}
L'\textbf{Open Shortest Path First} o \textbf{OSPF} è un protocollo di routing \textbf{IGP} basato sull'instradamento \textbf{link state}. L'OSPF è un protocollo \textbf{aperto} e la sua specifica è disponibile all'interno dell'RFC 2328.

Le \textbf{metriche} del costo degli archi (e.g.\  throughput, RTT, affidabilitàn hops ecc$\dots$) e del costo massimo sono \textbf{decise dall'amministratore}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.45]{Immagini/OSPF.png}
	\includegraphics[scale=0.45]{Immagini/OSPF1.png}
\end{figure}

L'OSPF al contrario del RIP è progettato per operare in AS di \textbf{tutte le dimensioni}. Per evitare che l'operazione di \textbf{flooding}, prevista dal \textbf{LS algorithm}, generi un volume di traffico molto grande in AS di elevate dimensioni OSPF usa un altro livello di gerarchia: l'\textbf{area}. Un AS molto vasto può quindi essere diviso in aree, ognuna con un ID, che saranno poi collegate da un'area detta \textbf{back-bone area} o \textbf{area dorsale}, con ID = 0, il cui compito è quello di collegare tra di loro le varie aree, in modo tale che tutti i router, appartenenti a varie aree, possano costruire l'LSDB.
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.45]{Immagini/Area.png}
\end{figure}

I messaggi OSPF viaggiano all'interno di datagrammi IP con campo \textbf{proto} impostato a \textbf{89}. \textbf{\underline{N.B.}} RIP era un processo applicativo UDP.

\pagebreak

\subsubsection{BGP}
Il \textbf{Border Gateway Protocol} o \textbf{BGP} è l'unico protocollo EGP attualmente utilizzato in Internet, consente la comunicazione tra AS differenti.

Ne esistono \textbf{due varianti} chiamate rispettivamente \textbf{external BGP} ed \textbf{internal BGP}. La prima è installata \textbf{solo} sui router di confine dell'AS, la seconda su tutti i router dell'AS, \textbf{compresi} quelli di confine. In totale quindi i router di confine dovranno eseguire \textbf{tre} protocolli: \textbf{eBGP}, \textbf{iBGP} e un protocollo IGP e i router non di confine invece \textbf{due}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{Immagini/ieBGP.png}
\end{figure}

Due router che comunicano tramite BGP creano una \textbf{connessione TCP semipermanente} alla porta nota \textbf{179} e vengono chiamati \textbf{peer BGP} o \textbf{speaker BGP}. La variante \textbf{external BGP} permette a due router di confine di AS diversi di formare coppie di speaker BGP e di scambiarsi messaggi. Le connessioni TCP instaurate da BGP vengono definite \textbf{sessioni}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.35]{Immagini/eBGP.png}
	\caption{In figura i messaggi di aggiornamento eBGP, il numero corrisponde al router che li ha mandati. Le informazioni circa le reti interne al proprio AS vengono ricavate dalla \textbf{tabella d'inoltro intradominio}.}
\end{figure}

\pagebreak

Sussistono però ancora \textbf{due} problemi fondamentali:

\begin{enumerate}
	\item Alcuni router di confine non sanno come instradare un pacchetto a un AS che non è vicino, nella figura precedente ad esempio R5 non sa come raggiungere nè AS4 nè AS3.
	\item Nessuno dei router interni sa come inoltrare un pacchetto a un AS esterno.
\end{enumerate}

La versione interna del BGP risolve questi problemi.

\textbf{iBGP} viene eseguito tra tutte le coppie di router, se un AS ha un solo router non ci può essere nessuna sessione iGBP, e utilizza anch'esso connessini TCP sulla porta 179. Se ci sono n router in un AS ci saranno  $ \binom{n}{2} = \frac{(n \times (n - 1))}{2}$ connessioni TCP.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.4]{Immagini/iBGP.png}
	\caption{In figura i messaggi di aggiornamento iBGP, il numero corrisponde al router che li ha mandati. Le informazioni circa le reti degli altri AS vengono propagate dai router di confine ai router interni.}
\end{figure}

Il router R1 in figura dopo aver ricevuto il messaggio d'aggiornamento da R2 combina tali informazioni circa la raggiungibilità di AS3 a quelle che già possedeva circa AS1 e invia un nuovo messaggio d'aggiornamento a R5. R5 adesso saprà come raggiungere AS1 e AS3.

Ogni router combina le informazioni ricevute tramite \textbf{iBGP} e \textbf{eBGP}, questo processo continua fino alla \textbf{convergenza}.

Le informazioni ottenute con entrambe le versioni di BGP non sono usate di per sè per l'instradamento dei pacchetti ma sono \textbf{inserite} all'interno delle tabelle d'inoltro intra-dominio.

\pagebreak

Le tabelle d'inoltro così ottenute diventerebbero \textbf{enormi} nel caso della Internet globale.

Per questo motivo BGP utilizza i prefissi, in formato CIDR, come identificatori della destinazione e consente l'aggregazione di tali prefissi, anche se uno o più prefissi aggregati richiedono un percorso separato è comunque possibile aggregarli usando il principio della \textbf{longest matching mask}.

I \textbf{protocolli di routing IGP} associano ad una destinazione \textbf{solo due} informazioni, costo e next hop.

Per il routing inter-domain solo due attributi \textbf{non bastano}, vengono aggiunte informazioni aggiuntive chiamate \textbf{attributi del percorso}.

Le rotte inter-domain sono quindi \textbf{identificate} dal \textbf{prefisso} e \textbf{dagli attributi}.

I due attributi più importanti sono:

\begin{itemize}
	\item \textbf{AS\_PATH}: esprime la sequenza degli AS attraversati nel path pubblicizzato
	      dall’advertisement (\textbf{messaggio d'aggiornamento}).

	      Usato per scegliere tra più percorsi per lo stesso prefisso e scartare advertisement già ricevuti.

	\item \textbf{NEXT\_HOP}: indica l’interfaccia del gateway da usare per il prefisso
	      \textbf{pubblicizzato}. Nell'esempio precedente R1 pubblicizzava ad R5 il prefisso relativo alle reti di AS3.

	      Di seguito un estratto dell'RFC 1163:

	      \textit{"The NEXT\_HOP path attribute defines the IP address of the border router that should be used as the next hop to the
		      networks listed in the UPDATE message.}

	      \textit{This border router must
		      belong to the same AS as the BGP peer that advertises it."}
\end{itemize}

Un \textbf{gateway router} usa delle regole chiamate \textbf{politiche di importazione} per accettare o rifiutare un advertisement.

Un gateway infatti può ricevere più rotte per lo stesso prefisso.

Riportiamo di seguito la \textbf{sequenza di regole principale} per la scelta dei percorsi:

\begin{enumerate}
	\item Attributo di preferenza locale: \textbf{LOCAL-PREF}, è scelta da
	      amministratore o impostato dai router dell’AS.

	      Vengono
	      selezionati i percorsi con i valori più alti per questo attributo. \textit{(e.g.\  per evitare di passare dalla rete di un competitore)}
	\item \textbf{AS\_PATH} più breve.
	\item Interfaccia \textbf{NEXT\_HOP} più vicina.
\end{enumerate}

\pagebreak

\subsection{IPv6}

Sebbene con l'utilizzo di routers NAT e di indirizzi privati si sia riusciti ad allungare la vita di Ipv4, sarà inevitabile il passaggio, nell'immediato futuro, agli \textbf{indirizzi IPv6}.

Lo scopo principale di IPv6 è sostanzialmente quello di \textbf{aumentare} la dimensione dello spazio degli indirizzi, un indirizzo IPv6 infatti è composto da 128 bit, contro i 32 dell'IPv4. Lo spazio degli indirizzi di IPv6 è più grande di quello di IPv4 di $2^{96}$ volte.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.45]{Immagini/IPv6.png}
\end{figure}

L'incremento del numero totale degli indirizzi possibili non è però l'unico vantaggio ad essere apportato da IPv6:

\begin{itemize}
	\item \textbf{Miglior formato dell'intestazione}: in un indirizzo IPv6 le opzioni sono \textbf{separate} dall'intestazione di base e sono collocate tra essa e i dati.
	\item \textbf{Frammentazione del pacchetto gestita dal router mittente}: in modo tale da alleggerire il carico di lavoro sui routers intermedi. Il protocollo ICMP è usato per ottenere informazioni circa l'MTU.
	\item \textbf{Velocizzazione dell'operazione di forwarding}: ottenuta impostando un lunghezza fissa dell'intestazione, fissata a 40 byte, ed \textbf{eliminando} la checksum.
	\item \textbf{Classe di traffico ed etichetta di flusso}: sono campi dell'intestazione di base del datagramma IPv6 utilizzati per la \textbf{differenziazione del traffico}. Permettono di caratterizzare il pacchetto e applicarvi delle politiche. Facilitano quindi la gestione della \textbf{qualità del servizio}, aspetto molto importante per gli ISP\@. Il campo classe di traffico sostituisce il campo Type Of Service di IPv4. L'etichetta di flusso permette di gestire i dati in viaggio sotto forma di un \textbf{flusso di datagrammi}.
\end{itemize}

L'adozione dell'IPv6 comporta però non solo che si debba \textbf{ridisegnare} il formato dei datagrammi UDP e dei segmenti TCP, che si debbano \textbf{modificare} alcuni protocolli ausiliari come ad esempio ICMP ma \textbf{soprattutto} che si debbano far \textbf{coesistere} IPv4 e IPv6 fino al completamento della transizione.

\pagebreak

Presentiamo di seguito una strategia chiamata \textbf{Dual Stack}.

La \textbf{strategia Dual Stack} prevede che fino al completamento della transizione tutti gli host abbiano \textbf{due pile di protocolli} per la comunicazione in rete e di conseguenza due interfacce.

Ma come consentire ad un host di ricevere un pacchetto IPv6 ed inoltrarlo verso una rete IPv4, oppure di inoltrare un pachetto IPv6 attraverso una rete IPv4?

Con il \textbf{tunnelling}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.45]{Immagini/Tunnelling.png}
\end{figure}

Il tunnelling consiste nell'incapsulare i datagrammi IPv6 dentro un datagramma IPv4.

In sostanza si dota il datagramma IPv6 di un header IPv4, consentendone quindi il transito sulle reti IPv4. \textbf{\underline{N.B.}} Da notare il primo e l'ultimo router del percorso IPv4.

\subsection{Esercizi}


\begin{enumerate}
	\item In una rete i cui router utilizzano il protocollo distance vector con
	      poisoned reverse, il router R è collegato solo a un router V, il costo del
	      collegamento R-V è 3 e R ha calcolato che la sua distanza minima per
	      Z è 8.

	      Indicare, giustificando la risposta,in che modo R aggiorna il
	      suo vettore delle distanze se V gli comunica che la sua nuova distanza
	      da Z è 7.

	      \textbf{Soluzione}:
	      \begin{figure}[!h]
		      \centering
		      \includegraphics[scale=0.45]{Immagini/Sol_rout.png}
	      \end{figure}

	      \pagebreak

	      \begin{figure}[!h]
		      \centering
		      \includegraphics[scale=0.45]{Immagini/Rout_imm.png}
	      \end{figure}

	\item Sia data la rete con topologia raffigurata in figura e si
	      ipotizzi che sia in uso l’algoritmo di distance vector.
	      Tutti i distance vector sono stati calcolati in tutti i nodi
	      e ad un certo istante il link da E a B va giù (guasto).
	      Approssimativamente quanti messaggi distance vector
	      il node E manderà a seguito del guasto del link?

	      \textbf{Soluzione}:
	      \begin{figure}[!h]
		      \centering
		      \includegraphics[scale=0.4]{Immagini/Sol_rout1.png}
	      \end{figure}

	      \begin{figure}[!h]
		      \centering
		      \includegraphics[scale=0.45]{Immagini/Rout_imm.png}
	      \end{figure}
	\item Data la rete con topologia raffigurata in figura, mostrare l’evoluzione
	      dell’algoritmo di Dijkstra per il calcolo
	      del cammino a costo minimo dal nodo
	      E a tutte le destinazioni.

	      \textbf{Soluzione}:
	      \begin{figure}[!h]
		      \centering
		      \includegraphics[scale=0.4]{Immagini/Sol_rout2.png}
	      \end{figure}

	      \pagebreak

	      \begin{figure}[!h]
		      \centering
		      \includegraphics[scale=1.3]{Immagini/Eserout.png}
	      \end{figure}
	\item Consideriamo il sistema autonomo AS0 in figura, in cui B ed E sono gli unici
	      due gateway e i cui nodi utilizzano OSPF come protocollo di routing intra-AS
	      e non utilizzano alcuna preferenza locale per BGP.

	      Supponiamo che al tempo t, sia B che E comunichino agli altri router di AS0
	      la raggiungibilità di due sistemi autonomi esterni AS1 e AS2.

	      In particolare, B
	      trasmette un advertisement di AS1 con $|AS-PATH| = 8$ e uno di AS2 con $|AS-PATH| = 6$, mentre E trasmette un advertisement di AS1 e uno di AS2 entrambi con $|AS-PATH| = 8$.

	      Indicare, giustificando la risposta,  su quale collegamento A, C, D e F
	      inoltrano i pacchetti destinati ad AS1 e ad AS2 dopo avere ricevuto tutti gli
	      advertisement sopra menzionati.

	      \textbf{Soluzione}:

	      Dato che i nodi non utilizzano alcuna preferenza locale, per AS2 sceglieranno tutti il percorso pubblicizzato da B poiché ha $|AS-PATH|$ minore di quello pubblicizzato da E e inoltreranno quindi i pacchetti destinati ad AS2 nel modo seguente:

	      A sul collegamento AC,\newline
	      C sul collegamento CB,\newline
	      D sul collegamento DB,\newline
	      F sul collegamento FD.\newline

	      Nel caso di AS1, dato che i percorsi pubblicizzati da B ed E hanno uguale $|AS-PATH|$, ogni nodo sceglierà il percorso pubblicizzato dal gateway meno distante:

	      A sul collegamento AC,\newline
	      C sul collegamento CB,\newline
	      D sul collegamento DB o DF,\newline
	      F sul collegamento FE.

	      \pagebreak
\end{enumerate}

\section{Lo strato di collegamento}
Nello stack protocollare TCP/IP lo \textbf{strato di collegamento} si trova sotto lo strato di rete.

\begin{figure}[!h]
	\includegraphics[scale=0.2]{Immagini/Ip.png}
	\centering
	\caption{Lo strato di collegamento dello stack protocollare TCP/IP.}
\end{figure}

\begin{figure}[!h]
	\includegraphics[scale=0.58]{Immagini/Link.png}
	\centering
	\caption{Comunicazione a livello di collegamento.}
\end{figure}

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Link1.png}
	\centering
\end{figure}

Abbiamo visto, in precedenza, come la comunicazione nei livelli di applicazione, trasporto e rete fosse \textbf{end-to-end}, nel livello di collegamento invece è da \textbf{nodo a nodo}.

In questa sezione ci riferiremo agli host e ai router con \textbf{nodi} e alle reti nel mezzo con \textbf{collegamenti}.

I collegamenti possono essere di \textbf{due tipi}:

\begin{itemize}
	\item \textbf{Punto-punto}: è un collegamento dedicato solo a \textbf{due dispositivi}. (\textit{e.g.\  telefonata da fisso}).
	\item \textbf{Broadcast}: è collegamento \textbf{condiviso tra più dispositivi}.
	      Quando un nodo trasmette un frame, il canale lo diffonde e tutti gli altri nodi ne ricevono una copia.
\end{itemize}

Il livello di collegamento può essere quindi diviso in \textbf{due} sottolivelli:
il \textbf{Data Link Control} o \textbf{DLC} e il \textbf{Medium Access Control} o \textbf{MAC}. Nei collegamenti punto-punto troviamo \textbf{solo} il DLC mentre in quelli broadcast troviamo \textbf{entrambi}.

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/DLCMAC.png}
	\centering
\end{figure}

Le unità di dati scambiate dai protocolli di livello collegamento saranno invece chiamate \textbf{frame}, e vengono mosse da un nodo a ad un altro nodo ad esso adiacente su un singolo link di comunicazione. Un frame contiene un \textbf{campo dati}, un'\textbf{intestazione} ed un eventuale \textbf{trailer} e può essere gestito da \textbf{diversi} protocolli, per ogni collegamento attraversato: per esempio potrebbe essere gestito da Ethernet sul primo collegamento, da PPP sull’ultimo e da un protocollo WAN nel collegamento intermedio.

I \textbf{servizi} erogati dai protocolli del livello di link
possono essere \textbf{differenti}, ad esempio infatti, non tutti i protocolli forniscono un servizio di consegna affidabile.

\pagebreak

Il sottolivello DLC si occupa delle procedure necessarie per la comunicazione di due nodi adiacenti, \textbf{indipendentemente} dal fatto che il collegamento sia punto-punto o broadcast, e offre i seguenti servizi:

\begin{itemize}
	\item \textbf{Framing}: i protocolli del livello collegamento incapsulano i datagrammi del livello di rete all’interno di un \textbf{frame}. Consente di \textbf{separare} i vari messaggi durante la trasmissione da una sorgente a una destinazione. Per identificare origine e destinatario sono utilizzati indirizzi MAC, \textbf{diversi} rispetto agli indirizzi IP.

	      Normalmente si predilige la \textbf{suddivisione} di un frame in frames più piccoli, anche se fosse possibile trasmettere un unico frame. Ciò \textbf{facilita} il \textbf{controllo degli errori}, se c'è un errore su un singolo bit infatti non si dovrà ritrasmettere tutto il frame ma solo il frame che lo contiene, e il \textbf{controllo di flusso}.
	\item \textbf{Consegna affidabile}: è considerata non necessaria nei collegamenti che presentano un basso numero di errori sui bit (e.g.\  \textit{fibra ottica, cavo coassiale e doppino intrecciato}), è spesso utilizzata invece nei collegamenti soggetti a elevati tassi di errori. (\textit{e.g.\  collegamenti wireless})
	\item \textbf{Controllo di flusso}: il nodo mittente evita di saturare il nodo ricevente. I concetti di fondo sono gli stessi del livello trasporto.
	\item \textbf{Rilevazione degli errori}: Gli errori, al livello collegamento, sono causati dall’\textbf{attenuazione del segnale e da rumore
		      elettromagnetico}. Il nodo ricevente individua la presenza di errori grazie all’inserimento all’interno del frame, da parte del nodo mittente, di \textbf{bit di controllo dell' errore}.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/DLCerrors.png}
		      \centering
	      \end{figure}

	      Gli \textbf{errori} possono essere di \textbf{due} tipi: \textbf{a raffica} o \textbf{su singolo bit}. Quelli a raffica sono più comuni in quanto la durata del rumore è quasi sempre maggiore di un singolo bit.
	\item \textbf{Correzione degli errori}: il nodo ricevente determina anche il punto in cui si è verificato l’errore, e lo corregge.
\end{itemize}

\pagebreak

\subsection{Indirizzamento}

Un \textbf{indirizzo di livello collegamento} o \textbf{MAC address} è associato alla scheda di rete del dispositivo ed è \textbf{permanente}.

Per le LAN Ethernet (IEEE 802) l'indirizzo è lungo \textbf{6 byte}, gli indirizzi possibili sono $2^{48}$ ed è espresso in notazione esadecimale: 1A-63-F9-BD-06-9B. L'indirizzo di \textbf{broadcast} è: FF-FF-FF-FF-FF-FF.

L'\textbf{IEEE}, o Institute of Electrical and Electronics Engineers, definisce ed assegna \textbf{i primi 24 bit} detti anche \textbf{OUI} o \textbf{Organization Unique Identifier}, mentre i rimanenti 24 bit vengono gestiti dalle aziende ed assegnati a livello \textbf{locale}. Quando una società vuole costruire schede di rete compra un blocco di spazio di indirizzi per garantirne l'\textbf{univocità}.

Come detto poco prima, gli \textbf{indirizzi MAC} hanno una struttura \textbf{piatta} e sono \textbf{immutabili}, al contrario degli \textbf{indirizzi IP} che hanno una struttura \textbf{gerarchica} e sono \textbf{mutabili} (\textit{ma pur sempre univoci}).

Quando una scheda di rete spedisce un frame, vi inserisce l'indirizzo MAC della scheda di destinazione. Nel caso di reti LAN broadcast, tutte le schede attestate sulla rete controllano l'indirizzo destinazione e passano i dati allo strato superiore \textbf{solo se riconoscono il proprio indirizzo MAC nell'intestazione}. Se una scheda trasmittente vuole che \textbf{tutte} le schede di rete passino i dati agli strati superiori, immette nel campo indirizzo destinazione: FF-FF-FF-FF-FF-FF, ovvero
l'\textbf{indirizzo broadcast}.

\subsection{ARP}

Normalmente, all’\textbf{accensione}, una macchina conosce il suo \textbf{indirizzo MAC}, il suo \textbf{indirizzo IP}, la rete locale a cui appartiene e il suo indirizzo alfanumerico.  Supponiamo che voglia comunicare con un'altra macchina distante un certo numero di routers. La macchina mittente conosce l'indirizzo IP della macchina destinataria e l'indirizzo IP del router di default della sua rete locale. Ogni router tranne l'ultimo ricava l'indirizzo del router successivo dalla propria \textbf{tabella d'inoltro}. L'ultimo router conosce l'indirizzo IP dell'host di destinazione, tuttavia l'indirizzo IP non è sufficiente per la trasmissione di un frame lungo un collegamento, è necessario conoscere l'\textbf{indirizzo di collegamento del nodo successivo}.

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/ARP.png}
	\centering
	\caption{Posizione dell'ARP nello stack protocollare TCP/IP.}
\end{figure}

\pagebreak

L'\textbf{ARP} o \textbf{Address Resolution Protocol} è un protocollo ausiliario di livello rete, il suo scopo è quello di individuare l'indirizzo di collegamento associato ad un indirizzo IP.

Ogni volta che un host o un router vuole sapere l'indirizzo di collegamento di un altro host o router all'interno della sua rete invia, in \textbf{broadcast}, un pacchetto di richiesta ARP contenente il \textbf{proprio indirizzo IP}, il \textbf{proprio indirizzo di collegamento} e l'indirizzo IP dell'host o del router di cui vuole conoscere il MAC address.

Ogni nodo nella rete locale riceve ed elabora il pacchetto di richiesta ARP\@. Il nodo che riconosce il proprio indirizzo IP restituisce un pacchetto di risposta ARP che contiene il proprio indirizzo IP e il proprio indirizzo MAC\@. La risposta viene inviata in \textbf{unicast} direttamente al nodo che ha inviato la richiesta.

\begin{figure}[!h]
	\includegraphics[scale=0.37]{Immagini/ARP_fun.png}
	\includegraphics[scale=0.3]{Immagini/ARP_pkt.png}
	\centering
	\caption{Funzionamento e formato del pacchetto ARP.}
\end{figure}

\pagebreak

\begin{itemize}
	\item \textbf{Hardware Type}: indica protocollo di livello di collegamento usato.
	      (\textit{e.g.\  Ethernet 1})
	\item \textbf{Protocol Type}: indica protocollo di livello superiore usato. (\textit{e.g.\  IP})
	\item \textbf{Source Hardware Address e Source Protocol Address}:
	      contengono rispettivamente gli \textbf{indirizzi del nodo mittente a livello link e al livello rete}. Entrambi i campi sono di lunghezza variabile, da qui gli altri campi: Hardware Length e Protocol Length.
	\item \textbf{Destination Hardware Address e Destinaztion Protocol Address}: sono rispettivamente il MAC address che si vuole conoscere, il campo è \textbf{vuoto nelle richieste}, e l'indirizzo di rete del ricevente.
\end{itemize}

Ogni host e ogni router ha una \textbf{tabella ARP} che contiene le corrispondenze tra indirizzi IP e indirizzi MAC dei dispositivi interni alla propria sottorete.
Tuttavia è bene precisare che la tabella ARP non contiene necessariamente le corrispondenze per tutti i nodi della sottorete. Una entry della tabella ha il seguente formato:

\begin{center}
	\textbf{\large(Indirizzo IP - Indirizzo MAC - TTL)}
\end{center}

Il \textbf{TTL} o time to live indica quando bisognerà eliminare una
data voce nella tabella, il valore tipo è di \textbf{20 minuti}.

\begin{figure}[!h]
	\includegraphics[scale=0.25]{Immagini/ARP_tab.png}
	\centering
	\caption{Tabella ARP.}
\end{figure}

\textbf{ARP} è un protocollo \textbf{plug-and-play}: la tabella ARP di una macchina viene
costituita \textbf{automaticamente} e non deve essere configurata dall’amministratore del sistema.

Mostriamo ora un \textbf{esempio} di \textbf{forwarding diretto}:

\begin{enumerate}
	\item A vuole inviare un datagramma a B, e l’indirizzo MAC di B non è nella
	      tabella ARP di A. Allora trasmette in un pacchetto broadcast il messaggio di richiesta
	      ARP, contenente l’indirizzo IP di B e con indirizzo MAC del destinatario
	      l'indirizzo di broadcast \textbf{FF-FF-FF-FF-FF-FF}.
	\item Tutte le macchine della LAN ricevono una richiesta ARP.
	\item B riceve il pacchetto ARP, e risponde ad A comunicandogli il proprio indirizzo MAC.
	\item Il frame con la riposta ARP viene inviato all’indirizzo MAC di A.
\end{enumerate}

\pagebreak

E uno di \textbf{forwarding indiretto}: consideriamo l'invio di un datagramma da A a B attraverso il router R, ipotizzando che A conosca l'indirizzo IP di B.

Mostriamo in figura la configurazione:

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/ARP_example.png}
	\centering
\end{figure}

Nel router R ci sono \textbf{due} tabelle ARP, \textbf{una per ogni rete LAN} con cui esso si interfaccia.

\begin{enumerate}
	\item A crea un datagramma con origine A e destinazione B.
	\item A usa ARP per ottenere l’indirizzo MAC di R.
	\item A richiede alla scheda di rete di inviare un frame all’indirizzo MAC di
	      destinazione di R, il frame contiene il datagramma IP da A a B.
	\item La scheda di rete di A invia il frame.
	\item La scheda di rete di R riceve il fram.
	\item R estrae il datagramma IP dal frame Ethernet, e vede che la sua destinazione è B.
	\item R usa ARP per ottenere l’indirizzo MAC di B.
	\item R crea un frame contenente il datagramma IP da A a B e lo invia a B.
\end{enumerate}

Mostriamo ora, attraverso un esempio più articolato, cosa succede quando dal computer di Gaia, nella figura a pagina seguente, viene inviata una richiesta HTTP al server di Gabriele contenente la URL:

\begin{center}
	\textit{http://dagabriele.biz/prodotti}
\end{center}

Lavoreremo sotto le ipotesi che il computer di Gaia e quello di Gabriele appartengano a due reti LAN \textbf{diverse} e la connessione TCP tra il client HTTP di Gaia e il server HTTP di Gabriele sia già aperta.

\pagebreak

La figura sotto mostra la configurazione su cui lavoreremo.

\begin{figure}[!h]
	\includegraphics[scale=0.6]{Immagini/ARPexample.png}
	\centering
\end{figure}

La figura sopra mostra il flusso di pacchetti generati dal computer di Gaia: viene usato il \textbf{client HTTP} per soddisfare la richiesta, tuttavia egli non conosce l'indirizzo IP del server HTTP di Gabriele, contatta quindi il \textbf{resolver DNS} del computer di Gaia.

Il resolver DNS ottiene l'indirizzo IP richiesto e lo comunica al client HTTP che a sua invia la richiesta HTTP in un \textbf{segmento TCP}. La connessione TCP è già stata instaurata. Il segmento viene quindi consegnato al livello rete e incapsulato in un \textbf{datagramma IP}.

Lo strato di rete consulta la sua \textbf{tabella d'inoltro} e ne ricava che dovrà inviare il datagramma al router R1.

Non conoscendone però il MAC address, usa \textbf{ARP} per ricavarlo, e a quel punto, passa il datagramma al livello di collegamento che lo incapsula in un frame e lo invia sul collegamento verso R1.

\pagebreak

Descriviamo ora le attività interne al \textbf{router R1}:

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/ARPexample1.png}
	\centering
\end{figure}

Il router R1 \textbf{decapsula} il frame e il suo livello di rete, dopo aver effettuato il look-up nella tabella d'inoltro, determina che il datagramma IP deve essere inviato all'host con indirizzo IP N$_{B}$.

Il \textbf{MAC address} relativo non è però noto e viene ricavato tramite ARP\@. Il datagramma viene quindi passato al livello di collegamento, incapsulato in un frame e inviato verso il \textbf{server HTTP} di Gabriele.

\begin{figure}[!h]
	\includegraphics[scale=0.35]{Immagini/Router_model.png}
	\centering
\end{figure}

Infine il nel server HTTP di Gabriele, in figura alla pagina successiva:

Dal frame ricevuto dal suo livello di collegamento viene estratto il datagramma IP.

Il datagramma viene quindi passato al livello di rete e vi viene estratto il segmento TCP, contenente la \textbf{richiesta HTTP}, che viene a sua volta passato al livello trasporto, il quale estrae i dati applicativi, ovvero la richiesta HTTP, e li consegna alla socket in ascolto sulla porta nota \textbf{80}.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.53]{Immagini/ARPexample2.png}
	\centering
\end{figure}

\subsection{Ethernet}
L'\textbf{ETHERNET} è la tecnologia che detiene una posizione dominante nel mercato
delle LAN cablate. È stata la prima LAN ad alta velocità con vasta diffusione, essendo più semplice e meno costosa di token ring, FDDI e ATM.

Si è mantenuta inoltre sempre al passo dei tempi con il tasso trasmissivo pari a 10 Mbps (Ethernet Standard), 100Mbps, 1 Gbps, 10 Gbps.

\begin{figure}[!h]
	\includegraphics[scale=0.3]{Immagini/Original.png}
	\centering
	\caption{Il progetto originale di Bob Metcalfe che portò allo standard Ethernet.}
\end{figure}

\pagebreak

Per quel che concerne la topologia delle reti Ethernet fino alla metà degli anni '90 la tipologia più diffusa era quella a bus con cavo coassiale.
Tuttavia quasi tutte le odierne reti Ethernet sono progettate con topologia a \textbf{stella}, al centro della quale è collocato un \textbf{hub (switch)} o \textbf{commutatore}.

\begin{figure}[!h]
	\includegraphics[scale=0.37]{Immagini/Star_lan.png}
	\centering
\end{figure}

L’adattatore trasmittente incapsula i datagrammi IP in un
pacchetto Ethernet che ha la seguente struttura:

\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Ethernet_pkt.png}
	\centering
\end{figure}

I campi hanno i seguenti valori:

\begin{itemize}
	\item \textbf{Preamble}: I pacchetti Ethernet iniziano con un campo di otto byte: sette hanno i bit 10101010 e l’ultimo è 10101011. Il loro unico scopo è quello di notificare gli adattatori dei riceventi dell'arrivo del frame e sincronizzarne gli orologi con quello del trasmittente. Viene aggiunto al livello fisico e non fa propriamente parte del frame.
	\item \textbf{Dati}: L’unità massima di trasferimento o \textbf{MTU} varia da 46 byte ad un max di 1500 byte. Se il datagramma IP è più grande allora deve essere
	      frammentato prima di essere immesso sul collegamento. Se il campo dati è più piccolo il campo dati deve essere riempito o \textbf{stuffed}.
	\item \textbf{Indirizzo di destinazione}: è un campo composto da 6 byte.  Quando un adattatore riceve un pacchetto con indirizzo di
	      destinazione corrispondente al proprio indirizzo MAC o
	      l’indirizzo broadcast (\textit{e.g.\  un pacchetto ARP}), estrae il
	      contenuto del campo dati. I pacchetti con altri indirizzi MAC vengono \textbf{ignorati}.
	\item \textbf{Tipo}: è un campo lungo \textbf{due byte}, consente a Ethernet di supportare vari protocolli di rete (\textit{i.e. IP, ARP}). In gergo questo campo consente a Ethernet di \textit{multiplexare} i protocolli.
	\item \textbf{Controllo CRC}: consente all’adattatore ricevente di rilevare la
	      presenza di un errore nei bit del pacchetto.
\end{itemize}

\pagebreak

Descriviamo brevemente di seguito l'evoluzione di Ethernet:

\begin{itemize}
	\item \textbf{Fast Ethernet}:
	      \begin{itemize}
		      \item Velocità: 100 Mbps.
		      \item Mantiene invariati il formato e le dimensione sia minima che massima del frame.
		      \item La dimensione minima immutata e la trasmissione dieci volte più veloce implicano che la rete sia più piccola. Descriviamo \textbf{due} soluzioni possibili per far fronte a ciò:

		            O si introduce un hub passivo con topologia a stella oppure si usa un commutatore a livello link, dotato di buffer, e una connessione full-duplex per ogni host, in modo tale da \textit{evitare le collisioni}.
	      \end{itemize}
	\item \textbf{Gigabit Ethernet (802.3z)}:
	      \begin{itemize}
		      \item Velocità: 1000 Mbps o 1 Gbps.
		      \item Vengono mantenute invariate la lunghezza sia minima che massima del frame.
		      \item Lo switch è posto al centro della stella e tutti i nodi sono collegati ai suoi raggi per evitare le collisioni.
	      \end{itemize}
	\item \textbf{10-Gigabit Ethernet (802.3ae)}:
	      \begin{itemize}
		      \item Pensata per le \textbf{MAN} o \textbf{Metropolitan Area Networks}.
		      \item È un'estensione della tecnologia, incrementa la velocità trasferimento e la distanza di copertura massima.
	      \end{itemize}
\end{itemize}

\subsection{Dispositivi di interconnessione}
In questa sezione passeremo brevemente in rassegna vari tipi di dispositivi di interconnessione.
\subsubsection{Repeater e hub}
I \textbf{repeaters} sono dispositivi di interconnessione di \textbf{livello 1} e operano solo a livello fisico. Il loro funzionamento consiste nel ricevere un segnale e rigenerarlo.

In passato venivano usati per collegare segmenti di Ethernet con topologia a bus.

Un \textbf{hub} non è altro che repeater multi porta.

È importante precisare che nè i repeaters nè gli hubs hanno \textbf{capacità di filtraggio}, infatti come detto poco prima, operando solo a livello fisico \textbf{non hanno nessuna informazione circa gli indirizzi di collegamento} presenti nell'intestazione dei frame, il che vuol dire che inviano sempre il segnale su ogni loro porta.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.55]{Immagini/Hub.png}
	\centering
\end{figure}

\subsubsection{Switch di livello link}

Gli switch sono dispositivi di interconnessione di \textbf{livello 2}. Operano sia a livello fisico \textbf{rigenerando segnale} che a livello link \textbf{verificando gli indirizzi MAC} contenuti nei frames ed \textbf{hanno capacità di filtraggio}.

\begin{figure}[!h]
	\includegraphics[scale=0.45]{Immagini/Switch.png}
	\centering
\end{figure}

Posseggono una tabella detta \textbf{tabella di commutazione} che usano per effettuare il filtraggio dei datagrammi. Tale tabella viene costruita con l'ausilio di una \textbf{tecnologia di autoapprendimento} mediante il seguente procedimento: gli indirizzi destinazione dei frame vengono usati per determinare su quale interfaccia dello switch inoltrare il frame, quelli sorgente invece sono usati per aggiungere voci alla tabella di commutazione.

Tale processo potrebbe richiedere molto tempo, ad esempio, se da una stazione non dovesse esser trasmesso nessun frame essa non avrebbe mai una voce nella tabella di commutazione. Gli \textbf{switch, al contrario dei routers, non modificano gli indirizzi MAC} nell'intestazione dei frames.

\begin{figure}[!h]
	\includegraphics[scale=0.5]{Immagini/Comm_table.png}
	\centering
\end{figure}

A pagina seguente è presente una simulazione del processo di apprendimento.

\pagebreak

\begin{figure}[!h]
	\includegraphics[scale=0.4]{Immagini/Apprendimento.png}
	\centering
\end{figure}

\subsubsection{Router}
Il \textbf{router} è un dispositivo di interconnessione di \textbf{livello 3}, opera sia a \textbf{livello fisico}, rigenerando segnale, sia a \textbf{livello link}, verificando gli indirizzi MAC contenuti nei frames che a \textbf{livello network}, verificando gli indirizzi IP dei datagrammi. I routers sono diversi da ogni tipologia di dispositivi di interconnessione incontrata fin'ora, ecco \textbf{tre grandi differenze}:  essi \textbf{hanno un indirizzo MAC e un indirizzo IP per ogni loro interfaccia}, operano \textbf{solo sui frames il cui indirizzo destinazione di livello link è l’indirizzo link dell’interfaccia su cui sono ricevuti} e, inoltre, \textbf{cambiano gli indirizzi link} contenuti nei frames che inoltrano.

\subsection{Esercizi}

\begin{enumerate}
	\item Indicare, giustificando la risposta, se, e in che modo, frame Ethernet possono essere trasportati in pacchetti ARP o viceversa.

	      \textbf{Soluzione}:
	      I pacchetti ARP vengono trasportati nella parte dati dei frame Ethernet specificando ARP nel campo Type del preambolo, se l’host che esegue ARP appartiene a una rete Ethernet. Il viceversa non può invece avvenire dato che ARP è un servizio a livello di rete.

	\item Supponiamo che un cliente HTTP in esecuzione su un host A invii una
	      richiesta X a un server HTTP su un host B.

	      Supponendo che N sia un router
	      NAT e che R non lo sia, indicare i valori dei campi contenenti informazioni
	      di addressing negli header di livello datalink, rete e trasporto contenuti nel
	      frame che trasporta il messaggio X trasmesso da A e nel frame trasmesso,
	      in risposta, da B.

	      \pagebreak

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Eser.png}
		      \centering
	      \end{figure}

	      \textbf{Soluzione}:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Eser_sol.png}
		      \centering
	      \end{figure}

	\item Un Router R0 ha costruito la tabella di instradamento mostrata sotto. Il router può
	      consegnare pacchetti direttamente alle interfacce 0 e 1, oppure può inviare
	      pacchetti ai router R2, R3 o R4.

	      Descrivere le azioni del router quando deve
	      inoltrare un pacchetto indirizzato a ognuna delle seguenti destinazioni:

	      \begin{itemize}
		      \item 170.210.49.8
		      \item 170.210.50.11
		      \item 170.210.50.140
	      \end{itemize}

	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Eser1.png}
		      \centering
	      \end{figure}

	      \pagebreak

	      \textbf{Soluzione}:

	      Per ciascun pacchetto il router controlla se l’indirizzo di destinazione appartiene a una o più delle sottoreti nella tabella di forwarding.
	      170.210.49.8 appartiene alla rete 170.210.49.0/25:

	      [][][]00001000 [][][]000000000

	      non traduco in binario i primi 3 ottetti in quanto la maschera è 25 bit e i primi tre ottetti sono uguali. Il forwarding è diretto. Il router inoltra il pacchetto all’host destinatario tramite la sua interfaccia Eth0.


	      170.210.50.11 appartiene alla rete 170.210.50.0/25:

	      [][][]00001011 [][][] 00000000

	      Il forwarding è indiretto. Il router inoltra il pacchetto al router R2 tramite la sua interfaccia Eth1.

	      170.210.50.140 non appartiene a nessuna delle reti in tabella, viene quindi applicata la entry di default: il router invia il pacchetto a R4 tramite l’interfaccia S1
		      [][][]10001100.

	\item Giulia ha una piccola impresa. Chiede al suo ISP di darle un blocco di indirizzi per 1200 host. L’ISP alloca un sottoblocco dal range di indirizzi 192.1.* che possiede e dice a Maggie di utilizzare i
	      seguenti blocchi di indirizzi:

	      \begin{multicols}{2}
		      \begin{itemize}
			      \item 192.1.0.0/24
			      \item 192.1.1.0/24
			      \item 192.1.2.0/24
			      \item 192.1.3.0/24
			      \item 192.1.4.0/24
		      \end{itemize}
	      \end{multicols}

	      Come buona pratica, Maggie sa che deve annunciare il minimo numero possibile di rotte per coprire esattamente I suoi indirizzi IP.
	      \begin{enumerate}
		      \item Usando CIDR, qual è l’insieme più piccolo di indirizzi di rete che è possibile usare per annunciare la raggiungibilità delle reti di Maggie? Usare la notazione /n per indicare l’indirizzo di rete.

		            Maggie usa anche un secondo ISP\@.  I router della rete di Maggie annunciano le rotte ad entrambi gli ISP (senza applicare la buona pratica di cui sopra). Come risultato un router remoto in rete produce la seguente tabella di forwarding.

		            \begin{figure}[!h]
			            \includegraphics[scale=0.35]{Immagini/Eser2.png}
			            \centering
		            \end{figure}

		      \item Quale next hop usa il router per inoltrare un pacchetto destinato a 192.1.0.1?
	      \end{enumerate}

	      \pagebreak

	      \textbf{Soluzione}:

	      a) 192.1.0.0/22 e 192.1.4.0/24


	      b) C’è corrispondenza (match) con la prima e la seconda riga,
	      applicando il principio del longest prefix match, dovrebbe usare 1.2.3.5

	      \textbf{\underline{N.B.}} Attenzione ai casi in cui ci sono match multipli! Vale il criterio del \textbf{longest prefix}.

	\item Indicare le differenze principali tra IPv6 e IPv4
	      e relative motivazioni principali.

	      \textbf{Una possibile soluzione}:

	      \begin{itemize}
		      \item IPv6 usa indirizzi IP a 128 bit mentre IPv4 usa indirizzi IP a 32 bit, per
		            aumentare lo spazio degli indirizzi
		      \item IPv6 non implementa la frammentazione ai nodi intermedi, questa viene
		            implementata al nodo mittente, per velocizzare elaborazione e forwarding
		            pacchetti
		      \item In IPv6 non viene eseguita la checksum, come sopra per velocizzare
		            elaborazione e forwarding pacchetti
		      \item IPv6 ha un header di lunghezza fissa (40 byte), mentre in IPv4 l’header ha
		            lunghezza variabile (lunghezza min 20 byte), per velocizzare elaborazione
		            header
		      \item Introdotta una \textbf{flow label} per identificare i datagrams appartenenti allo stesso flow da trattare, eventualmente, secondo simili politiche di Quality Of Service, trattamento differenziato del traffico, ecc$\dots$
	      \end{itemize}

	\item Un router NAT è dotato di 6 interfacce di rete
	      a cui sono associati 4 indirizzi IP pubblici: 113.205.94.1, 113.205.94.2, 113.205.94.3, 113.205.94.4 e 2 indirizzi privati: 192.168.0.1 e 192.168.0.2. Indicare, giustificando la risposta, quanti sono i server FTP simultaneamente attivi nella rete NAT raggiungibili da host esterni.

	      \textbf{Soluzione}: Il numero di server FTP accessibili sulla porta 21
	      dall’esterno della rete NAT è \textbf{al più 4}, ovvero al più
	      uno per ogni indirizzo pubblico del router NAT.

	\item Consideriamo il frammento di sistema autonomo illustrato sotto:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Es7.png}
		      \centering
	      \end{figure}

	      \pagebreak

	      I router utilizzano RIP come protocollo intra-dominio e in cui B, C,
	      G, H sono router IPv6 mentre a, d, e, f sono router IPv4.

	      Supponiamo che G riceva da H un datagram P IPv6 contenente
	      \begin{center}
		      FE80::0202:B3FF:FE1E:8329
	      \end{center}
	      come indirizzo sorgente e l’indirizzo
	      IPv6 dell’interfaccia di B sul collegamento BC come indirizzo
	      destinazione. Supponendo che G utilizzi il tunneling per inoltrare
	      tale datagramma, indicare il contenuto dei campi indirizzo sorgente e
	      indirizzo destinazione del datagramma inoltrato da G: indicare
	      indirizzo sorgente e indirizzo destinazione nel datagramma, di livello
	      network, e del frame, di livello datalink.

	      \textbf{Soluzione}: A livello 3 il datagramma ha come IP sorgente l’ip di G sull’interfaccia IPv4 sul collegamento G-e e come IP destinazione C$_{ipv4}$, ovvero l'interfaccia sul collegamento C-d.
	      A livello datalink il frame ha come source address l’indirizzo di livello datalink di G$_{ipv4}$ e indirizzo di destinazione l’indirizzo datalink di e sul collegamento e-G.

	\item Data la topologia raffigurata, determinare la
	      tabella di forwarding del router R1.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.4]{Immagini/Es8.png}
		      \centering
	      \end{figure}

	      \textbf{Soluzione}:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.35]{Immagini/Es8_sol.png}
		      \centering
	      \end{figure}

	      \pagebreak

	\item Data la topologia di rete in figura in cui i nodi rappresentano dei routers, ipotizzando un costo unitario per ciascun collegamento, e usando
	      l’algoritmo Distance Vector:
	      \begin{enumerate}
		      \item Definire la tabella di forwarding per A, dopo la convergenza.\textbf{}
		      \item Ad un certo punto il nodo E si guasta, calcolare la tabella di B
		            dopo la convergenza.
	      \end{enumerate}

	      \begin{figure}[!h]
		      \includegraphics[scale=0.3]{Immagini/Es9.png}
		      \centering
	      \end{figure}

	      \textbf{Soluzione}: A sinistra il punto a) e a destra il punto b).
	      \begin{figure}[!h]
		      \includegraphics[scale=0.25]{Immagini/Es9_sol1.png}
		      \includegraphics[scale=0.25]{Immagini/Es9_sol2.png}
		      \centering
	      \end{figure}

	\item Consideriamo uno switch con autoapprendimento dotato di 5 porte a cui sono connessi 5 computer:
	      \begin{itemize}
		      \item il computer A con indirizzo MAC V alla porta 1.
		      \item il computer B con indirizzo MAC W alla porta 2.
		      \item il computer C con indirizzo MAC X alla porta 3.
		      \item il computer D con indirizzo MAC Y alla porta 4.
		      \item il computer E con indirizzo MAC Z alla porta 5.
	      \end{itemize}

	      Indicare il contenuto della tabella di
	      commutazione dello switch nell'ipotesi che
	      quando essa è inizialmente vuota vengano inviati
	      nell'ordine i seguenti frame: da A a C, da C a E, da D ad A, da B ad E, da E a B e da C ad A. \textbf{Soluzione}:

	      \begin{figure}[!h]
		      \includegraphics[scale=0.27]{Immagini/Es10_sol.png}
		      \centering
	      \end{figure}

	      \pagebreak

	\item A una rete IP è assegnato l’insieme di indirizzi definiti dall’indirizzo 208.57.0.0 e netmask: 255.255.0.0.
	      Occorre partizionare la rete in modo da servire una vecchia rete locale con circa 4000 host; quale netmask
	      serve per definire la sotto-rete per i circa 4000 host? Quale indirizzo di rete gli si può associare? (\textit{la risposta a questa domanda non è univoca}) Quante altre reti delle stesse dimensioni si possono definire? Quante reti con circa 60 host si possono ulteriormente definire nel rimanente spazio di indirizzi dopo aver assegnato la sottorete per i
	      4000 host e con quale nuova netmask?

	      \textbf{Soluzione}:

	      La sottorete per 4000 host ha una subnetmask pari a 255.255.240.0 in quanto $2^{12}$ fa 4096. Il suo indirizzo di rete è 208.57.0.0/20.
	      Si possono definire altre $2^{4}$ - 1 = 15 sottoreti da 4000 host.
	      Per le sottoreti di circa 60 host servono 6 bit per gli host e 26 bit per la rete, quindi la netmask è 255.255.255.192.
	      Le sottoreti possibili sono $15 \times 2^{6}$ = 15*64.

	\item Per una Intranet si ha a disposizione l’indirizzo di rete 129.174.0.0 con netmask: 255.255.0.0. Nella Intranet
	      occorre installare almeno 15 reti locali collegate mediante dei router; descrivere come possono essere ricavati gli indirizzi per le sotto-reti e dire quanti host al massimo possono contenere le sotto-reti. Infine,
	      dire a quali sottoreti appartengono i seguenti indirizzi specificando se si tratta di indirizzi di host o di
	      indirizzi speciali: 129.174.28.66 129.174.99.122 129.174.130.255 129.174.191.255.

	      \textbf{Soluzione}:

	      Devono essere dedicati 4 bit per indirizzo di rete poichè $2^{4} = 16$.
	      12 bit per gli host, in totale ci saranno $2^{12}$ = 4096 - 2 host, vanno sottratti infatti indirizzo di rete e di broadcast.
	      L'indirizzo 129.174.28.66 appartiene a 129.174.16.0/20.
	      L'indirizzo 129.174.99.122 appartiene alla rete di indirizzo 129.174.96.0.
	      L'indirizzo 129.174.130.255 appartiene alla rete di indirizzo 129.174.128.0/20.
	      L'indirizzo 129.174.191.255 appartiene alla rete di indirizzo 129.174.176.0/20 ed è l'indirizzo di broadcast.

	\item Un amministratore di rete deve gestire una campus LAN a cui è assegnato il blocco di indirizzi 150.10.0.0/16.

	      Assumendo che la rete comprenda 100 sottoreti ognuna delle quali è connessa ad un router usando uno switch, definire una appropriata subnet mask se il numero massimo di host connessi ad ogni subnet è 70.

	      \textbf{Soluzione}: Una subnet di 70 host ha 25 bit di sottorete e 7 bit per i dispositivi poiché $2^{7}$ = 128, la subnet mask sarà quindi 255.255.255.128.

	      \pagebreak

	\item Considerare la topologia nella figura seguente.

	      \begin{figure}[!h]
		      \includegraphics[scale=0.5]{Immagini/Es11.png}
		      \centering
	      \end{figure}

	      I nodi utilizzano l’algoritmo distance vector per il calcolo dei cammini minimi. Dire:
	      \begin{enumerate}
		      \item Qual è lo stato della tabella di routing di ogni nodo prima del primo scambio di distance vectors?
		      \item Supponiamo ora che siano avvenuti scambi di distance vectors tra i seguenti nodi:

		            E $\rightarrow$ C ; B $\rightarrow$ A ; C $\rightarrow$ A ;

		            Mostrare come sono modificate le tabelle di routing.

		            \textbf{Soluzione}:
		            \begin{figure}[!h]
			            \includegraphics[scale=0.63]{Immagini/Es11_sol.png}
			            \centering
		            \end{figure}
	      \end{enumerate}
	      \pagebreak
\end{enumerate}

\chapter{Cenni su VLAN, P2P e sicurezza}

\textit{Illustriamo di seguito i contenuti di questo capitolo: un'introduzione alla tecnologia VLAN o Virtual Local Area Network, applicazioni P2P o Peer To Peer e una breve introduzione alla sicurezza.}

\section{VLAN}
Prima di affrontare direttamente l'argomento si prenda in considerazione la LAN illustrata in figura:

\begin{wrapfigure}{L} {0.5\textwidth}
	\includegraphics[scale=0.35]{Immagini/Vlan.png}
	\centering
\end{wrapfigure}

I dispositivi sono organizzati in \textbf{quattro segmenti LAN}, un segmento LAN è infatti costituito da uno switch e da tutti gli end systems ad esso connessi. Si supponga, ai fini dell'esempio, che i tre segmenti LAN in basso siano cinque distinti dipartimenti universitari e il quarto segmento, in alto, sia una server farm utilizzata da due dei dipartimenti. Supponiamo ora che l'host X debba inviare un frame a tutti gli altri dispositivi del suo dipartimento e che ragionevolmente lo invii in \textbf{broadcast}. A ricevere il frame saranno però tutti i dispositivi della LAN, anche quelli non interessati, come ad esempio gli altri dipartimenti e la server farm. Il dominio di \textbf{broadcast} è infatti l'intera LAN\@. Ciò crea però uno \textbf{spreco} di capacità trasmissiva. Come si può evitare ciò?

\pagebreak

\begin{wrapfigure}{L} {0.5\textwidth}
	\includegraphics[scale=0.35]{Immagini/Vlan1.png}
	\centering
\end{wrapfigure}
Un approccio molto semplice per evitare lo scenario descritto nell'esempio di prima e di conseguenza aumentare l'efficienza della comunicazione, è descritto nella figura a sinistra, e consiste nel \textbf{partizionare fisicamente la LAN} in domini di broadcast diversi. La configurazione così ottenuta infatti consiste di quattro LAN separate e connesse da un router, dove ciascuna LAN ha il proprio dominio di broadcast limitato ai dispositivi connessi allo switch.

Un'altra soluzione possibile, illustrata della figura a destra, è invece quella di partizionare \textbf{logicamente}, non fisicamente, la LAN in varie \textbf{VLAN o virtual local area network}.

\begin{wrapfigure}{R} {0.5\textwidth}
	\includegraphics[scale=0.35]{Immagini/Vlan2.png}
	\centering
\end{wrapfigure}
 
Una \textbf{VLAN} è un \textbf{dominio di broadcast} composto da un gruppo di dispositivi che comunicano come se facessero parte di una stessa LAN ma che sono in realtà fisicamente situati in \textbf{luoghi diversi}. Tutta la logica della VLAN è implementata al livello link e per consentire la comunicazione tra VLAN diverse è necessario un router che le colleghi. Una VLAN \textbf{non} è quindi limitata da un singolo switch. Tornando all'esempio precedente, una partizione via VLAN consente a ogni organizzazione dipartimentale di far parte di uno stesso gruppo pur essendo fisicamente distante l'una dall'altra. Ma come fare, proprio a causa della distanza fisica, a stabilire che un host appartiene a una determinata VLAN? 

Di seguito verranno illustrati \textbf{tre} meccanismi che consentono di stabilire l'appartenenza di un host ad una VLAN.

\begin{enumerate}
	\item \textbf{Appartenenza per porta}: ad ogni porta di ogni switch della LAN corrisponde una VLAN. 
	
	\pagebreak 
	
	Una configurazione sì fatta ha il vantaggio di essere facile da  impostare tuttavia se un host cambia porta dello switch bisogna riconfigurare l'appartenenzaz.
	
	\item \textbf{Appartenenza per indirizzo MAC}: sono configurazioni di VLAN in cui, ad ogni VLAN, è associato un \textbf{gruppo di indirizzi}. Così facendo si risolve il problema di prima, un host che cambia la porta dello switch continua ad appartenere alla VLAN, infatti il suo indirizzo MAC resta immutato. Lo svantaggio è che l'appartenenza ad una VLAN per indirizzo MAC va assegnata \textbf{almeno una volta} ad ogni dispositivo.
	
	\item \textbf{Appartenenza per informazioni protocollari}: è un meccanismo molto flessibile che permette di determinare l'appartenenza di un dispositivo alla VLAN attraverso il suo \textbf{indirizzo IP}, il suo \textbf{protocollo di trasporto} o altre \textbf{informazioni proprie degli stack protocollari superiori al livello link}. Lo svantaggio principale è dato dal fatto che, per far ciò, lo switch deve accedere a porzioni del frame che non gli competono e ciò causa un declino delle prestazioni. 
\end{enumerate}

Prima di concludere la sezione, resta però da risolvere un ultimo problema, ovvero, come può uno switch distinguere l'appartenenza ad una VLAN \textbf{quando il traffico arriva da una sola porta}. Gli switch hanno infatti due tipi di porte: 

\begin{enumerate}
	\item \textbf{Porte tronco o trunk ports}: le porte tronco connettono uno switch ad un \textbf{altro switch} e trasmettono il traffico di più VLAN.
	\item \textbf{Porte di accesso o end ports}: le porte di accesso connettono uno switch ad un \textbf{host}.
\end{enumerate}

Una pratica soluzione consiste nel \textbf{frame tagging}, ovvero l'inserimento all'interno di ogni frame di un header per indicare a quale VLAN è indirizzato il frame. Infatti, all'interno di una LAN, ad ogni VLAN è assegnato un \textbf{VID o vlan id} univoco compreso tra 1 e 4094. L'header viene aggiunto al frame prima che esso sia inoltrato su una porta tronco e viene poi rimosso prima che il frame sia inoltrato su una porta di accesso.

\begin{figure}[!h]
	\includegraphics[scale=0.28]{Immagini/Vlan_tagging.png}
	\centering
\end{figure}

\pagebreak

\end{document}
